{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"source/images/colllor.jpg","path":"images/colllor.jpg","modified":0,"renderable":0},{"_id":"source/images/colr.jpg","path":"images/colr.jpg","modified":0,"renderable":0},{"_id":"source/images/component.jpg","path":"images/component.jpg","modified":0,"renderable":0},{"_id":"source/images/CSD.jpg","path":"images/CSD.jpg","modified":0,"renderable":0},{"_id":"source/images/jekyll.png","path":"images/jekyll.png","modified":0,"renderable":0},{"_id":"source/images/kuler.jpg","path":"images/kuler.jpg","modified":0,"renderable":0},{"_id":"source/images/linguistic.png","path":"images/linguistic.png","modified":0,"renderable":0},{"_id":"source/images/pair-model.jpg","path":"images/pair-model.jpg","modified":0,"renderable":0},{"_id":"source/images/pro-angularjs.png","path":"images/pro-angularjs.png","modified":0,"renderable":0},{"_id":"source/images/programmingpearls.jpg","path":"images/programmingpearls.jpg","modified":0,"renderable":0},{"_id":"source/images/refactoring.jpg","path":"images/refactoring.jpg","modified":0,"renderable":0},{"_id":"source/images/stylus.jpg","path":"images/stylus.jpg","modified":0,"renderable":0},{"_id":"source/images/angular.jpg","path":"images/angular.jpg","modified":0,"renderable":0},{"_id":"source/images/clastic-pair.jpg","path":"images/clastic-pair.jpg","modified":0,"renderable":0},{"_id":"source/images/cleancode.jpg","path":"images/cleancode.jpg","modified":0,"renderable":0}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1638098231990},{"_id":"themes/landscape/.npmignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1638098231990},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1638098231990},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1638098231990},{"_id":"themes/landscape/README.md","hash":"37fae88639ef60d63bd0de22314d7cc4c5d94b07","modified":1638098231990},{"_id":"themes/landscape/_config.yml","hash":"79ac6b9ed6a4de5a21ea53fc3f5a3de92e2475ff","modified":1638098231990},{"_id":"themes/landscape/package.json","hash":"544f21a0b2c7034998b36ae94dba6e3e0f39f228","modified":1638098231990},{"_id":"themes/landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1638098231990},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1638098231990},{"_id":"themes/landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1638098231990},{"_id":"themes/landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1638098231990},{"_id":"themes/landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1638098231990},{"_id":"themes/landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1638098231990},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1638098231990},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1638098231990},{"_id":"themes/landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1638098231990},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1638098231990},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1638098231990},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1638098231990},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1638098231990},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1638098231990},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1638098231990},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1638098231990},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1638098231990},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1638098231990},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1638098231990},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1638098231990},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"d0d753d39038284d52b10e5075979cc97db9cd20","modified":1638098231990},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1638098231990},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"950ddd91db8718153b329b96dc14439ab8463ba5","modified":1638098231990},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"c4c835615d96a950d51fa2c3b5d64d0596534fed","modified":1638098231990},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1638098231990},{"_id":"themes/landscape/layout/_partial/gauges-analytics.ejs","hash":"aad6312ac197d6c5aaf2104ac863d7eba46b772a","modified":1638098231990},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1638098231990},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"5abf77aec957d9445fc71a8310252f0013c84578","modified":1638098231990},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"7e749050be126eadbc42decfbea75124ae430413","modified":1638098231990},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1638098231990},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1638098231990},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1638098231990},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1638098231990},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1638098231990},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1638098231990},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1638098231990},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1638098231990},{"_id":"themes/landscape/source/css/_variables.styl","hash":"628e307579ea46b5928424313993f17b8d729e92","modified":1638098232000},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1638098232000},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1638098232000},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1638098232000},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1638098232000},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1638098232000},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1638098232000},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1638098232000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1638098232000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1638098232000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1638098232000},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1638098231990},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1638098231990},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1638098231990},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1638098231990},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1638098231990},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1638098231990},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1638098231990},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1638098232000},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1638098232000},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1638098232000},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1638098232000},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1638098232000},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1638098232000},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1638098232000},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1638098232000},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1638098232000},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1638098232000},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1638098232000},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1638098232000},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1638098232000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1638098232000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1638098232000},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1638098232000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1638098232000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1638098232000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1638098232000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1638098232000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1638098232000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1638098232000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1638098232000},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1638098232000},{"_id":"source/_posts/2013-02-05-https.md","hash":"0862be899067d28e10ac3745d940538b2a95293a","modified":1638099447160},{"_id":"source/_posts/2013-03-05-pointer-lock.md","hash":"fcecbe9afa69354ee26e769d382d37ff3474dbbb","modified":1638099447160},{"_id":"source/_posts/2013-04-28-create.md","hash":"5acccf3a59355e9e9257c7607e98b8497a27690b","modified":1638100769970},{"_id":"source/_posts/2013-05-04-Refactoring.md","hash":"de6c56a08c1205aa45ea9a8b827bba4231e47687","modified":1638099447160},{"_id":"source/_posts/2013-05-21-design-tools.md","hash":"af925d6b19b368f7368989def181fdc3f94c81c0","modified":1638100769970},{"_id":"source/_posts/2013-05-26-Programming-Pearls.md","hash":"2c06e7e0fdfa2a79eea892cb2103725af11adf95","modified":1638100769970},{"_id":"source/_posts/2013-05-29-design-tools2.md","hash":"8be821986dca532803ea597665e2cf3fb41b1da5","modified":1638099447160},{"_id":"source/_posts/2013-06-06-event-keycode.md","hash":"cd975a3183e1ed59a03b6f677fbe8143652f1e48","modified":1638099447160},{"_id":"source/_posts/2013-07-10-unit-test.md","hash":"72f18b18d28556c793bf2848085e87e8434181a8","modified":1638099447160},{"_id":"source/_posts/2013-08-21-html5-upload-file.md","hash":"d020cb66a9d0b940b455e803e0225730fd056558","modified":1638099447160},{"_id":"source/_posts/2013-09-25-improve-workflow.md","hash":"514273f3277ad37a8b2bb8bf0969b6d03c7f1b59","modified":1638099447160},{"_id":"source/_posts/2013-11-16-stylus-guide.md","hash":"948d872073d0c5b8acd5aa7d7f14bf8910b7b9f2","modified":1638100769970},{"_id":"source/_posts/2013-11-26-clean-code.md","hash":"a9e16b0bf2da71dad7895c26fb440487206b6402","modified":1638100769970},{"_id":"source/_posts/2014-03-16-css-principle.md","hash":"458d2f139c8d0e827b37888ac39f0593a32843d7","modified":1638099447160},{"_id":"source/_posts/2014-07-21-template-of-angularjs.md","hash":"d1a540b4896f3ff4eecab4a48b181f80319e09a5","modified":1638100769970},{"_id":"source/_posts/2015-03-14-thinking-in-semantic-css.md","hash":"9a87ce436794981bcefe714f950459b24c2c65a6","modified":1638100769970},{"_id":"source/_posts/2015-06-20-five-whys-for-css.md","hash":"c5e76319945eb29887539389cfb2e57db4b7a310","modified":1638099447160},{"_id":"source/_posts/2015-09-01-translate-pro-angularjs.md","hash":"e7c112cb190272d9459465cceb361ec93894d10c","modified":1638100769970},{"_id":"source/_posts/2016-05-26-clastic-pair-programing.md","hash":"1a0784354126093bb76aee19e1e37a6873dea6b9","modified":1638100769970},{"_id":"source/_posts/2017-02-17-frontend-architecture.md","hash":"6cc543030937b8e8a2f896b5bef6a152b5dd39d2","modified":1638100769970},{"_id":"source/_posts/2013-05-04-refactoring.md","hash":"ea389373753dee1644482b4bfedd2a8642d485af","modified":1638100769970},{"_id":"source/_posts/2013-04-28-create/jekyll.png","hash":"3ccdb547cb8961ae7409f6813fa3efc2acf0831e","modified":1638099951560},{"_id":"source/_posts/2013-04-28-create2/jekyll.png","hash":"3ccdb547cb8961ae7409f6813fa3efc2acf0831e","modified":1638099951560},{"_id":"source/_posts/2013/04/28/create/jekyll.png","hash":"3ccdb547cb8961ae7409f6813fa3efc2acf0831e","modified":1638099951560},{"_id":"source/images/CSD.jpg","hash":"0758959fa623ee2b2c917724aa7211233ba1e5b1","modified":1638099951560},{"_id":"source/images/angular.jpg","hash":"6e0f1d084ee2e2d595cd16961a4d2368f7ab09e1","modified":1638099951560},{"_id":"source/images/cleancode.jpg","hash":"8b451b34f9214f7a3fc7e9aaaad7933cde81046b","modified":1638099951560},{"_id":"source/images/colllor.jpg","hash":"28b5386e44c6ae89572fd1fd4ae58478872c7862","modified":1638099951560},{"_id":"source/images/colr.jpg","hash":"96d4fb23c12102d2c6d37b4fe58c92b934a96971","modified":1638099951560},{"_id":"source/images/jekyll.png","hash":"3ccdb547cb8961ae7409f6813fa3efc2acf0831e","modified":1638099951560},{"_id":"source/images/kuler.jpg","hash":"39c554881595efcc5f24326599c48ee58446cf7d","modified":1638099951560},{"_id":"source/images/linguistic.png","hash":"641345a613853a9b1bd11539022d163c3d113c8e","modified":1638099951560},{"_id":"source/images/pair-model.jpg","hash":"d949081d43572285cf6357fa465c17eaaf478172","modified":1638099951560},{"_id":"source/images/programmingpearls.jpg","hash":"ec688d9e3961c3b279ddb146564adeb28cb6920e","modified":1638099951570},{"_id":"source/images/refactoring.jpg","hash":"0b809a7d3289d82568befa9f56ae33da89a1b031","modified":1638099951570},{"_id":"source/images/stylus.jpg","hash":"03385acb2f322b83421b62051f999c0423f1fdd2","modified":1638099951570},{"_id":"source/images/clastic-pair.jpg","hash":"250f73bdb59a8e9eb209ac70516b0fcca60ce18f","modified":1638099951560},{"_id":"source/images/component.jpg","hash":"246b9b759f02d7e8d0697b1ac13f369fbd281b01","modified":1638099951560},{"_id":"source/images/pro-angularjs.png","hash":"21b22442937ff78c85018da7259b2c747309f708","modified":1638099951570}],"Category":[{"name":"Tech","_id":"ckwj6550t0002vyjh2knef928"},{"name":"Read","_id":"ckwj65512000hvyjh5v541b43"},{"name":"Work","_id":"ckwj6551c001dvyjh7qod5ezr"}],"Data":[],"Page":[],"Post":[{"layout":"post","title":"Https协议握手流程","_content":"\n今天在segmentfault上和某人探讨了一下这个https的握手流程，其实我一开始也不是很清楚，也没有好好去思考过，通过回答这个问题，对https有了更深的认识。\n\n首先我搜索到的流程正规说法是：\n<!-- more -->\n1. 用户浏览器将其SSL版本号、加密设置参数、与session有关的数据以及其它一些必要信息发送到服务器。 \n\n2. 服务器将其SSL版本号、加密设置参数、与session有关的数据以及其它一些必要信息发送给浏览器，同时发给浏览器的还有服务器的证书。如果配置服务器的SSL需要验证用户身份，还要发出请求要求浏览器提供用户证书。 \n\n3. 客户端检查服务器证书，如果检查失败，提示不能建立SSL连接。如果成功，那么继续。 \n\n4. 客户端浏览器为本次会话生成pre-master secret，并将其用服务器公钥加密后发送给服务器。 \n\n5. 如果服务器要求鉴别客户身份，客户端还要再对另外一些数据签名后并将其与客户端证书一起发送给服务器。 \n\n6. 如果服务器要求鉴别客户身份，则检查签署客户证书的CA是否可信。如果不在信任列表中，结束本次会话。如果检查通过，服务器用自己的私钥解密收到的pre-master secret，并用它通过某些算法生成本次会话的master secret。 \n\n7. 客户端与服务器均使用此master secret生成本次会话的会话密钥(对称密钥)。在双方SSL握手结束后传递任何消息均使用此会话密钥。这样做的主要原因是对称加密比非对称加密的运算量低一个数量级以上，能够显著提高双方会话时的运算速度。 \n\n8. 客户端通知服务器此后发送的消息都使用这个会话密钥进行加密。并通知服务器客户端已经完成本次SSL握手。 \n\n9. 服务器通知客户端此后发送的消息都使用这个会话密钥进行加密。并通知客户端服务器已经完成本次SSL握手。 \n\n10. 本次握手过程结束，会话已经建立。双方使用同一个会话密钥分别对发送以及接受的信息进行加、解密。\n\n---\n\n我理解的简化说法是：\n\nc端请求，s端响应并提供证书；\n\nc端检查接收后生成pre-master-securet使用s端发过来的公钥加密；\n\ns端接收到后使用私钥解密，并最终通过某种算法生成master-securet；\n\n后续的通信中s和c端均使用这个master-securet生成的密钥。\n\n其中，提问者有一个疑问，为什么要有2个master-securet. 对此，最后我们得出的结论是\n\n握手过程中服务器生成私钥和公钥，将公钥发给客户端，所以握手过程中为非对称加密。\n\n最终使用master-securet生成密钥，使用对称加密通信。\n\n前面使用非对称，后面使用对称加密，是因为对称加密效率高。\n\n由于不信任机器生成的随机数，所以需要客户端生成pre-master-securet，然后再由服务端加密，最后得到master-securet，减少被猜中的可能。","source":"_posts/2013-02-05-https.md","raw":"---\nlayout: post\ntitle: Https协议握手流程\ntags: [http,https,protocol,协议]\ncategory: Tech\n---\n\n今天在segmentfault上和某人探讨了一下这个https的握手流程，其实我一开始也不是很清楚，也没有好好去思考过，通过回答这个问题，对https有了更深的认识。\n\n首先我搜索到的流程正规说法是：\n<!-- more -->\n1. 用户浏览器将其SSL版本号、加密设置参数、与session有关的数据以及其它一些必要信息发送到服务器。 \n\n2. 服务器将其SSL版本号、加密设置参数、与session有关的数据以及其它一些必要信息发送给浏览器，同时发给浏览器的还有服务器的证书。如果配置服务器的SSL需要验证用户身份，还要发出请求要求浏览器提供用户证书。 \n\n3. 客户端检查服务器证书，如果检查失败，提示不能建立SSL连接。如果成功，那么继续。 \n\n4. 客户端浏览器为本次会话生成pre-master secret，并将其用服务器公钥加密后发送给服务器。 \n\n5. 如果服务器要求鉴别客户身份，客户端还要再对另外一些数据签名后并将其与客户端证书一起发送给服务器。 \n\n6. 如果服务器要求鉴别客户身份，则检查签署客户证书的CA是否可信。如果不在信任列表中，结束本次会话。如果检查通过，服务器用自己的私钥解密收到的pre-master secret，并用它通过某些算法生成本次会话的master secret。 \n\n7. 客户端与服务器均使用此master secret生成本次会话的会话密钥(对称密钥)。在双方SSL握手结束后传递任何消息均使用此会话密钥。这样做的主要原因是对称加密比非对称加密的运算量低一个数量级以上，能够显著提高双方会话时的运算速度。 \n\n8. 客户端通知服务器此后发送的消息都使用这个会话密钥进行加密。并通知服务器客户端已经完成本次SSL握手。 \n\n9. 服务器通知客户端此后发送的消息都使用这个会话密钥进行加密。并通知客户端服务器已经完成本次SSL握手。 \n\n10. 本次握手过程结束，会话已经建立。双方使用同一个会话密钥分别对发送以及接受的信息进行加、解密。\n\n---\n\n我理解的简化说法是：\n\nc端请求，s端响应并提供证书；\n\nc端检查接收后生成pre-master-securet使用s端发过来的公钥加密；\n\ns端接收到后使用私钥解密，并最终通过某种算法生成master-securet；\n\n后续的通信中s和c端均使用这个master-securet生成的密钥。\n\n其中，提问者有一个疑问，为什么要有2个master-securet. 对此，最后我们得出的结论是\n\n握手过程中服务器生成私钥和公钥，将公钥发给客户端，所以握手过程中为非对称加密。\n\n最终使用master-securet生成密钥，使用对称加密通信。\n\n前面使用非对称，后面使用对称加密，是因为对称加密效率高。\n\n由于不信任机器生成的随机数，所以需要客户端生成pre-master-securet，然后再由服务端加密，最后得到master-securet，减少被猜中的可能。","slug":"https","published":1,"date":"2013-02-04T16:00:00.000Z","updated":"2021-11-28T11:37:27.160Z","comments":1,"photos":[],"link":"","_id":"ckwj6550n0000vyjh838xcfma","content":"<p>今天在segmentfault上和某人探讨了一下这个https的握手流程，其实我一开始也不是很清楚，也没有好好去思考过，通过回答这个问题，对https有了更深的认识。</p>\n<p>首先我搜索到的流程正规说法是：</p>\n<span id=\"more\"></span>\n<ol>\n<li><p>用户浏览器将其SSL版本号、加密设置参数、与session有关的数据以及其它一些必要信息发送到服务器。 </p>\n</li>\n<li><p>服务器将其SSL版本号、加密设置参数、与session有关的数据以及其它一些必要信息发送给浏览器，同时发给浏览器的还有服务器的证书。如果配置服务器的SSL需要验证用户身份，还要发出请求要求浏览器提供用户证书。 </p>\n</li>\n<li><p>客户端检查服务器证书，如果检查失败，提示不能建立SSL连接。如果成功，那么继续。 </p>\n</li>\n<li><p>客户端浏览器为本次会话生成pre-master secret，并将其用服务器公钥加密后发送给服务器。 </p>\n</li>\n<li><p>如果服务器要求鉴别客户身份，客户端还要再对另外一些数据签名后并将其与客户端证书一起发送给服务器。 </p>\n</li>\n<li><p>如果服务器要求鉴别客户身份，则检查签署客户证书的CA是否可信。如果不在信任列表中，结束本次会话。如果检查通过，服务器用自己的私钥解密收到的pre-master secret，并用它通过某些算法生成本次会话的master secret。 </p>\n</li>\n<li><p>客户端与服务器均使用此master secret生成本次会话的会话密钥(对称密钥)。在双方SSL握手结束后传递任何消息均使用此会话密钥。这样做的主要原因是对称加密比非对称加密的运算量低一个数量级以上，能够显著提高双方会话时的运算速度。 </p>\n</li>\n<li><p>客户端通知服务器此后发送的消息都使用这个会话密钥进行加密。并通知服务器客户端已经完成本次SSL握手。 </p>\n</li>\n<li><p>服务器通知客户端此后发送的消息都使用这个会话密钥进行加密。并通知客户端服务器已经完成本次SSL握手。 </p>\n</li>\n<li><p>本次握手过程结束，会话已经建立。双方使用同一个会话密钥分别对发送以及接受的信息进行加、解密。</p>\n</li>\n</ol>\n<hr>\n<p>我理解的简化说法是：</p>\n<p>c端请求，s端响应并提供证书；</p>\n<p>c端检查接收后生成pre-master-securet使用s端发过来的公钥加密；</p>\n<p>s端接收到后使用私钥解密，并最终通过某种算法生成master-securet；</p>\n<p>后续的通信中s和c端均使用这个master-securet生成的密钥。</p>\n<p>其中，提问者有一个疑问，为什么要有2个master-securet. 对此，最后我们得出的结论是</p>\n<p>握手过程中服务器生成私钥和公钥，将公钥发给客户端，所以握手过程中为非对称加密。</p>\n<p>最终使用master-securet生成密钥，使用对称加密通信。</p>\n<p>前面使用非对称，后面使用对称加密，是因为对称加密效率高。</p>\n<p>由于不信任机器生成的随机数，所以需要客户端生成pre-master-securet，然后再由服务端加密，最后得到master-securet，减少被猜中的可能。</p>\n","site":{"data":{}},"excerpt":"<p>今天在segmentfault上和某人探讨了一下这个https的握手流程，其实我一开始也不是很清楚，也没有好好去思考过，通过回答这个问题，对https有了更深的认识。</p>\n<p>首先我搜索到的流程正规说法是：</p>","more":"<ol>\n<li><p>用户浏览器将其SSL版本号、加密设置参数、与session有关的数据以及其它一些必要信息发送到服务器。 </p>\n</li>\n<li><p>服务器将其SSL版本号、加密设置参数、与session有关的数据以及其它一些必要信息发送给浏览器，同时发给浏览器的还有服务器的证书。如果配置服务器的SSL需要验证用户身份，还要发出请求要求浏览器提供用户证书。 </p>\n</li>\n<li><p>客户端检查服务器证书，如果检查失败，提示不能建立SSL连接。如果成功，那么继续。 </p>\n</li>\n<li><p>客户端浏览器为本次会话生成pre-master secret，并将其用服务器公钥加密后发送给服务器。 </p>\n</li>\n<li><p>如果服务器要求鉴别客户身份，客户端还要再对另外一些数据签名后并将其与客户端证书一起发送给服务器。 </p>\n</li>\n<li><p>如果服务器要求鉴别客户身份，则检查签署客户证书的CA是否可信。如果不在信任列表中，结束本次会话。如果检查通过，服务器用自己的私钥解密收到的pre-master secret，并用它通过某些算法生成本次会话的master secret。 </p>\n</li>\n<li><p>客户端与服务器均使用此master secret生成本次会话的会话密钥(对称密钥)。在双方SSL握手结束后传递任何消息均使用此会话密钥。这样做的主要原因是对称加密比非对称加密的运算量低一个数量级以上，能够显著提高双方会话时的运算速度。 </p>\n</li>\n<li><p>客户端通知服务器此后发送的消息都使用这个会话密钥进行加密。并通知服务器客户端已经完成本次SSL握手。 </p>\n</li>\n<li><p>服务器通知客户端此后发送的消息都使用这个会话密钥进行加密。并通知客户端服务器已经完成本次SSL握手。 </p>\n</li>\n<li><p>本次握手过程结束，会话已经建立。双方使用同一个会话密钥分别对发送以及接受的信息进行加、解密。</p>\n</li>\n</ol>\n<hr>\n<p>我理解的简化说法是：</p>\n<p>c端请求，s端响应并提供证书；</p>\n<p>c端检查接收后生成pre-master-securet使用s端发过来的公钥加密；</p>\n<p>s端接收到后使用私钥解密，并最终通过某种算法生成master-securet；</p>\n<p>后续的通信中s和c端均使用这个master-securet生成的密钥。</p>\n<p>其中，提问者有一个疑问，为什么要有2个master-securet. 对此，最后我们得出的结论是</p>\n<p>握手过程中服务器生成私钥和公钥，将公钥发给客户端，所以握手过程中为非对称加密。</p>\n<p>最终使用master-securet生成密钥，使用对称加密通信。</p>\n<p>前面使用非对称，后面使用对称加密，是因为对称加密效率高。</p>\n<p>由于不信任机器生成的随机数，所以需要客户端生成pre-master-securet，然后再由服务端加密，最后得到master-securet，减少被猜中的可能。</p>"},{"layout":"post","title":"使用Pointer Lock技术","_content":"\n所谓的mouselook其实就是第一人称视角，而[pointerlock技术](http://www.w3.org/TR/pointerlock/ \"pointerlock技术\")（其实和第一人称没什么关系,只是说这个技术可以用来实现第一人称）其核心就是让鼠标隐藏并且无论怎么拖动鼠标，鼠标指针都不会跑出目标区域。\n<!-- more -->\n用法：\n\n* requestPointerLock 是最主要的方法，进入pointerlock模式，在chrome会出现像fullscreen一样的提示，是否隐藏鼠标，按esc键可以退出该模式。需要加上浏览器前缀，moz或者webkit，像这样element.webkitRequestPointerLock()。不过在firefox中测试用不了，具体还没来得及调，不知道什么情况。\n\n* pointerlockchange 是一个事件event，用addEventListener绑定给一个方法，在切换模式时就可以触发该方法。同样需要添加前缀。\n\n* pointerLockElement 是当前为pointerlock模式的元素，用来检查目标元素是否进入了该模式，比如document.pointerLockElement === element。一样添加前缀。\n\n* movementX/movementY 在pointerlock模式中，鼠标是隐藏并且不动的，因此要获取此时的鼠标动作，需要这个属性。存在与事件event中，比如在mousemove时间中，像这样e.movementX直接使用。需要加上前缀。\n\n以下是一个简单的Demo：\n\n    (function ($, undefined) {\n        var mouse = {\n            x: -1,\n            y: -1\n        };\n        document.addEventListener('pointerlockchange', change, false);\n        document.addEventListener('mozpointerlockchange', change, false);\n        document.addEventListener('webkitpointerlockchange', change, false);\n        $(\"#canvas\").click(function () {\n            var canvas = $(\"#canvas\").get()[0];\n            canvas.requestPointerLock = canvas.requestPointerLock || canvas.mozRequestPointerLock || canvas.webkitRequestPointerLock \n            || canvas.oRequestPointerLock || canvas.msRequestPointerLock;\n            canvas.requestPointerLock();\n        });\n\n        function change(e) {\n            var canvas = $(\"#canvas\").get()[0];\n            if (document.pointerLockElement === canvas || document.mozPointerLockElement === canvas || document.webkitPointerLockElement === canvas) {\n                document.addEventListener(\"mousemove\", move, false);\n            } else {\n                document.removeEventListener(\"mousemove\", move, false);\n                mouse = {\n                    x: -1,\n                    y: -1\n                };\n            }\n        };\n\n        function move(e) {\n            var canvas = $(\"#canvas\").get()[0];\n            var ctx = canvas.getContext('2d');\n            if (mouse.x == -1) {\n                mouse = _position(canvas, e);\n            }\n            var movementX = e.movementX || e.mozMovementX || e.webkitMovementX || 0;\n            var movementY = e.movementY || e.mozMovementY || e.webkitMovementY || 0;\n            mouse.x = mouse.x + movementX;\n            mouse.y = mouse.y + movementY;\n            if (mouse.x > $('#canvas').width() - 50) {\n                mouse.x = $('#canvas').width() - 50;\n            } else if (mouse.x < 0) {\n                mouse.x = 0;\n            }\n            if (mouse.y > $('#canvas').height() - 50) {\n                mouse.y = $('#canvas').height() - 50;\n            } else if (mouse.y < 0) {\n                mouse.y = 0;\n            }\n            ctx.clearRect(0, 0, 400, 400);\n            _show(mouse.x, mouse.y, ctx);\n        }\n\n        function _position(canvas, event) {\n            var x, y;\n            if (event.x != undefined && event.y != undefined) {\n                x = event.x;\n                y = event.y;\n            } else {\n                x = event.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;\n                y = event.clientY + document.body.scrollTop + document.documentElement.scrollTop;\n            }\n            x -= canvas.offsetLeft;\n            y -= canvas.offsetTop;\n            return {\n                x: x,\n                y: y\n            };\n        }\n\n        function _show(_x, _y, _ctx) {\n            _ctx.fillStyle = 'red';\n            _ctx.fillRect(0, 0, _x, _y);\n        }\n    })(jQuery);\n\n\n[Fiddle Demo](http://jsfiddle.net/tyrantchiong/NUTt8/2/ \"Fiddle Demo\")","source":"_posts/2013-03-05-pointer-lock.md","raw":"---\nlayout: post\ntitle: 使用Pointer Lock技术\ntags: [html,html5,mouse look,鼠标视角]\ncategory: Tech\n---\n\n所谓的mouselook其实就是第一人称视角，而[pointerlock技术](http://www.w3.org/TR/pointerlock/ \"pointerlock技术\")（其实和第一人称没什么关系,只是说这个技术可以用来实现第一人称）其核心就是让鼠标隐藏并且无论怎么拖动鼠标，鼠标指针都不会跑出目标区域。\n<!-- more -->\n用法：\n\n* requestPointerLock 是最主要的方法，进入pointerlock模式，在chrome会出现像fullscreen一样的提示，是否隐藏鼠标，按esc键可以退出该模式。需要加上浏览器前缀，moz或者webkit，像这样element.webkitRequestPointerLock()。不过在firefox中测试用不了，具体还没来得及调，不知道什么情况。\n\n* pointerlockchange 是一个事件event，用addEventListener绑定给一个方法，在切换模式时就可以触发该方法。同样需要添加前缀。\n\n* pointerLockElement 是当前为pointerlock模式的元素，用来检查目标元素是否进入了该模式，比如document.pointerLockElement === element。一样添加前缀。\n\n* movementX/movementY 在pointerlock模式中，鼠标是隐藏并且不动的，因此要获取此时的鼠标动作，需要这个属性。存在与事件event中，比如在mousemove时间中，像这样e.movementX直接使用。需要加上前缀。\n\n以下是一个简单的Demo：\n\n    (function ($, undefined) {\n        var mouse = {\n            x: -1,\n            y: -1\n        };\n        document.addEventListener('pointerlockchange', change, false);\n        document.addEventListener('mozpointerlockchange', change, false);\n        document.addEventListener('webkitpointerlockchange', change, false);\n        $(\"#canvas\").click(function () {\n            var canvas = $(\"#canvas\").get()[0];\n            canvas.requestPointerLock = canvas.requestPointerLock || canvas.mozRequestPointerLock || canvas.webkitRequestPointerLock \n            || canvas.oRequestPointerLock || canvas.msRequestPointerLock;\n            canvas.requestPointerLock();\n        });\n\n        function change(e) {\n            var canvas = $(\"#canvas\").get()[0];\n            if (document.pointerLockElement === canvas || document.mozPointerLockElement === canvas || document.webkitPointerLockElement === canvas) {\n                document.addEventListener(\"mousemove\", move, false);\n            } else {\n                document.removeEventListener(\"mousemove\", move, false);\n                mouse = {\n                    x: -1,\n                    y: -1\n                };\n            }\n        };\n\n        function move(e) {\n            var canvas = $(\"#canvas\").get()[0];\n            var ctx = canvas.getContext('2d');\n            if (mouse.x == -1) {\n                mouse = _position(canvas, e);\n            }\n            var movementX = e.movementX || e.mozMovementX || e.webkitMovementX || 0;\n            var movementY = e.movementY || e.mozMovementY || e.webkitMovementY || 0;\n            mouse.x = mouse.x + movementX;\n            mouse.y = mouse.y + movementY;\n            if (mouse.x > $('#canvas').width() - 50) {\n                mouse.x = $('#canvas').width() - 50;\n            } else if (mouse.x < 0) {\n                mouse.x = 0;\n            }\n            if (mouse.y > $('#canvas').height() - 50) {\n                mouse.y = $('#canvas').height() - 50;\n            } else if (mouse.y < 0) {\n                mouse.y = 0;\n            }\n            ctx.clearRect(0, 0, 400, 400);\n            _show(mouse.x, mouse.y, ctx);\n        }\n\n        function _position(canvas, event) {\n            var x, y;\n            if (event.x != undefined && event.y != undefined) {\n                x = event.x;\n                y = event.y;\n            } else {\n                x = event.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;\n                y = event.clientY + document.body.scrollTop + document.documentElement.scrollTop;\n            }\n            x -= canvas.offsetLeft;\n            y -= canvas.offsetTop;\n            return {\n                x: x,\n                y: y\n            };\n        }\n\n        function _show(_x, _y, _ctx) {\n            _ctx.fillStyle = 'red';\n            _ctx.fillRect(0, 0, _x, _y);\n        }\n    })(jQuery);\n\n\n[Fiddle Demo](http://jsfiddle.net/tyrantchiong/NUTt8/2/ \"Fiddle Demo\")","slug":"pointer-lock","published":1,"date":"2013-03-04T16:00:00.000Z","updated":"2021-11-28T11:37:27.160Z","comments":1,"photos":[],"link":"","_id":"ckwj6550s0001vyjhdl7lbeii","content":"<p>所谓的mouselook其实就是第一人称视角，而<a href=\"http://www.w3.org/TR/pointerlock/\" title=\"pointerlock技术\">pointerlock技术</a>（其实和第一人称没什么关系,只是说这个技术可以用来实现第一人称）其核心就是让鼠标隐藏并且无论怎么拖动鼠标，鼠标指针都不会跑出目标区域。</p>\n<span id=\"more\"></span>\n<p>用法：</p>\n<ul>\n<li><p>requestPointerLock 是最主要的方法，进入pointerlock模式，在chrome会出现像fullscreen一样的提示，是否隐藏鼠标，按esc键可以退出该模式。需要加上浏览器前缀，moz或者webkit，像这样element.webkitRequestPointerLock()。不过在firefox中测试用不了，具体还没来得及调，不知道什么情况。</p>\n</li>\n<li><p>pointerlockchange 是一个事件event，用addEventListener绑定给一个方法，在切换模式时就可以触发该方法。同样需要添加前缀。</p>\n</li>\n<li><p>pointerLockElement 是当前为pointerlock模式的元素，用来检查目标元素是否进入了该模式，比如document.pointerLockElement === element。一样添加前缀。</p>\n</li>\n<li><p>movementX/movementY 在pointerlock模式中，鼠标是隐藏并且不动的，因此要获取此时的鼠标动作，需要这个属性。存在与事件event中，比如在mousemove时间中，像这样e.movementX直接使用。需要加上前缀。</p>\n</li>\n</ul>\n<p>以下是一个简单的Demo：</p>\n<pre><code>(function ($, undefined) &#123;\n    var mouse = &#123;\n        x: -1,\n        y: -1\n    &#125;;\n    document.addEventListener(&#39;pointerlockchange&#39;, change, false);\n    document.addEventListener(&#39;mozpointerlockchange&#39;, change, false);\n    document.addEventListener(&#39;webkitpointerlockchange&#39;, change, false);\n    $(&quot;#canvas&quot;).click(function () &#123;\n        var canvas = $(&quot;#canvas&quot;).get()[0];\n        canvas.requestPointerLock = canvas.requestPointerLock || canvas.mozRequestPointerLock || canvas.webkitRequestPointerLock \n        || canvas.oRequestPointerLock || canvas.msRequestPointerLock;\n        canvas.requestPointerLock();\n    &#125;);\n\n    function change(e) &#123;\n        var canvas = $(&quot;#canvas&quot;).get()[0];\n        if (document.pointerLockElement === canvas || document.mozPointerLockElement === canvas || document.webkitPointerLockElement === canvas) &#123;\n            document.addEventListener(&quot;mousemove&quot;, move, false);\n        &#125; else &#123;\n            document.removeEventListener(&quot;mousemove&quot;, move, false);\n            mouse = &#123;\n                x: -1,\n                y: -1\n            &#125;;\n        &#125;\n    &#125;;\n\n    function move(e) &#123;\n        var canvas = $(&quot;#canvas&quot;).get()[0];\n        var ctx = canvas.getContext(&#39;2d&#39;);\n        if (mouse.x == -1) &#123;\n            mouse = _position(canvas, e);\n        &#125;\n        var movementX = e.movementX || e.mozMovementX || e.webkitMovementX || 0;\n        var movementY = e.movementY || e.mozMovementY || e.webkitMovementY || 0;\n        mouse.x = mouse.x + movementX;\n        mouse.y = mouse.y + movementY;\n        if (mouse.x &gt; $(&#39;#canvas&#39;).width() - 50) &#123;\n            mouse.x = $(&#39;#canvas&#39;).width() - 50;\n        &#125; else if (mouse.x &lt; 0) &#123;\n            mouse.x = 0;\n        &#125;\n        if (mouse.y &gt; $(&#39;#canvas&#39;).height() - 50) &#123;\n            mouse.y = $(&#39;#canvas&#39;).height() - 50;\n        &#125; else if (mouse.y &lt; 0) &#123;\n            mouse.y = 0;\n        &#125;\n        ctx.clearRect(0, 0, 400, 400);\n        _show(mouse.x, mouse.y, ctx);\n    &#125;\n\n    function _position(canvas, event) &#123;\n        var x, y;\n        if (event.x != undefined &amp;&amp; event.y != undefined) &#123;\n            x = event.x;\n            y = event.y;\n        &#125; else &#123;\n            x = event.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;\n            y = event.clientY + document.body.scrollTop + document.documentElement.scrollTop;\n        &#125;\n        x -= canvas.offsetLeft;\n        y -= canvas.offsetTop;\n        return &#123;\n            x: x,\n            y: y\n        &#125;;\n    &#125;\n\n    function _show(_x, _y, _ctx) &#123;\n        _ctx.fillStyle = &#39;red&#39;;\n        _ctx.fillRect(0, 0, _x, _y);\n    &#125;\n&#125;)(jQuery);\n</code></pre>\n<p><a href=\"http://jsfiddle.net/tyrantchiong/NUTt8/2/\" title=\"Fiddle Demo\">Fiddle Demo</a></p>\n","site":{"data":{}},"excerpt":"<p>所谓的mouselook其实就是第一人称视角，而<a href=\"http://www.w3.org/TR/pointerlock/\" title=\"pointerlock技术\">pointerlock技术</a>（其实和第一人称没什么关系,只是说这个技术可以用来实现第一人称）其核心就是让鼠标隐藏并且无论怎么拖动鼠标，鼠标指针都不会跑出目标区域。</p>","more":"<p>用法：</p>\n<ul>\n<li><p>requestPointerLock 是最主要的方法，进入pointerlock模式，在chrome会出现像fullscreen一样的提示，是否隐藏鼠标，按esc键可以退出该模式。需要加上浏览器前缀，moz或者webkit，像这样element.webkitRequestPointerLock()。不过在firefox中测试用不了，具体还没来得及调，不知道什么情况。</p>\n</li>\n<li><p>pointerlockchange 是一个事件event，用addEventListener绑定给一个方法，在切换模式时就可以触发该方法。同样需要添加前缀。</p>\n</li>\n<li><p>pointerLockElement 是当前为pointerlock模式的元素，用来检查目标元素是否进入了该模式，比如document.pointerLockElement === element。一样添加前缀。</p>\n</li>\n<li><p>movementX/movementY 在pointerlock模式中，鼠标是隐藏并且不动的，因此要获取此时的鼠标动作，需要这个属性。存在与事件event中，比如在mousemove时间中，像这样e.movementX直接使用。需要加上前缀。</p>\n</li>\n</ul>\n<p>以下是一个简单的Demo：</p>\n<pre><code>(function ($, undefined) &#123;\n    var mouse = &#123;\n        x: -1,\n        y: -1\n    &#125;;\n    document.addEventListener(&#39;pointerlockchange&#39;, change, false);\n    document.addEventListener(&#39;mozpointerlockchange&#39;, change, false);\n    document.addEventListener(&#39;webkitpointerlockchange&#39;, change, false);\n    $(&quot;#canvas&quot;).click(function () &#123;\n        var canvas = $(&quot;#canvas&quot;).get()[0];\n        canvas.requestPointerLock = canvas.requestPointerLock || canvas.mozRequestPointerLock || canvas.webkitRequestPointerLock \n        || canvas.oRequestPointerLock || canvas.msRequestPointerLock;\n        canvas.requestPointerLock();\n    &#125;);\n\n    function change(e) &#123;\n        var canvas = $(&quot;#canvas&quot;).get()[0];\n        if (document.pointerLockElement === canvas || document.mozPointerLockElement === canvas || document.webkitPointerLockElement === canvas) &#123;\n            document.addEventListener(&quot;mousemove&quot;, move, false);\n        &#125; else &#123;\n            document.removeEventListener(&quot;mousemove&quot;, move, false);\n            mouse = &#123;\n                x: -1,\n                y: -1\n            &#125;;\n        &#125;\n    &#125;;\n\n    function move(e) &#123;\n        var canvas = $(&quot;#canvas&quot;).get()[0];\n        var ctx = canvas.getContext(&#39;2d&#39;);\n        if (mouse.x == -1) &#123;\n            mouse = _position(canvas, e);\n        &#125;\n        var movementX = e.movementX || e.mozMovementX || e.webkitMovementX || 0;\n        var movementY = e.movementY || e.mozMovementY || e.webkitMovementY || 0;\n        mouse.x = mouse.x + movementX;\n        mouse.y = mouse.y + movementY;\n        if (mouse.x &gt; $(&#39;#canvas&#39;).width() - 50) &#123;\n            mouse.x = $(&#39;#canvas&#39;).width() - 50;\n        &#125; else if (mouse.x &lt; 0) &#123;\n            mouse.x = 0;\n        &#125;\n        if (mouse.y &gt; $(&#39;#canvas&#39;).height() - 50) &#123;\n            mouse.y = $(&#39;#canvas&#39;).height() - 50;\n        &#125; else if (mouse.y &lt; 0) &#123;\n            mouse.y = 0;\n        &#125;\n        ctx.clearRect(0, 0, 400, 400);\n        _show(mouse.x, mouse.y, ctx);\n    &#125;\n\n    function _position(canvas, event) &#123;\n        var x, y;\n        if (event.x != undefined &amp;&amp; event.y != undefined) &#123;\n            x = event.x;\n            y = event.y;\n        &#125; else &#123;\n            x = event.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;\n            y = event.clientY + document.body.scrollTop + document.documentElement.scrollTop;\n        &#125;\n        x -= canvas.offsetLeft;\n        y -= canvas.offsetTop;\n        return &#123;\n            x: x,\n            y: y\n        &#125;;\n    &#125;\n\n    function _show(_x, _y, _ctx) &#123;\n        _ctx.fillStyle = &#39;red&#39;;\n        _ctx.fillRect(0, 0, _x, _y);\n    &#125;\n&#125;)(jQuery);\n</code></pre>\n<p><a href=\"http://jsfiddle.net/tyrantchiong/NUTt8/2/\" title=\"Fiddle Demo\">Fiddle Demo</a></p>"},{"layout":"post","title":"在Github上创建一个博客","_content":"\n##创建##\n\n![jakyll](/images/jekyll.png)使用Github创建博客，项目名必须是username.github.io，然后直接使用主分支master即可。github使用的jekyll会自动根据相关文件生成一个_site文件夹，包括整个blog的静态文件用于访问。\n\n_layouts文件夹为模板文件夹，可以创建一个default(自定)的html文件作为模板，并使用{{content}}作为模板接受的内容变量，另外还有{{page.title}}之类的变量。\n_posts文件夹为博客文章文件夹，发布文章的格式为yyyy-mm-dd-blogname，也就说文章的日期是自定的。格式可以使用html、md、textile。当然更易于管理的方式是建立Year>Month>Day这样的目录结构。\n<!-- more -->\n无论是模板还是页面都可以在文件的开始，写入YAML的配置信息，使用三个横杠分隔，像这样：\n\n    ---\n    layout: post\n    category: Other\n    tags: github page blog config\n    title: Create Blog on Github\n    ---\n\n最关键的是_config.yml文件，这个是jekyll的配置文件。其中auto为boolean值，是否自动根据修改重建网站静态文件。\n\n    destination: ./_site\n    auto:        true\n    lsi:         false\n\n当然根目录中的index.html是必不可少的首页了，另外也许还需要一个about.html之类的页面，都放在根目录中即可，然后在模板中的导航直接放入这些页面的链接。如果不喜欢有HTML这样的后缀，可以使用文件夹代替，并在文件夹中使用index.html这样的名字。比如`about/index.html` 在访问时路径为www.example.com/about/\n\n更详细的wiki可以看这里,[Jekyll Wiki](https://github.com/mojombo/jekyll/wiki)，可以查看各种配置和使用方法。或者访问[Jekyll主页](http://jekyllrb.com/docs/home/)\n\n##评论##\n\n我使用的是[Disqus](http://disqus.com/)第三方评论，国内的模仿者还有[友言](http://uyan.cc/)、[灯鹭](http://denglu.cc/)、[多说](http://duoshuo.com/)等，它们大致的原理都一样，引入一段js，然后动态加载一个iframe，将第三方提供的输入框和评论数据呈现出来，另外这需要一个帐号，用来保存和管理你的评论。\n\n首先注册一个Disqus的帐号，然后输入需要添加评论的网站地址，以及名称和简称，然后会自动生成一段js代码，和一个div，这个div就是容器，只要放到你的网站中需要放置评论的地方就可以了。js代码可以放在body的最后加载。\n\n\n    var disqus_shortname = 'tychio blog';\n    var disqus_title = '{{ page.title }}';\n    var disqus_identifier = '{{ page.id }}';\n    var disqus_url = 'http://www.tychio.net/{{ page.url }}';\n\n    (function() {\n        var dsq = document.createElement('script'); \n        dsq.type = 'text/javascript'; dsq.async = true;\n        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n    })();\n\ndisqus_shortname是简称，disqus_title是标题，disqus_identifier是标识，disqus_url是地址。\n\n另外disqus可以自动根据网站样式生成样式，我没有做任何样式的修改，disqus就生成了文字颜色与我的blog一致的评论框。\n\n## 本地环境 ##\n\nJekyll是由Ruby编写的，所以首先需要下载Ruby，在[这里下载Ruby1.9.3](http://rubyinstaller.org/downloads/)，注意不能下载Ruby2，之后会出现问题。\n\n在下载页面中还能找到DevKit，也一并下载了，注意自己的操作系统选择对应的版本。\n\nRuby的安装很简单，如果是安装版连环境变量都不用配置。然后是DevKit稍微复杂点，需要几行命令：\n\n    cd /d/DevKit/\n    ruby dk.rb init\n    ruby dk.rb install\n\n如此基本环境就准备好了，然后使用gem安装jekyll：\n\n    gem install jekyll\n\n最后在需要建立blog的文件夹下，使用以下命令即可创建jekyll博客。\n\n    jekyll new\n\n然后无论是否用jekyll创建的blog，在其目录下使用以下命令即可在本地启动jekyll服务：\n\n    jekyll serve\n\n这条命令其实还包含了build命令用以生成_site文件夹，也就是博客的静态页面。如果希望每次修改都会生成，可以使用参数--watch或-w\n\n    jekyll serve -w\n\n这样一个基本的Jekyll博客就建好了，把除了_site的其他文件push到github上即可用有自己的Blog了。","source":"_posts/2013-04-28-create.md","raw":"---\nlayout: post\ntitle: 在Github上创建一个博客\ntags: [github,jekyll,pages]\ncategory: Tech\n---\n\n##创建##\n\n![jakyll](/images/jekyll.png)使用Github创建博客，项目名必须是username.github.io，然后直接使用主分支master即可。github使用的jekyll会自动根据相关文件生成一个_site文件夹，包括整个blog的静态文件用于访问。\n\n_layouts文件夹为模板文件夹，可以创建一个default(自定)的html文件作为模板，并使用{{content}}作为模板接受的内容变量，另外还有{{page.title}}之类的变量。\n_posts文件夹为博客文章文件夹，发布文章的格式为yyyy-mm-dd-blogname，也就说文章的日期是自定的。格式可以使用html、md、textile。当然更易于管理的方式是建立Year>Month>Day这样的目录结构。\n<!-- more -->\n无论是模板还是页面都可以在文件的开始，写入YAML的配置信息，使用三个横杠分隔，像这样：\n\n    ---\n    layout: post\n    category: Other\n    tags: github page blog config\n    title: Create Blog on Github\n    ---\n\n最关键的是_config.yml文件，这个是jekyll的配置文件。其中auto为boolean值，是否自动根据修改重建网站静态文件。\n\n    destination: ./_site\n    auto:        true\n    lsi:         false\n\n当然根目录中的index.html是必不可少的首页了，另外也许还需要一个about.html之类的页面，都放在根目录中即可，然后在模板中的导航直接放入这些页面的链接。如果不喜欢有HTML这样的后缀，可以使用文件夹代替，并在文件夹中使用index.html这样的名字。比如`about/index.html` 在访问时路径为www.example.com/about/\n\n更详细的wiki可以看这里,[Jekyll Wiki](https://github.com/mojombo/jekyll/wiki)，可以查看各种配置和使用方法。或者访问[Jekyll主页](http://jekyllrb.com/docs/home/)\n\n##评论##\n\n我使用的是[Disqus](http://disqus.com/)第三方评论，国内的模仿者还有[友言](http://uyan.cc/)、[灯鹭](http://denglu.cc/)、[多说](http://duoshuo.com/)等，它们大致的原理都一样，引入一段js，然后动态加载一个iframe，将第三方提供的输入框和评论数据呈现出来，另外这需要一个帐号，用来保存和管理你的评论。\n\n首先注册一个Disqus的帐号，然后输入需要添加评论的网站地址，以及名称和简称，然后会自动生成一段js代码，和一个div，这个div就是容器，只要放到你的网站中需要放置评论的地方就可以了。js代码可以放在body的最后加载。\n\n\n    var disqus_shortname = 'tychio blog';\n    var disqus_title = '{{ page.title }}';\n    var disqus_identifier = '{{ page.id }}';\n    var disqus_url = 'http://www.tychio.net/{{ page.url }}';\n\n    (function() {\n        var dsq = document.createElement('script'); \n        dsq.type = 'text/javascript'; dsq.async = true;\n        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n    })();\n\ndisqus_shortname是简称，disqus_title是标题，disqus_identifier是标识，disqus_url是地址。\n\n另外disqus可以自动根据网站样式生成样式，我没有做任何样式的修改，disqus就生成了文字颜色与我的blog一致的评论框。\n\n## 本地环境 ##\n\nJekyll是由Ruby编写的，所以首先需要下载Ruby，在[这里下载Ruby1.9.3](http://rubyinstaller.org/downloads/)，注意不能下载Ruby2，之后会出现问题。\n\n在下载页面中还能找到DevKit，也一并下载了，注意自己的操作系统选择对应的版本。\n\nRuby的安装很简单，如果是安装版连环境变量都不用配置。然后是DevKit稍微复杂点，需要几行命令：\n\n    cd /d/DevKit/\n    ruby dk.rb init\n    ruby dk.rb install\n\n如此基本环境就准备好了，然后使用gem安装jekyll：\n\n    gem install jekyll\n\n最后在需要建立blog的文件夹下，使用以下命令即可创建jekyll博客。\n\n    jekyll new\n\n然后无论是否用jekyll创建的blog，在其目录下使用以下命令即可在本地启动jekyll服务：\n\n    jekyll serve\n\n这条命令其实还包含了build命令用以生成_site文件夹，也就是博客的静态页面。如果希望每次修改都会生成，可以使用参数--watch或-w\n\n    jekyll serve -w\n\n这样一个基本的Jekyll博客就建好了，把除了_site的其他文件push到github上即可用有自己的Blog了。","slug":"create","published":1,"date":"2013-04-27T16:00:00.000Z","updated":"2021-11-28T11:59:29.970Z","_id":"ckwj6550v0004vyjha4wa1gaq","comments":1,"photos":[],"link":"","content":"<p>##创建##</p>\n<p><img src=\"/images/jekyll.png\" alt=\"jakyll\">使用Github创建博客，项目名必须是username.github.io，然后直接使用主分支master即可。github使用的jekyll会自动根据相关文件生成一个_site文件夹，包括整个blog的静态文件用于访问。</p>\n<p>_layouts文件夹为模板文件夹，可以创建一个default(自定)的html文件作为模板，并使用</p><p>##创建##</p>\n<p><img src=\"/images/jekyll.png\" alt=\"jakyll\">使用Github创建博客，项目名必须是username.github.io，然后直接使用主分支master即可。github使用的jekyll会自动根据相关文件生成一个_site文件夹，包括整个blog的静态文件用于访问。</p>\n<p>_layouts文件夹为模板文件夹，可以创建一个default(自定)的html文件作为模板，并使用{{content}}作为模板接受的内容变量，另外还有{{page.title}}之类的变量。<br>_posts文件夹为博客文章文件夹，发布文章的格式为yyyy-mm-dd-blogname，也就说文章的日期是自定的。格式可以使用html、md、textile。当然更易于管理的方式是建立Year&gt;Month&gt;Day这样的目录结构。</p>\n<span id=\"more\"></span>\n<p>无论是模板还是页面都可以在文件的开始，写入YAML的配置信息，使用三个横杠分隔，像这样：</p>\n<pre><code>---\nlayout: post\ncategory: Other\ntags: github page blog config\ntitle: Create Blog on Github\n---\n</code></pre>\n<p>最关键的是_config.yml文件，这个是jekyll的配置文件。其中auto为boolean值，是否自动根据修改重建网站静态文件。</p>\n<pre><code>destination: ./_site\nauto:        true\nlsi:         false\n</code></pre>\n<p>当然根目录中的index.html是必不可少的首页了，另外也许还需要一个about.html之类的页面，都放在根目录中即可，然后在模板中的导航直接放入这些页面的链接。如果不喜欢有HTML这样的后缀，可以使用文件夹代替，并在文件夹中使用index.html这样的名字。比如<code>about/index.html</code> 在访问时路径为<a href=\"http://www.example.com/about/\">www.example.com/about/</a></p>\n<p>更详细的wiki可以看这里,<a href=\"https://github.com/mojombo/jekyll/wiki\">Jekyll Wiki</a>，可以查看各种配置和使用方法。或者访问<a href=\"http://jekyllrb.com/docs/home/\">Jekyll主页</a></p>\n<p>##评论##</p>\n<p>我使用的是<a href=\"http://disqus.com/\">Disqus</a>第三方评论，国内的模仿者还有<a href=\"http://uyan.cc/\">友言</a>、<a href=\"http://denglu.cc/\">灯鹭</a>、<a href=\"http://duoshuo.com/\">多说</a>等，它们大致的原理都一样，引入一段js，然后动态加载一个iframe，将第三方提供的输入框和评论数据呈现出来，另外这需要一个帐号，用来保存和管理你的评论。</p>\n<p>首先注册一个Disqus的帐号，然后输入需要添加评论的网站地址，以及名称和简称，然后会自动生成一段js代码，和一个div，这个div就是容器，只要放到你的网站中需要放置评论的地方就可以了。js代码可以放在body的最后加载。</p>\n<pre><code>var disqus_shortname = &#39;tychio blog&#39;;\nvar disqus_title = &#39;{{ page.title }}&#39;;\nvar disqus_identifier = &#39;{{ page.id }}&#39;;\nvar disqus_url = &#39;http://www.tychio.net/{{ page.url }}&#39;;\n\n(function() {\n    var dsq = document.createElement(&#39;script&#39;); \n    dsq.type = &#39;text/javascript&#39;; dsq.async = true;\n    dsq.src = &#39;//&#39; + disqus_shortname + &#39;.disqus.com/embed.js&#39;;\n    (document.getElementsByTagName(&#39;head&#39;)[0] || document.getElementsByTagName(&#39;body&#39;)[0]).appendChild(dsq);\n})();\n</code></pre>\n<p>disqus_shortname是简称，disqus_title是标题，disqus_identifier是标识，disqus_url是地址。</p>\n<p>另外disqus可以自动根据网站样式生成样式，我没有做任何样式的修改，disqus就生成了文字颜色与我的blog一致的评论框。</p>\n<h2 id=\"本地环境\"><a href=\"#本地环境\" class=\"headerlink\" title=\"本地环境\"></a>本地环境</h2><p>Jekyll是由Ruby编写的，所以首先需要下载Ruby，在<a href=\"http://rubyinstaller.org/downloads/\">这里下载Ruby1.9.3</a>，注意不能下载Ruby2，之后会出现问题。</p>\n<p>在下载页面中还能找到DevKit，也一并下载了，注意自己的操作系统选择对应的版本。</p>\n<p>Ruby的安装很简单，如果是安装版连环境变量都不用配置。然后是DevKit稍微复杂点，需要几行命令：</p>\n<pre><code>cd /d/DevKit/\nruby dk.rb init\nruby dk.rb install\n</code></pre>\n<p>如此基本环境就准备好了，然后使用gem安装jekyll：</p>\n<pre><code>gem install jekyll\n</code></pre>\n<p>最后在需要建立blog的文件夹下，使用以下命令即可创建jekyll博客。</p>\n<pre><code>jekyll new\n</code></pre>\n<p>然后无论是否用jekyll创建的blog，在其目录下使用以下命令即可在本地启动jekyll服务：</p>\n<pre><code>jekyll serve\n</code></pre>\n<p>这条命令其实还包含了build命令用以生成_site文件夹，也就是博客的静态页面。如果希望每次修改都会生成，可以使用参数–watch或-w</p>\n<pre><code>jekyll serve -w\n</code></pre>\n<p>这样一个基本的Jekyll博客就建好了，把除了_site的其他文件push到github上即可用有自己的Blog了。</p>\n作为模板接受的内容变量，另外还有之类的变量。<br>_posts文件夹为博客文章文件夹，发布文章的格式为yyyy-mm-dd-blogname，也就说文章的日期是自定的。格式可以使用html、md、textile。当然更易于管理的方式是建立Year&gt;Month&gt;Day这样的目录结构。<p></p>\n<!-- more -->\n<p>无论是模板还是页面都可以在文件的开始，写入YAML的配置信息，使用三个横杠分隔，像这样：</p>\n<pre><code>---\nlayout: post\ncategory: Other\ntags: github page blog config\ntitle: Create Blog on Github\n---\n</code></pre>\n<p>最关键的是_config.yml文件，这个是jekyll的配置文件。其中auto为boolean值，是否自动根据修改重建网站静态文件。</p>\n<pre><code>destination: ./_site\nauto:        true\nlsi:         false\n</code></pre>\n<p>当然根目录中的index.html是必不可少的首页了，另外也许还需要一个about.html之类的页面，都放在根目录中即可，然后在模板中的导航直接放入这些页面的链接。如果不喜欢有HTML这样的后缀，可以使用文件夹代替，并在文件夹中使用index.html这样的名字。比如<code>about/index.html</code> 在访问时路径为<a href=\"http://www.example.com/about/\">www.example.com/about/</a></p>\n<p>更详细的wiki可以看这里,<a href=\"https://github.com/mojombo/jekyll/wiki\">Jekyll Wiki</a>，可以查看各种配置和使用方法。或者访问<a href=\"http://jekyllrb.com/docs/home/\">Jekyll主页</a></p>\n<p>##评论##</p>\n<p>我使用的是<a href=\"http://disqus.com/\">Disqus</a>第三方评论，国内的模仿者还有<a href=\"http://uyan.cc/\">友言</a>、<a href=\"http://denglu.cc/\">灯鹭</a>、<a href=\"http://duoshuo.com/\">多说</a>等，它们大致的原理都一样，引入一段js，然后动态加载一个iframe，将第三方提供的输入框和评论数据呈现出来，另外这需要一个帐号，用来保存和管理你的评论。</p>\n<p>首先注册一个Disqus的帐号，然后输入需要添加评论的网站地址，以及名称和简称，然后会自动生成一段js代码，和一个div，这个div就是容器，只要放到你的网站中需要放置评论的地方就可以了。js代码可以放在body的最后加载。</p>\n<pre><code>var disqus_shortname = &#39;tychio blog&#39;;\nvar disqus_title = &#39;&#123;&#123; page.title &#125;&#125;&#39;;\nvar disqus_identifier = &#39;&#123;&#123; page.id &#125;&#125;&#39;;\nvar disqus_url = &#39;http://www.tychio.net/&#123;&#123; page.url &#125;&#125;&#39;;\n\n(function() &#123;\n    var dsq = document.createElement(&#39;script&#39;); \n    dsq.type = &#39;text/javascript&#39;; dsq.async = true;\n    dsq.src = &#39;//&#39; + disqus_shortname + &#39;.disqus.com/embed.js&#39;;\n    (document.getElementsByTagName(&#39;head&#39;)[0] || document.getElementsByTagName(&#39;body&#39;)[0]).appendChild(dsq);\n&#125;)();\n</code></pre>\n<p>disqus_shortname是简称，disqus_title是标题，disqus_identifier是标识，disqus_url是地址。</p>\n<p>另外disqus可以自动根据网站样式生成样式，我没有做任何样式的修改，disqus就生成了文字颜色与我的blog一致的评论框。</p>\n<h2 id=\"本地环境\"><a href=\"#本地环境\" class=\"headerlink\" title=\"本地环境\"></a>本地环境</h2><p>Jekyll是由Ruby编写的，所以首先需要下载Ruby，在<a href=\"http://rubyinstaller.org/downloads/\">这里下载Ruby1.9.3</a>，注意不能下载Ruby2，之后会出现问题。</p>\n<p>在下载页面中还能找到DevKit，也一并下载了，注意自己的操作系统选择对应的版本。</p>\n<p>Ruby的安装很简单，如果是安装版连环境变量都不用配置。然后是DevKit稍微复杂点，需要几行命令：</p>\n<pre><code>cd /d/DevKit/\nruby dk.rb init\nruby dk.rb install\n</code></pre>\n<p>如此基本环境就准备好了，然后使用gem安装jekyll：</p>\n<pre><code>gem install jekyll\n</code></pre>\n<p>最后在需要建立blog的文件夹下，使用以下命令即可创建jekyll博客。</p>\n<pre><code>jekyll new\n</code></pre>\n<p>然后无论是否用jekyll创建的blog，在其目录下使用以下命令即可在本地启动jekyll服务：</p>\n<pre><code>jekyll serve\n</code></pre>\n<p>这条命令其实还包含了build命令用以生成_site文件夹，也就是博客的静态页面。如果希望每次修改都会生成，可以使用参数–watch或-w</p>\n<pre><code>jekyll serve -w\n</code></pre>\n<p>这样一个基本的Jekyll博客就建好了，把除了_site的其他文件push到github上即可用有自己的Blog了。</p>\n","site":{"data":{}},"excerpt":"<p>##创建##</p>\n<p><img src=\"/images/jekyll.png\" alt=\"jakyll\">使用Github创建博客，项目名必须是username.github.io，然后直接使用主分支master即可。github使用的jekyll会自动根据相关文件生成一个_site文件夹，包括整个blog的静态文件用于访问。</p>\n<p>_layouts文件夹为模板文件夹，可以创建一个default(自定)的html文件作为模板，并使用</p><p>##创建##</p>\n<p><img src=\"/images/jekyll.png\" alt=\"jakyll\">使用Github创建博客，项目名必须是username.github.io，然后直接使用主分支master即可。github使用的jekyll会自动根据相关文件生成一个_site文件夹，包括整个blog的静态文件用于访问。</p>\n<p>_layouts文件夹为模板文件夹，可以创建一个default(自定)的html文件作为模板，并使用{{content}}作为模板接受的内容变量，另外还有{{page.title}}之类的变量。<br>_posts文件夹为博客文章文件夹，发布文章的格式为yyyy-mm-dd-blogname，也就说文章的日期是自定的。格式可以使用html、md、textile。当然更易于管理的方式是建立Year&gt;Month&gt;Day这样的目录结构。</p>","more":"<p>无论是模板还是页面都可以在文件的开始，写入YAML的配置信息，使用三个横杠分隔，像这样：</p>\n<pre><code>---\nlayout: post\ncategory: Other\ntags: github page blog config\ntitle: Create Blog on Github\n---\n</code></pre>\n<p>最关键的是_config.yml文件，这个是jekyll的配置文件。其中auto为boolean值，是否自动根据修改重建网站静态文件。</p>\n<pre><code>destination: ./_site\nauto:        true\nlsi:         false\n</code></pre>\n<p>当然根目录中的index.html是必不可少的首页了，另外也许还需要一个about.html之类的页面，都放在根目录中即可，然后在模板中的导航直接放入这些页面的链接。如果不喜欢有HTML这样的后缀，可以使用文件夹代替，并在文件夹中使用index.html这样的名字。比如<code>about/index.html</code> 在访问时路径为<a href=\"http://www.example.com/about/\">www.example.com/about/</a></p>\n<p>更详细的wiki可以看这里,<a href=\"https://github.com/mojombo/jekyll/wiki\">Jekyll Wiki</a>，可以查看各种配置和使用方法。或者访问<a href=\"http://jekyllrb.com/docs/home/\">Jekyll主页</a></p>\n<p>##评论##</p>\n<p>我使用的是<a href=\"http://disqus.com/\">Disqus</a>第三方评论，国内的模仿者还有<a href=\"http://uyan.cc/\">友言</a>、<a href=\"http://denglu.cc/\">灯鹭</a>、<a href=\"http://duoshuo.com/\">多说</a>等，它们大致的原理都一样，引入一段js，然后动态加载一个iframe，将第三方提供的输入框和评论数据呈现出来，另外这需要一个帐号，用来保存和管理你的评论。</p>\n<p>首先注册一个Disqus的帐号，然后输入需要添加评论的网站地址，以及名称和简称，然后会自动生成一段js代码，和一个div，这个div就是容器，只要放到你的网站中需要放置评论的地方就可以了。js代码可以放在body的最后加载。</p>\n<pre><code>var disqus_shortname = &#39;tychio blog&#39;;\nvar disqus_title = &#39;{{ page.title }}&#39;;\nvar disqus_identifier = &#39;{{ page.id }}&#39;;\nvar disqus_url = &#39;http://www.tychio.net/{{ page.url }}&#39;;\n\n(function() {\n    var dsq = document.createElement(&#39;script&#39;); \n    dsq.type = &#39;text/javascript&#39;; dsq.async = true;\n    dsq.src = &#39;//&#39; + disqus_shortname + &#39;.disqus.com/embed.js&#39;;\n    (document.getElementsByTagName(&#39;head&#39;)[0] || document.getElementsByTagName(&#39;body&#39;)[0]).appendChild(dsq);\n})();\n</code></pre>\n<p>disqus_shortname是简称，disqus_title是标题，disqus_identifier是标识，disqus_url是地址。</p>\n<p>另外disqus可以自动根据网站样式生成样式，我没有做任何样式的修改，disqus就生成了文字颜色与我的blog一致的评论框。</p>\n<h2 id=\"本地环境\"><a href=\"#本地环境\" class=\"headerlink\" title=\"本地环境\"></a>本地环境</h2><p>Jekyll是由Ruby编写的，所以首先需要下载Ruby，在<a href=\"http://rubyinstaller.org/downloads/\">这里下载Ruby1.9.3</a>，注意不能下载Ruby2，之后会出现问题。</p>\n<p>在下载页面中还能找到DevKit，也一并下载了，注意自己的操作系统选择对应的版本。</p>\n<p>Ruby的安装很简单，如果是安装版连环境变量都不用配置。然后是DevKit稍微复杂点，需要几行命令：</p>\n<pre><code>cd /d/DevKit/\nruby dk.rb init\nruby dk.rb install\n</code></pre>\n<p>如此基本环境就准备好了，然后使用gem安装jekyll：</p>\n<pre><code>gem install jekyll\n</code></pre>\n<p>最后在需要建立blog的文件夹下，使用以下命令即可创建jekyll博客。</p>\n<pre><code>jekyll new\n</code></pre>\n<p>然后无论是否用jekyll创建的blog，在其目录下使用以下命令即可在本地启动jekyll服务：</p>\n<pre><code>jekyll serve\n</code></pre>\n<p>这条命令其实还包含了build命令用以生成_site文件夹，也就是博客的静态页面。如果希望每次修改都会生成，可以使用参数–watch或-w</p>\n<pre><code>jekyll serve -w\n</code></pre>\n<p>这样一个基本的Jekyll博客就建好了，把除了_site的其他文件push到github上即可用有自己的Blog了。</p>\n作为模板接受的内容变量，另外还有之类的变量。<br>_posts文件夹为博客文章文件夹，发布文章的格式为yyyy-mm-dd-blogname，也就说文章的日期是自定的。格式可以使用html、md、textile。当然更易于管理的方式是建立Year&gt;Month&gt;Day这样的目录结构。<p></p>\n<!-- more -->\n<p>无论是模板还是页面都可以在文件的开始，写入YAML的配置信息，使用三个横杠分隔，像这样：</p>\n<pre><code>---\nlayout: post\ncategory: Other\ntags: github page blog config\ntitle: Create Blog on Github\n---\n</code></pre>\n<p>最关键的是_config.yml文件，这个是jekyll的配置文件。其中auto为boolean值，是否自动根据修改重建网站静态文件。</p>\n<pre><code>destination: ./_site\nauto:        true\nlsi:         false\n</code></pre>\n<p>当然根目录中的index.html是必不可少的首页了，另外也许还需要一个about.html之类的页面，都放在根目录中即可，然后在模板中的导航直接放入这些页面的链接。如果不喜欢有HTML这样的后缀，可以使用文件夹代替，并在文件夹中使用index.html这样的名字。比如<code>about/index.html</code> 在访问时路径为<a href=\"http://www.example.com/about/\">www.example.com/about/</a></p>\n<p>更详细的wiki可以看这里,<a href=\"https://github.com/mojombo/jekyll/wiki\">Jekyll Wiki</a>，可以查看各种配置和使用方法。或者访问<a href=\"http://jekyllrb.com/docs/home/\">Jekyll主页</a></p>\n<p>##评论##</p>\n<p>我使用的是<a href=\"http://disqus.com/\">Disqus</a>第三方评论，国内的模仿者还有<a href=\"http://uyan.cc/\">友言</a>、<a href=\"http://denglu.cc/\">灯鹭</a>、<a href=\"http://duoshuo.com/\">多说</a>等，它们大致的原理都一样，引入一段js，然后动态加载一个iframe，将第三方提供的输入框和评论数据呈现出来，另外这需要一个帐号，用来保存和管理你的评论。</p>\n<p>首先注册一个Disqus的帐号，然后输入需要添加评论的网站地址，以及名称和简称，然后会自动生成一段js代码，和一个div，这个div就是容器，只要放到你的网站中需要放置评论的地方就可以了。js代码可以放在body的最后加载。</p>\n<pre><code>var disqus_shortname = &#39;tychio blog&#39;;\nvar disqus_title = &#39;&#123;&#123; page.title &#125;&#125;&#39;;\nvar disqus_identifier = &#39;&#123;&#123; page.id &#125;&#125;&#39;;\nvar disqus_url = &#39;http://www.tychio.net/&#123;&#123; page.url &#125;&#125;&#39;;\n\n(function() &#123;\n    var dsq = document.createElement(&#39;script&#39;); \n    dsq.type = &#39;text/javascript&#39;; dsq.async = true;\n    dsq.src = &#39;//&#39; + disqus_shortname + &#39;.disqus.com/embed.js&#39;;\n    (document.getElementsByTagName(&#39;head&#39;)[0] || document.getElementsByTagName(&#39;body&#39;)[0]).appendChild(dsq);\n&#125;)();\n</code></pre>\n<p>disqus_shortname是简称，disqus_title是标题，disqus_identifier是标识，disqus_url是地址。</p>\n<p>另外disqus可以自动根据网站样式生成样式，我没有做任何样式的修改，disqus就生成了文字颜色与我的blog一致的评论框。</p>\n<h2 id=\"本地环境\"><a href=\"#本地环境\" class=\"headerlink\" title=\"本地环境\"></a>本地环境</h2><p>Jekyll是由Ruby编写的，所以首先需要下载Ruby，在<a href=\"http://rubyinstaller.org/downloads/\">这里下载Ruby1.9.3</a>，注意不能下载Ruby2，之后会出现问题。</p>\n<p>在下载页面中还能找到DevKit，也一并下载了，注意自己的操作系统选择对应的版本。</p>\n<p>Ruby的安装很简单，如果是安装版连环境变量都不用配置。然后是DevKit稍微复杂点，需要几行命令：</p>\n<pre><code>cd /d/DevKit/\nruby dk.rb init\nruby dk.rb install\n</code></pre>\n<p>如此基本环境就准备好了，然后使用gem安装jekyll：</p>\n<pre><code>gem install jekyll\n</code></pre>\n<p>最后在需要建立blog的文件夹下，使用以下命令即可创建jekyll博客。</p>\n<pre><code>jekyll new\n</code></pre>\n<p>然后无论是否用jekyll创建的blog，在其目录下使用以下命令即可在本地启动jekyll服务：</p>\n<pre><code>jekyll serve\n</code></pre>\n<p>这条命令其实还包含了build命令用以生成_site文件夹，也就是博客的静态页面。如果希望每次修改都会生成，可以使用参数–watch或-w</p>\n<pre><code>jekyll serve -w\n</code></pre>\n<p>这样一个基本的Jekyll博客就建好了，把除了_site的其他文件push到github上即可用有自己的Blog了。</p>"},{"layout":"post","title":"推荐几个配色工具","_content":"\n作为一名前端工程师，或多或少都会接触到设计，虽然我很讨厌有人把前端和美工等同，但是我仍然很喜欢设计，这是一个Web必不可少的环节。\n\n不过毕竟不是专业的设计师，不可能什么都靠自己，我相信工具的帮助将会让前端做起一般的设计来游刃有余。\n\n首先介绍简单而常用的工具，颜色选择工具。\n\n### [Kuler](https://kuler.adobe.com) ###\n![Kuler](/images/kuler.jpg)\n\nKuler是adobe的一款在线配色方案分享服务，上面有海量的设计师们的配色方案，最多有5种颜色，有详细的颜色代码，HSV，RGB，CMKY，LAB，HEX。每一个配色方案都可以收藏，只有你有adobe的帐户，还可以随意修改。\n<!-- more -->\n---\n\n### [Colllor](http://colllor.com/) ###\n![Colllor](/images/colllor.jpg)\n\n虽然Kuler已经很强大了，但是由于它太强大了，似乎是面向设计师的产品，如果你不明白什么是对比色、相邻色、间隔色、等距色之类的概念，又无法确认主色调、辅色调、点缀色的区别，那我建议你还是选择Colllor，至少我觉得它对于业余设计者来说更加友好。\n\nColllor只需要选择一种主色调，然后会推荐一个辅色调，当然你也可以选择其他颜色作为辅色调。然后它会把主色调不同明度的颜色，主色调不同饱和度的颜色，主色调到辅色调渐变的颜色，还有主色调相似的颜色都一一列出，只需点击即可将HEX颜色代码复制到剪贴板，另外由于它是flash制作的，复制还兼容chrome。HEX颜色就是#FFFFFF这样的颜色码，可直接用于CSS。\n\n---\n\n### [Colr](http://www.colr.org/) ###\n![Colr](/images/colr.jpg)\n\n好吧，就算你搞清除了这些颜色的概念，好不容易选定了颜色，却发现和配图放在一起怎么就不是那么一回事呢。那么你可以试试Colr，它通过图片取色。帮助你快速找出一张图片的主色调和辅色调，至少对于业余设计者来说这样的质量足够了。\n\n如果你想随机选色，可以自动获取flickr上的图片，然后点击图片获取图片的主要几种颜色。如果你有需要搭配的图片，上传这个图片，Colr也会取出主要的颜色。只需要触碰图片，Colr就会生成需要颜色块散落在图片上，选一个适合的颜色块点击，获取你要的颜色。\n\n---\n\n### [ColorSchemeDesigner](http://colorschemedesigner.com/) ###\n![ColorSchemeDesigner](/images/CSD.jpg)\n\n这些都太繁琐了？什么设计理论都是浮云，随便来点颜色，看着不那么丑不就行了。没问题，ColorSchemeDesigner提供了一个色环，还有几种模式，mono（单色）、complement（补色）、triad（三色）、tetrad（四色）、analogic（类似色）、accented analogic（强化类似色）。其实这些运用了一些对比色、间隔色还有分裂互补的理论知识，不过什么也不用管。按照想选择的颜色个数选个模式随便点点吧，看起来不错的颜色搭配马上拥有。\n\n","source":"_posts/2013-05-21-design-tools.md","raw":"---\nlayout: post\ntitle: 推荐几个配色工具\ntags: [tool,recommend,color,颜色,调色,配色]\ncategory: Tech\n---\n\n作为一名前端工程师，或多或少都会接触到设计，虽然我很讨厌有人把前端和美工等同，但是我仍然很喜欢设计，这是一个Web必不可少的环节。\n\n不过毕竟不是专业的设计师，不可能什么都靠自己，我相信工具的帮助将会让前端做起一般的设计来游刃有余。\n\n首先介绍简单而常用的工具，颜色选择工具。\n\n### [Kuler](https://kuler.adobe.com) ###\n![Kuler](/images/kuler.jpg)\n\nKuler是adobe的一款在线配色方案分享服务，上面有海量的设计师们的配色方案，最多有5种颜色，有详细的颜色代码，HSV，RGB，CMKY，LAB，HEX。每一个配色方案都可以收藏，只有你有adobe的帐户，还可以随意修改。\n<!-- more -->\n---\n\n### [Colllor](http://colllor.com/) ###\n![Colllor](/images/colllor.jpg)\n\n虽然Kuler已经很强大了，但是由于它太强大了，似乎是面向设计师的产品，如果你不明白什么是对比色、相邻色、间隔色、等距色之类的概念，又无法确认主色调、辅色调、点缀色的区别，那我建议你还是选择Colllor，至少我觉得它对于业余设计者来说更加友好。\n\nColllor只需要选择一种主色调，然后会推荐一个辅色调，当然你也可以选择其他颜色作为辅色调。然后它会把主色调不同明度的颜色，主色调不同饱和度的颜色，主色调到辅色调渐变的颜色，还有主色调相似的颜色都一一列出，只需点击即可将HEX颜色代码复制到剪贴板，另外由于它是flash制作的，复制还兼容chrome。HEX颜色就是#FFFFFF这样的颜色码，可直接用于CSS。\n\n---\n\n### [Colr](http://www.colr.org/) ###\n![Colr](/images/colr.jpg)\n\n好吧，就算你搞清除了这些颜色的概念，好不容易选定了颜色，却发现和配图放在一起怎么就不是那么一回事呢。那么你可以试试Colr，它通过图片取色。帮助你快速找出一张图片的主色调和辅色调，至少对于业余设计者来说这样的质量足够了。\n\n如果你想随机选色，可以自动获取flickr上的图片，然后点击图片获取图片的主要几种颜色。如果你有需要搭配的图片，上传这个图片，Colr也会取出主要的颜色。只需要触碰图片，Colr就会生成需要颜色块散落在图片上，选一个适合的颜色块点击，获取你要的颜色。\n\n---\n\n### [ColorSchemeDesigner](http://colorschemedesigner.com/) ###\n![ColorSchemeDesigner](/images/CSD.jpg)\n\n这些都太繁琐了？什么设计理论都是浮云，随便来点颜色，看着不那么丑不就行了。没问题，ColorSchemeDesigner提供了一个色环，还有几种模式，mono（单色）、complement（补色）、triad（三色）、tetrad（四色）、analogic（类似色）、accented analogic（强化类似色）。其实这些运用了一些对比色、间隔色还有分裂互补的理论知识，不过什么也不用管。按照想选择的颜色个数选个模式随便点点吧，看起来不错的颜色搭配马上拥有。\n\n","slug":"design-tools","published":1,"date":"2013-05-20T16:00:00.000Z","updated":"2021-11-28T11:59:29.970Z","_id":"ckwj6550x0006vyjhcxjh7d20","comments":1,"photos":[],"link":"","content":"<p>作为一名前端工程师，或多或少都会接触到设计，虽然我很讨厌有人把前端和美工等同，但是我仍然很喜欢设计，这是一个Web必不可少的环节。</p>\n<p>不过毕竟不是专业的设计师，不可能什么都靠自己，我相信工具的帮助将会让前端做起一般的设计来游刃有余。</p>\n<p>首先介绍简单而常用的工具，颜色选择工具。</p>\n<h3 id=\"Kuler\"><a href=\"#Kuler\" class=\"headerlink\" title=\"Kuler\"></a><a href=\"https://kuler.adobe.com/\">Kuler</a></h3><p><img src=\"/images/kuler.jpg\" alt=\"Kuler\"></p>\n<p>Kuler是adobe的一款在线配色方案分享服务，上面有海量的设计师们的配色方案，最多有5种颜色，有详细的颜色代码，HSV，RGB，CMKY，LAB，HEX。每一个配色方案都可以收藏，只有你有adobe的帐户，还可以随意修改。</p>\n<span id=\"more\"></span>\n<hr>\n<h3 id=\"Colllor\"><a href=\"#Colllor\" class=\"headerlink\" title=\"Colllor\"></a><a href=\"http://colllor.com/\">Colllor</a></h3><p><img src=\"/images/colllor.jpg\" alt=\"Colllor\"></p>\n<p>虽然Kuler已经很强大了，但是由于它太强大了，似乎是面向设计师的产品，如果你不明白什么是对比色、相邻色、间隔色、等距色之类的概念，又无法确认主色调、辅色调、点缀色的区别，那我建议你还是选择Colllor，至少我觉得它对于业余设计者来说更加友好。</p>\n<p>Colllor只需要选择一种主色调，然后会推荐一个辅色调，当然你也可以选择其他颜色作为辅色调。然后它会把主色调不同明度的颜色，主色调不同饱和度的颜色，主色调到辅色调渐变的颜色，还有主色调相似的颜色都一一列出，只需点击即可将HEX颜色代码复制到剪贴板，另外由于它是flash制作的，复制还兼容chrome。HEX颜色就是#FFFFFF这样的颜色码，可直接用于CSS。</p>\n<hr>\n<h3 id=\"Colr\"><a href=\"#Colr\" class=\"headerlink\" title=\"Colr\"></a><a href=\"http://www.colr.org/\">Colr</a></h3><p><img src=\"/images/colr.jpg\" alt=\"Colr\"></p>\n<p>好吧，就算你搞清除了这些颜色的概念，好不容易选定了颜色，却发现和配图放在一起怎么就不是那么一回事呢。那么你可以试试Colr，它通过图片取色。帮助你快速找出一张图片的主色调和辅色调，至少对于业余设计者来说这样的质量足够了。</p>\n<p>如果你想随机选色，可以自动获取flickr上的图片，然后点击图片获取图片的主要几种颜色。如果你有需要搭配的图片，上传这个图片，Colr也会取出主要的颜色。只需要触碰图片，Colr就会生成需要颜色块散落在图片上，选一个适合的颜色块点击，获取你要的颜色。</p>\n<hr>\n<h3 id=\"ColorSchemeDesigner\"><a href=\"#ColorSchemeDesigner\" class=\"headerlink\" title=\"ColorSchemeDesigner\"></a><a href=\"http://colorschemedesigner.com/\">ColorSchemeDesigner</a></h3><p><img src=\"/images/CSD.jpg\" alt=\"ColorSchemeDesigner\"></p>\n<p>这些都太繁琐了？什么设计理论都是浮云，随便来点颜色，看着不那么丑不就行了。没问题，ColorSchemeDesigner提供了一个色环，还有几种模式，mono（单色）、complement（补色）、triad（三色）、tetrad（四色）、analogic（类似色）、accented analogic（强化类似色）。其实这些运用了一些对比色、间隔色还有分裂互补的理论知识，不过什么也不用管。按照想选择的颜色个数选个模式随便点点吧，看起来不错的颜色搭配马上拥有。</p>\n","site":{"data":{}},"excerpt":"<p>作为一名前端工程师，或多或少都会接触到设计，虽然我很讨厌有人把前端和美工等同，但是我仍然很喜欢设计，这是一个Web必不可少的环节。</p>\n<p>不过毕竟不是专业的设计师，不可能什么都靠自己，我相信工具的帮助将会让前端做起一般的设计来游刃有余。</p>\n<p>首先介绍简单而常用的工具，颜色选择工具。</p>\n<h3 id=\"Kuler\"><a href=\"#Kuler\" class=\"headerlink\" title=\"Kuler\"></a><a href=\"https://kuler.adobe.com/\">Kuler</a></h3><p><img src=\"/images/kuler.jpg\" alt=\"Kuler\"></p>\n<p>Kuler是adobe的一款在线配色方案分享服务，上面有海量的设计师们的配色方案，最多有5种颜色，有详细的颜色代码，HSV，RGB，CMKY，LAB，HEX。每一个配色方案都可以收藏，只有你有adobe的帐户，还可以随意修改。</p>","more":"<hr>\n<h3 id=\"Colllor\"><a href=\"#Colllor\" class=\"headerlink\" title=\"Colllor\"></a><a href=\"http://colllor.com/\">Colllor</a></h3><p><img src=\"/images/colllor.jpg\" alt=\"Colllor\"></p>\n<p>虽然Kuler已经很强大了，但是由于它太强大了，似乎是面向设计师的产品，如果你不明白什么是对比色、相邻色、间隔色、等距色之类的概念，又无法确认主色调、辅色调、点缀色的区别，那我建议你还是选择Colllor，至少我觉得它对于业余设计者来说更加友好。</p>\n<p>Colllor只需要选择一种主色调，然后会推荐一个辅色调，当然你也可以选择其他颜色作为辅色调。然后它会把主色调不同明度的颜色，主色调不同饱和度的颜色，主色调到辅色调渐变的颜色，还有主色调相似的颜色都一一列出，只需点击即可将HEX颜色代码复制到剪贴板，另外由于它是flash制作的，复制还兼容chrome。HEX颜色就是#FFFFFF这样的颜色码，可直接用于CSS。</p>\n<hr>\n<h3 id=\"Colr\"><a href=\"#Colr\" class=\"headerlink\" title=\"Colr\"></a><a href=\"http://www.colr.org/\">Colr</a></h3><p><img src=\"/images/colr.jpg\" alt=\"Colr\"></p>\n<p>好吧，就算你搞清除了这些颜色的概念，好不容易选定了颜色，却发现和配图放在一起怎么就不是那么一回事呢。那么你可以试试Colr，它通过图片取色。帮助你快速找出一张图片的主色调和辅色调，至少对于业余设计者来说这样的质量足够了。</p>\n<p>如果你想随机选色，可以自动获取flickr上的图片，然后点击图片获取图片的主要几种颜色。如果你有需要搭配的图片，上传这个图片，Colr也会取出主要的颜色。只需要触碰图片，Colr就会生成需要颜色块散落在图片上，选一个适合的颜色块点击，获取你要的颜色。</p>\n<hr>\n<h3 id=\"ColorSchemeDesigner\"><a href=\"#ColorSchemeDesigner\" class=\"headerlink\" title=\"ColorSchemeDesigner\"></a><a href=\"http://colorschemedesigner.com/\">ColorSchemeDesigner</a></h3><p><img src=\"/images/CSD.jpg\" alt=\"ColorSchemeDesigner\"></p>\n<p>这些都太繁琐了？什么设计理论都是浮云，随便来点颜色，看着不那么丑不就行了。没问题，ColorSchemeDesigner提供了一个色环，还有几种模式，mono（单色）、complement（补色）、triad（三色）、tetrad（四色）、analogic（类似色）、accented analogic（强化类似色）。其实这些运用了一些对比色、间隔色还有分裂互补的理论知识，不过什么也不用管。按照想选择的颜色个数选个模式随便点点吧，看起来不错的颜色搭配马上拥有。</p>"},{"layout":"post","title":"《编程珠玑》Programming Pearls","_content":"\n![Programming Pearls](/images/programmingpearls.jpg)&#12298;编程珠玑&#12299;这本书读完感觉很诡异，在读的过程中感觉很有收获，但是却说不清从书中获得了什么，好像什么也没读懂。说实话，很难对这本书归类，有时它告诉你的是实际操作的性能问题，有时又在讲算法或者数据结构。不过确切的说，它告诉我们的是一种无招胜有招的境界。无论是实际操作、算法还是数据结构都是在为项目服务的，我们的目的只有一个，那就是完成项目。\n\n一个项目与一个科研课题的区别就是它需要被实践，需要一种行之有效的解决方案。在一个系统被部署到实际环境中时，有时可能需要它无比精准，有时是快速运行，有时是超低成本，或者也有可能是兼而有之的权衡。此时工程师就需要调整一切可以调整的东西去满足这些需求，这些东西自然就是硬件环境、算法、数据结构了。作者Jon Bentley要告诉读者的就是这些调整所需要的手段。\n<!-- more -->\n第一部分讲的是基本操作，我的理解这部分讲的是“手段”，从算法、数据结构、程序设计到测试这样的细节，介绍了许多能影响实际部署结果的手法。而第二部分则是“效果”，是时间与空间的权衡，利用分析、估算确定性能，在算法设计和代码调优中节省成本开销。最后一部分则是介绍了一些实际的应用，通篇讲述的二分搜索，当然还有排序等，数据结构和基本类型也是一个重点。\n\n其实这本书买了很久了，但是一直没怎么好好看过，主要是因为总觉得是在讲后端技术。但仔细阅读之后才感觉到了技术的相通，不在乎什么语言，什么时代。也许我一辈子也不会有机会去面对一个超大的系统部署的解决方面这样的问题，但只要还在写程序做项目，这些类似的问题就不会离去。\n\n在前端开发中，IE就像一个性能奇差的老爷车般的大型机，要考虑它的性能与内存占用，有时需要函数节流，有时需要隐藏一些东西，还需要考虑图片的加载与缓存。而Webkit又几乎成为了移动互联网浏览器的代名词，需要考虑不同的交互，不同的操作习惯与视觉习惯体验，另外众多标准浏览器支持HTML5后，可以使用的手段越来越多。更重要的是，这些浏览器的差异，程序必须同时兼容，这对算法和数据结构的选择，时间与空间的权衡都是强大的考验。\n\n比如说在以前的一个项目中，我面对的是4个没有规范的后端工程师提供的Ajax接口，然而时间不允许我逐一进行调用，如果是你会怎么做？很快我想到了一个解决方案，将接口名放入数组，然后通过数组下标将混乱的接口名变成了有序的数字。但是后来发现了一个Bug，这个问题有点严重了，由于在javascript中数组是引用类型，有点像指针的意思，所以当我把所谓的接口名传入Ajax封装方法中后，这个方法改变了引用的变量，然后这个接口名的数组的值也相应的改变了，很明显，结果是调用的接口失去了控制。随后我下意识的将这个数组每次获取的时候都复制了一遍，然后在IE6中，性能出现了问题，浏览器渲染就像结巴了一下，一跳一跳的，在chrome中测试发现效率比原来低了几倍。这时我无意识的使用了一个不错的手段，调整了数据类型和结构，采用字符串放置这些名称，然后使用下划线将不足的空位不足使所有接口名的长度一致，在使用的时候直接获取对应的区段，并利用正则去掉下划线，一切回复了正常。\n","source":"_posts/2013-05-26-Programming-Pearls.md","raw":"---\nlayout: post\ntitle: 《编程珠玑》Programming Pearls\ntags: [software,SE,program,code,软件工程,编程珠玑]\ncategory: Read\n---\n\n![Programming Pearls](/images/programmingpearls.jpg)&#12298;编程珠玑&#12299;这本书读完感觉很诡异，在读的过程中感觉很有收获，但是却说不清从书中获得了什么，好像什么也没读懂。说实话，很难对这本书归类，有时它告诉你的是实际操作的性能问题，有时又在讲算法或者数据结构。不过确切的说，它告诉我们的是一种无招胜有招的境界。无论是实际操作、算法还是数据结构都是在为项目服务的，我们的目的只有一个，那就是完成项目。\n\n一个项目与一个科研课题的区别就是它需要被实践，需要一种行之有效的解决方案。在一个系统被部署到实际环境中时，有时可能需要它无比精准，有时是快速运行，有时是超低成本，或者也有可能是兼而有之的权衡。此时工程师就需要调整一切可以调整的东西去满足这些需求，这些东西自然就是硬件环境、算法、数据结构了。作者Jon Bentley要告诉读者的就是这些调整所需要的手段。\n<!-- more -->\n第一部分讲的是基本操作，我的理解这部分讲的是“手段”，从算法、数据结构、程序设计到测试这样的细节，介绍了许多能影响实际部署结果的手法。而第二部分则是“效果”，是时间与空间的权衡，利用分析、估算确定性能，在算法设计和代码调优中节省成本开销。最后一部分则是介绍了一些实际的应用，通篇讲述的二分搜索，当然还有排序等，数据结构和基本类型也是一个重点。\n\n其实这本书买了很久了，但是一直没怎么好好看过，主要是因为总觉得是在讲后端技术。但仔细阅读之后才感觉到了技术的相通，不在乎什么语言，什么时代。也许我一辈子也不会有机会去面对一个超大的系统部署的解决方面这样的问题，但只要还在写程序做项目，这些类似的问题就不会离去。\n\n在前端开发中，IE就像一个性能奇差的老爷车般的大型机，要考虑它的性能与内存占用，有时需要函数节流，有时需要隐藏一些东西，还需要考虑图片的加载与缓存。而Webkit又几乎成为了移动互联网浏览器的代名词，需要考虑不同的交互，不同的操作习惯与视觉习惯体验，另外众多标准浏览器支持HTML5后，可以使用的手段越来越多。更重要的是，这些浏览器的差异，程序必须同时兼容，这对算法和数据结构的选择，时间与空间的权衡都是强大的考验。\n\n比如说在以前的一个项目中，我面对的是4个没有规范的后端工程师提供的Ajax接口，然而时间不允许我逐一进行调用，如果是你会怎么做？很快我想到了一个解决方案，将接口名放入数组，然后通过数组下标将混乱的接口名变成了有序的数字。但是后来发现了一个Bug，这个问题有点严重了，由于在javascript中数组是引用类型，有点像指针的意思，所以当我把所谓的接口名传入Ajax封装方法中后，这个方法改变了引用的变量，然后这个接口名的数组的值也相应的改变了，很明显，结果是调用的接口失去了控制。随后我下意识的将这个数组每次获取的时候都复制了一遍，然后在IE6中，性能出现了问题，浏览器渲染就像结巴了一下，一跳一跳的，在chrome中测试发现效率比原来低了几倍。这时我无意识的使用了一个不错的手段，调整了数据类型和结构，采用字符串放置这些名称，然后使用下划线将不足的空位不足使所有接口名的长度一致，在使用的时候直接获取对应的区段，并利用正则去掉下划线，一切回复了正常。\n","slug":"Programming-Pearls","published":1,"date":"2013-05-25T16:00:00.000Z","updated":"2021-11-28T11:59:29.970Z","_id":"ckwj6550y0009vyjh7nzha2jd","comments":1,"photos":[],"link":"","content":"<p><img src=\"/images/programmingpearls.jpg\" alt=\"Programming Pearls\">&#12298;编程珠玑&#12299;这本书读完感觉很诡异，在读的过程中感觉很有收获，但是却说不清从书中获得了什么，好像什么也没读懂。说实话，很难对这本书归类，有时它告诉你的是实际操作的性能问题，有时又在讲算法或者数据结构。不过确切的说，它告诉我们的是一种无招胜有招的境界。无论是实际操作、算法还是数据结构都是在为项目服务的，我们的目的只有一个，那就是完成项目。</p>\n<p>一个项目与一个科研课题的区别就是它需要被实践，需要一种行之有效的解决方案。在一个系统被部署到实际环境中时，有时可能需要它无比精准，有时是快速运行，有时是超低成本，或者也有可能是兼而有之的权衡。此时工程师就需要调整一切可以调整的东西去满足这些需求，这些东西自然就是硬件环境、算法、数据结构了。作者Jon Bentley要告诉读者的就是这些调整所需要的手段。</p>\n<span id=\"more\"></span>\n<p>第一部分讲的是基本操作，我的理解这部分讲的是“手段”，从算法、数据结构、程序设计到测试这样的细节，介绍了许多能影响实际部署结果的手法。而第二部分则是“效果”，是时间与空间的权衡，利用分析、估算确定性能，在算法设计和代码调优中节省成本开销。最后一部分则是介绍了一些实际的应用，通篇讲述的二分搜索，当然还有排序等，数据结构和基本类型也是一个重点。</p>\n<p>其实这本书买了很久了，但是一直没怎么好好看过，主要是因为总觉得是在讲后端技术。但仔细阅读之后才感觉到了技术的相通，不在乎什么语言，什么时代。也许我一辈子也不会有机会去面对一个超大的系统部署的解决方面这样的问题，但只要还在写程序做项目，这些类似的问题就不会离去。</p>\n<p>在前端开发中，IE就像一个性能奇差的老爷车般的大型机，要考虑它的性能与内存占用，有时需要函数节流，有时需要隐藏一些东西，还需要考虑图片的加载与缓存。而Webkit又几乎成为了移动互联网浏览器的代名词，需要考虑不同的交互，不同的操作习惯与视觉习惯体验，另外众多标准浏览器支持HTML5后，可以使用的手段越来越多。更重要的是，这些浏览器的差异，程序必须同时兼容，这对算法和数据结构的选择，时间与空间的权衡都是强大的考验。</p>\n<p>比如说在以前的一个项目中，我面对的是4个没有规范的后端工程师提供的Ajax接口，然而时间不允许我逐一进行调用，如果是你会怎么做？很快我想到了一个解决方案，将接口名放入数组，然后通过数组下标将混乱的接口名变成了有序的数字。但是后来发现了一个Bug，这个问题有点严重了，由于在javascript中数组是引用类型，有点像指针的意思，所以当我把所谓的接口名传入Ajax封装方法中后，这个方法改变了引用的变量，然后这个接口名的数组的值也相应的改变了，很明显，结果是调用的接口失去了控制。随后我下意识的将这个数组每次获取的时候都复制了一遍，然后在IE6中，性能出现了问题，浏览器渲染就像结巴了一下，一跳一跳的，在chrome中测试发现效率比原来低了几倍。这时我无意识的使用了一个不错的手段，调整了数据类型和结构，采用字符串放置这些名称，然后使用下划线将不足的空位不足使所有接口名的长度一致，在使用的时候直接获取对应的区段，并利用正则去掉下划线，一切回复了正常。</p>\n","site":{"data":{}},"excerpt":"<p><img src=\"/images/programmingpearls.jpg\" alt=\"Programming Pearls\">&#12298;编程珠玑&#12299;这本书读完感觉很诡异，在读的过程中感觉很有收获，但是却说不清从书中获得了什么，好像什么也没读懂。说实话，很难对这本书归类，有时它告诉你的是实际操作的性能问题，有时又在讲算法或者数据结构。不过确切的说，它告诉我们的是一种无招胜有招的境界。无论是实际操作、算法还是数据结构都是在为项目服务的，我们的目的只有一个，那就是完成项目。</p>\n<p>一个项目与一个科研课题的区别就是它需要被实践，需要一种行之有效的解决方案。在一个系统被部署到实际环境中时，有时可能需要它无比精准，有时是快速运行，有时是超低成本，或者也有可能是兼而有之的权衡。此时工程师就需要调整一切可以调整的东西去满足这些需求，这些东西自然就是硬件环境、算法、数据结构了。作者Jon Bentley要告诉读者的就是这些调整所需要的手段。</p>","more":"<p>第一部分讲的是基本操作，我的理解这部分讲的是“手段”，从算法、数据结构、程序设计到测试这样的细节，介绍了许多能影响实际部署结果的手法。而第二部分则是“效果”，是时间与空间的权衡，利用分析、估算确定性能，在算法设计和代码调优中节省成本开销。最后一部分则是介绍了一些实际的应用，通篇讲述的二分搜索，当然还有排序等，数据结构和基本类型也是一个重点。</p>\n<p>其实这本书买了很久了，但是一直没怎么好好看过，主要是因为总觉得是在讲后端技术。但仔细阅读之后才感觉到了技术的相通，不在乎什么语言，什么时代。也许我一辈子也不会有机会去面对一个超大的系统部署的解决方面这样的问题，但只要还在写程序做项目，这些类似的问题就不会离去。</p>\n<p>在前端开发中，IE就像一个性能奇差的老爷车般的大型机，要考虑它的性能与内存占用，有时需要函数节流，有时需要隐藏一些东西，还需要考虑图片的加载与缓存。而Webkit又几乎成为了移动互联网浏览器的代名词，需要考虑不同的交互，不同的操作习惯与视觉习惯体验，另外众多标准浏览器支持HTML5后，可以使用的手段越来越多。更重要的是，这些浏览器的差异，程序必须同时兼容，这对算法和数据结构的选择，时间与空间的权衡都是强大的考验。</p>\n<p>比如说在以前的一个项目中，我面对的是4个没有规范的后端工程师提供的Ajax接口，然而时间不允许我逐一进行调用，如果是你会怎么做？很快我想到了一个解决方案，将接口名放入数组，然后通过数组下标将混乱的接口名变成了有序的数字。但是后来发现了一个Bug，这个问题有点严重了，由于在javascript中数组是引用类型，有点像指针的意思，所以当我把所谓的接口名传入Ajax封装方法中后，这个方法改变了引用的变量，然后这个接口名的数组的值也相应的改变了，很明显，结果是调用的接口失去了控制。随后我下意识的将这个数组每次获取的时候都复制了一遍，然后在IE6中，性能出现了问题，浏览器渲染就像结巴了一下，一跳一跳的，在chrome中测试发现效率比原来低了几倍。这时我无意识的使用了一个不错的手段，调整了数据类型和结构，采用字符串放置这些名称，然后使用下划线将不足的空位不足使所有接口名的长度一致，在使用的时候直接获取对应的区段，并利用正则去掉下划线，一切回复了正常。</p>"},{"layout":"post","title":"推荐一些图片工具","_content":"\n上周介绍了几种配色工具，这次要介绍的是一些图片和图标的生成工具。\n\n就算你熟练掌握Photoshop之类的图片处理工具，要制作一个小小的图标还是挺费时费力的。可是网上下载的话，颜色尺寸又不一定能适合，所以制作图片的工具将是非常必要的。\n\n### [Online Generator](http://onlinegenerator.net/) ###\n\n[![Preloaders](http://onlinegenerator.net/images/preloaders.png)](http://preloaders.net/)\n\nOnline Generator包括好几个很棒的工具，首先是Preloaders，它用于制作loading图片，它的图片种类很齐全，还有大量的3D图片，最重要的是它可以任意改变尺寸，当然也包括颜色，动画。动画可以选择方向频率等等，功能十分强大，基本上只要你能找到喜欢的图案，它就一定能制作出你想要的loading图片。\n<!-- more -->\n[![Iconizer](http://onlinegenerator.net/images/iconizer.png)](http://iconizer.net/)\n\nIconizer是一个icon搜索制作工具，只要输入关键字，比如home，就会出现海量的类似图标，然后选一个就可以继续定制颜色尺寸等相关信息，然后下载你要的图标或者先存起来，之后再打包下载。\n\n[![CSSloader](http://onlinegenerator.net/images/cssload.png)](http://cssload.net/)\n\n这样还要加载图片，是不是觉得有点烦，其实还有更简单的办法，只要你忽略ie8一下浏览器就行了，用CSS的animation实现loading动画。不会写？懒的写？好吧，那只有用CSSloader了，虽然样式有限，但是选择颜色尺寸后你就可以复制代码了。\n\n### [IconBench](http://iconbench.com/) ###\n![iconbench](http://iconbench.com/Content/Images/iconbench.png)\n\n上面提到的iconizer虽然有海量图标，但是每种图标风格迥异，不能成套怎么办，iconizer就可以解决这个问题。它的选择过程是反的，先选颜色尺寸等属性，再选样式，然后打包下载，还有css sprite图片和css代码。其属性也很丰富，包括内外阴影，渐变颜色，描边，未来还会添加特殊效果。而样式也是非常丰富，基本涵盖了所有用途，一共5套免费的，1套收费的，每套都有上百种样式。\n\n### [ProjectFondue](http://blog.projectfondue.com/) ###\n[CSS Sprite Generator](http://spritegen.website-performance.org/)\n\nIconbench很贴心的把图标制作成css精灵图片是不是很好？可是如果有自己的图片需要制作时，这个CSS Sprite Generator就帮得上忙了。最强大也最无聊的是这玩意支持十几种语言。将要制作CSS精灵的图片打包成zip，然后上传，最大1Mb。你还可以选择移除相同的图片，当然还是尺寸、比例、每个图片的尺寸颜色质量等等。另外css代码也有一些配置信息，比如前缀之类的。然后点生成就可以了，非常方便。\n\n[Favicon Generator](http://favicon-generator.org/)\n\n这个工具的作用只有一个，每个网站都需要一个favorite.ico的文件，你不知道？就是打开网站后浏览器标签上面的小图标还有书签里的图标。因为必须是ico格式的，所以比较特殊，photoshop也歇菜了，用处虽然不大，但是非常必须。首先上传一个gif、png或者jpg格式的图片，然后最强大的地方是可以在线编辑，最后提交即可下载ico文件。\n\n另外projectfondue还很奇葩的提供了一个unix权限计算工具，和另外2个工具好像没什么联系，大概他们的团队也只是顺便开发了这些工具（偷笑）。\n\n### [Base64-Image](http://www.base64-image.de/) ###\n![base64image](http://www.base64-image.de/img/layout/logo.png)\n\nBase64是一种对称加密方式，就是说可以加也可以解，而标准浏览器已经实现了对base64图片的读取，也就是说一段字符可以代替一个图片了。这个工具自然就是把图片转换成base64码的，上传图片获取代码，不用说很简单。\n\n### [Fontello](http://fontello.com/) ###\n\n是不是觉得base64很高端了，别急，还有更geek的玩意。像github一样的icon，就是用字体做图标。这个fontello拥有海量的字体图标，选择一些图标，然后选择尺寸，最大只有30px。然后下载，这个压缩包里包含了各种格式的字体（woff、tff、svg、eot），还有css代码，包括兼容性问题，还有可能包括动画。甚至还有一个demo的html文件。\n\n### [Smush](http://www.smushit.com/) ###\n\n这些工具应该已经足够用了，不过如果你还想精益求精的话，Smush可以帮你将图片文件优化，在保证质量的情况下降低文件大小。使用很简单，上传或者输入url，下载图片压缩包。它还会显示容量优化的比率。这是yahoo的一个工具。\n\n### [PhotoRaster](http://photoraster.com/) ###\n\n这是一个在线的photoshop，如果以上这些工具都满足不了你，那这个工具一定能让你满意。不过说实在的，除了临时没有装photoshop需要用这个，一般谁会用呢，无论功能和性能，肯定都是不如photoshop的。\n\n","source":"_posts/2013-05-29-design-tools2.md","raw":"---\nlayout: post\ntitle: 推荐一些图片工具\ntags: [tool,recommend,image,图片,工具]\ncategory: Tech\n---\n\n上周介绍了几种配色工具，这次要介绍的是一些图片和图标的生成工具。\n\n就算你熟练掌握Photoshop之类的图片处理工具，要制作一个小小的图标还是挺费时费力的。可是网上下载的话，颜色尺寸又不一定能适合，所以制作图片的工具将是非常必要的。\n\n### [Online Generator](http://onlinegenerator.net/) ###\n\n[![Preloaders](http://onlinegenerator.net/images/preloaders.png)](http://preloaders.net/)\n\nOnline Generator包括好几个很棒的工具，首先是Preloaders，它用于制作loading图片，它的图片种类很齐全，还有大量的3D图片，最重要的是它可以任意改变尺寸，当然也包括颜色，动画。动画可以选择方向频率等等，功能十分强大，基本上只要你能找到喜欢的图案，它就一定能制作出你想要的loading图片。\n<!-- more -->\n[![Iconizer](http://onlinegenerator.net/images/iconizer.png)](http://iconizer.net/)\n\nIconizer是一个icon搜索制作工具，只要输入关键字，比如home，就会出现海量的类似图标，然后选一个就可以继续定制颜色尺寸等相关信息，然后下载你要的图标或者先存起来，之后再打包下载。\n\n[![CSSloader](http://onlinegenerator.net/images/cssload.png)](http://cssload.net/)\n\n这样还要加载图片，是不是觉得有点烦，其实还有更简单的办法，只要你忽略ie8一下浏览器就行了，用CSS的animation实现loading动画。不会写？懒的写？好吧，那只有用CSSloader了，虽然样式有限，但是选择颜色尺寸后你就可以复制代码了。\n\n### [IconBench](http://iconbench.com/) ###\n![iconbench](http://iconbench.com/Content/Images/iconbench.png)\n\n上面提到的iconizer虽然有海量图标，但是每种图标风格迥异，不能成套怎么办，iconizer就可以解决这个问题。它的选择过程是反的，先选颜色尺寸等属性，再选样式，然后打包下载，还有css sprite图片和css代码。其属性也很丰富，包括内外阴影，渐变颜色，描边，未来还会添加特殊效果。而样式也是非常丰富，基本涵盖了所有用途，一共5套免费的，1套收费的，每套都有上百种样式。\n\n### [ProjectFondue](http://blog.projectfondue.com/) ###\n[CSS Sprite Generator](http://spritegen.website-performance.org/)\n\nIconbench很贴心的把图标制作成css精灵图片是不是很好？可是如果有自己的图片需要制作时，这个CSS Sprite Generator就帮得上忙了。最强大也最无聊的是这玩意支持十几种语言。将要制作CSS精灵的图片打包成zip，然后上传，最大1Mb。你还可以选择移除相同的图片，当然还是尺寸、比例、每个图片的尺寸颜色质量等等。另外css代码也有一些配置信息，比如前缀之类的。然后点生成就可以了，非常方便。\n\n[Favicon Generator](http://favicon-generator.org/)\n\n这个工具的作用只有一个，每个网站都需要一个favorite.ico的文件，你不知道？就是打开网站后浏览器标签上面的小图标还有书签里的图标。因为必须是ico格式的，所以比较特殊，photoshop也歇菜了，用处虽然不大，但是非常必须。首先上传一个gif、png或者jpg格式的图片，然后最强大的地方是可以在线编辑，最后提交即可下载ico文件。\n\n另外projectfondue还很奇葩的提供了一个unix权限计算工具，和另外2个工具好像没什么联系，大概他们的团队也只是顺便开发了这些工具（偷笑）。\n\n### [Base64-Image](http://www.base64-image.de/) ###\n![base64image](http://www.base64-image.de/img/layout/logo.png)\n\nBase64是一种对称加密方式，就是说可以加也可以解，而标准浏览器已经实现了对base64图片的读取，也就是说一段字符可以代替一个图片了。这个工具自然就是把图片转换成base64码的，上传图片获取代码，不用说很简单。\n\n### [Fontello](http://fontello.com/) ###\n\n是不是觉得base64很高端了，别急，还有更geek的玩意。像github一样的icon，就是用字体做图标。这个fontello拥有海量的字体图标，选择一些图标，然后选择尺寸，最大只有30px。然后下载，这个压缩包里包含了各种格式的字体（woff、tff、svg、eot），还有css代码，包括兼容性问题，还有可能包括动画。甚至还有一个demo的html文件。\n\n### [Smush](http://www.smushit.com/) ###\n\n这些工具应该已经足够用了，不过如果你还想精益求精的话，Smush可以帮你将图片文件优化，在保证质量的情况下降低文件大小。使用很简单，上传或者输入url，下载图片压缩包。它还会显示容量优化的比率。这是yahoo的一个工具。\n\n### [PhotoRaster](http://photoraster.com/) ###\n\n这是一个在线的photoshop，如果以上这些工具都满足不了你，那这个工具一定能让你满意。不过说实在的，除了临时没有装photoshop需要用这个，一般谁会用呢，无论功能和性能，肯定都是不如photoshop的。\n\n","slug":"design-tools2","published":1,"date":"2013-05-28T16:00:00.000Z","updated":"2021-11-28T11:37:27.160Z","comments":1,"photos":[],"link":"","_id":"ckwj6550z000avyjhhdf1citf","content":"<p>上周介绍了几种配色工具，这次要介绍的是一些图片和图标的生成工具。</p>\n<p>就算你熟练掌握Photoshop之类的图片处理工具，要制作一个小小的图标还是挺费时费力的。可是网上下载的话，颜色尺寸又不一定能适合，所以制作图片的工具将是非常必要的。</p>\n<h3 id=\"Online-Generator\"><a href=\"#Online-Generator\" class=\"headerlink\" title=\"Online Generator\"></a><a href=\"http://onlinegenerator.net/\">Online Generator</a></h3><p><a href=\"http://preloaders.net/\"><img src=\"http://onlinegenerator.net/images/preloaders.png\" alt=\"Preloaders\"></a></p>\n<p>Online Generator包括好几个很棒的工具，首先是Preloaders，它用于制作loading图片，它的图片种类很齐全，还有大量的3D图片，最重要的是它可以任意改变尺寸，当然也包括颜色，动画。动画可以选择方向频率等等，功能十分强大，基本上只要你能找到喜欢的图案，它就一定能制作出你想要的loading图片。</p>\n<span id=\"more\"></span>\n<p><a href=\"http://iconizer.net/\"><img src=\"http://onlinegenerator.net/images/iconizer.png\" alt=\"Iconizer\"></a></p>\n<p>Iconizer是一个icon搜索制作工具，只要输入关键字，比如home，就会出现海量的类似图标，然后选一个就可以继续定制颜色尺寸等相关信息，然后下载你要的图标或者先存起来，之后再打包下载。</p>\n<p><a href=\"http://cssload.net/\"><img src=\"http://onlinegenerator.net/images/cssload.png\" alt=\"CSSloader\"></a></p>\n<p>这样还要加载图片，是不是觉得有点烦，其实还有更简单的办法，只要你忽略ie8一下浏览器就行了，用CSS的animation实现loading动画。不会写？懒的写？好吧，那只有用CSSloader了，虽然样式有限，但是选择颜色尺寸后你就可以复制代码了。</p>\n<h3 id=\"IconBench\"><a href=\"#IconBench\" class=\"headerlink\" title=\"IconBench\"></a><a href=\"http://iconbench.com/\">IconBench</a></h3><p><img src=\"http://iconbench.com/Content/Images/iconbench.png\" alt=\"iconbench\"></p>\n<p>上面提到的iconizer虽然有海量图标，但是每种图标风格迥异，不能成套怎么办，iconizer就可以解决这个问题。它的选择过程是反的，先选颜色尺寸等属性，再选样式，然后打包下载，还有css sprite图片和css代码。其属性也很丰富，包括内外阴影，渐变颜色，描边，未来还会添加特殊效果。而样式也是非常丰富，基本涵盖了所有用途，一共5套免费的，1套收费的，每套都有上百种样式。</p>\n<h3 id=\"ProjectFondue\"><a href=\"#ProjectFondue\" class=\"headerlink\" title=\"ProjectFondue\"></a><a href=\"http://blog.projectfondue.com/\">ProjectFondue</a></h3><p><a href=\"http://spritegen.website-performance.org/\">CSS Sprite Generator</a></p>\n<p>Iconbench很贴心的把图标制作成css精灵图片是不是很好？可是如果有自己的图片需要制作时，这个CSS Sprite Generator就帮得上忙了。最强大也最无聊的是这玩意支持十几种语言。将要制作CSS精灵的图片打包成zip，然后上传，最大1Mb。你还可以选择移除相同的图片，当然还是尺寸、比例、每个图片的尺寸颜色质量等等。另外css代码也有一些配置信息，比如前缀之类的。然后点生成就可以了，非常方便。</p>\n<p><a href=\"http://favicon-generator.org/\">Favicon Generator</a></p>\n<p>这个工具的作用只有一个，每个网站都需要一个favorite.ico的文件，你不知道？就是打开网站后浏览器标签上面的小图标还有书签里的图标。因为必须是ico格式的，所以比较特殊，photoshop也歇菜了，用处虽然不大，但是非常必须。首先上传一个gif、png或者jpg格式的图片，然后最强大的地方是可以在线编辑，最后提交即可下载ico文件。</p>\n<p>另外projectfondue还很奇葩的提供了一个unix权限计算工具，和另外2个工具好像没什么联系，大概他们的团队也只是顺便开发了这些工具（偷笑）。</p>\n<h3 id=\"Base64-Image\"><a href=\"#Base64-Image\" class=\"headerlink\" title=\"Base64-Image\"></a><a href=\"http://www.base64-image.de/\">Base64-Image</a></h3><p><img src=\"http://www.base64-image.de/img/layout/logo.png\" alt=\"base64image\"></p>\n<p>Base64是一种对称加密方式，就是说可以加也可以解，而标准浏览器已经实现了对base64图片的读取，也就是说一段字符可以代替一个图片了。这个工具自然就是把图片转换成base64码的，上传图片获取代码，不用说很简单。</p>\n<h3 id=\"Fontello\"><a href=\"#Fontello\" class=\"headerlink\" title=\"Fontello\"></a><a href=\"http://fontello.com/\">Fontello</a></h3><p>是不是觉得base64很高端了，别急，还有更geek的玩意。像github一样的icon，就是用字体做图标。这个fontello拥有海量的字体图标，选择一些图标，然后选择尺寸，最大只有30px。然后下载，这个压缩包里包含了各种格式的字体（woff、tff、svg、eot），还有css代码，包括兼容性问题，还有可能包括动画。甚至还有一个demo的html文件。</p>\n<h3 id=\"Smush\"><a href=\"#Smush\" class=\"headerlink\" title=\"Smush\"></a><a href=\"http://www.smushit.com/\">Smush</a></h3><p>这些工具应该已经足够用了，不过如果你还想精益求精的话，Smush可以帮你将图片文件优化，在保证质量的情况下降低文件大小。使用很简单，上传或者输入url，下载图片压缩包。它还会显示容量优化的比率。这是yahoo的一个工具。</p>\n<h3 id=\"PhotoRaster\"><a href=\"#PhotoRaster\" class=\"headerlink\" title=\"PhotoRaster\"></a><a href=\"http://photoraster.com/\">PhotoRaster</a></h3><p>这是一个在线的photoshop，如果以上这些工具都满足不了你，那这个工具一定能让你满意。不过说实在的，除了临时没有装photoshop需要用这个，一般谁会用呢，无论功能和性能，肯定都是不如photoshop的。</p>\n","site":{"data":{}},"excerpt":"<p>上周介绍了几种配色工具，这次要介绍的是一些图片和图标的生成工具。</p>\n<p>就算你熟练掌握Photoshop之类的图片处理工具，要制作一个小小的图标还是挺费时费力的。可是网上下载的话，颜色尺寸又不一定能适合，所以制作图片的工具将是非常必要的。</p>\n<h3 id=\"Online-Generator\"><a href=\"#Online-Generator\" class=\"headerlink\" title=\"Online Generator\"></a><a href=\"http://onlinegenerator.net/\">Online Generator</a></h3><p><a href=\"http://preloaders.net/\"><img src=\"http://onlinegenerator.net/images/preloaders.png\" alt=\"Preloaders\"></a></p>\n<p>Online Generator包括好几个很棒的工具，首先是Preloaders，它用于制作loading图片，它的图片种类很齐全，还有大量的3D图片，最重要的是它可以任意改变尺寸，当然也包括颜色，动画。动画可以选择方向频率等等，功能十分强大，基本上只要你能找到喜欢的图案，它就一定能制作出你想要的loading图片。</p>","more":"<p><a href=\"http://iconizer.net/\"><img src=\"http://onlinegenerator.net/images/iconizer.png\" alt=\"Iconizer\"></a></p>\n<p>Iconizer是一个icon搜索制作工具，只要输入关键字，比如home，就会出现海量的类似图标，然后选一个就可以继续定制颜色尺寸等相关信息，然后下载你要的图标或者先存起来，之后再打包下载。</p>\n<p><a href=\"http://cssload.net/\"><img src=\"http://onlinegenerator.net/images/cssload.png\" alt=\"CSSloader\"></a></p>\n<p>这样还要加载图片，是不是觉得有点烦，其实还有更简单的办法，只要你忽略ie8一下浏览器就行了，用CSS的animation实现loading动画。不会写？懒的写？好吧，那只有用CSSloader了，虽然样式有限，但是选择颜色尺寸后你就可以复制代码了。</p>\n<h3 id=\"IconBench\"><a href=\"#IconBench\" class=\"headerlink\" title=\"IconBench\"></a><a href=\"http://iconbench.com/\">IconBench</a></h3><p><img src=\"http://iconbench.com/Content/Images/iconbench.png\" alt=\"iconbench\"></p>\n<p>上面提到的iconizer虽然有海量图标，但是每种图标风格迥异，不能成套怎么办，iconizer就可以解决这个问题。它的选择过程是反的，先选颜色尺寸等属性，再选样式，然后打包下载，还有css sprite图片和css代码。其属性也很丰富，包括内外阴影，渐变颜色，描边，未来还会添加特殊效果。而样式也是非常丰富，基本涵盖了所有用途，一共5套免费的，1套收费的，每套都有上百种样式。</p>\n<h3 id=\"ProjectFondue\"><a href=\"#ProjectFondue\" class=\"headerlink\" title=\"ProjectFondue\"></a><a href=\"http://blog.projectfondue.com/\">ProjectFondue</a></h3><p><a href=\"http://spritegen.website-performance.org/\">CSS Sprite Generator</a></p>\n<p>Iconbench很贴心的把图标制作成css精灵图片是不是很好？可是如果有自己的图片需要制作时，这个CSS Sprite Generator就帮得上忙了。最强大也最无聊的是这玩意支持十几种语言。将要制作CSS精灵的图片打包成zip，然后上传，最大1Mb。你还可以选择移除相同的图片，当然还是尺寸、比例、每个图片的尺寸颜色质量等等。另外css代码也有一些配置信息，比如前缀之类的。然后点生成就可以了，非常方便。</p>\n<p><a href=\"http://favicon-generator.org/\">Favicon Generator</a></p>\n<p>这个工具的作用只有一个，每个网站都需要一个favorite.ico的文件，你不知道？就是打开网站后浏览器标签上面的小图标还有书签里的图标。因为必须是ico格式的，所以比较特殊，photoshop也歇菜了，用处虽然不大，但是非常必须。首先上传一个gif、png或者jpg格式的图片，然后最强大的地方是可以在线编辑，最后提交即可下载ico文件。</p>\n<p>另外projectfondue还很奇葩的提供了一个unix权限计算工具，和另外2个工具好像没什么联系，大概他们的团队也只是顺便开发了这些工具（偷笑）。</p>\n<h3 id=\"Base64-Image\"><a href=\"#Base64-Image\" class=\"headerlink\" title=\"Base64-Image\"></a><a href=\"http://www.base64-image.de/\">Base64-Image</a></h3><p><img src=\"http://www.base64-image.de/img/layout/logo.png\" alt=\"base64image\"></p>\n<p>Base64是一种对称加密方式，就是说可以加也可以解，而标准浏览器已经实现了对base64图片的读取，也就是说一段字符可以代替一个图片了。这个工具自然就是把图片转换成base64码的，上传图片获取代码，不用说很简单。</p>\n<h3 id=\"Fontello\"><a href=\"#Fontello\" class=\"headerlink\" title=\"Fontello\"></a><a href=\"http://fontello.com/\">Fontello</a></h3><p>是不是觉得base64很高端了，别急，还有更geek的玩意。像github一样的icon，就是用字体做图标。这个fontello拥有海量的字体图标，选择一些图标，然后选择尺寸，最大只有30px。然后下载，这个压缩包里包含了各种格式的字体（woff、tff、svg、eot），还有css代码，包括兼容性问题，还有可能包括动画。甚至还有一个demo的html文件。</p>\n<h3 id=\"Smush\"><a href=\"#Smush\" class=\"headerlink\" title=\"Smush\"></a><a href=\"http://www.smushit.com/\">Smush</a></h3><p>这些工具应该已经足够用了，不过如果你还想精益求精的话，Smush可以帮你将图片文件优化，在保证质量的情况下降低文件大小。使用很简单，上传或者输入url，下载图片压缩包。它还会显示容量优化的比率。这是yahoo的一个工具。</p>\n<h3 id=\"PhotoRaster\"><a href=\"#PhotoRaster\" class=\"headerlink\" title=\"PhotoRaster\"></a><a href=\"http://photoraster.com/\">PhotoRaster</a></h3><p>这是一个在线的photoshop，如果以上这些工具都满足不了你，那这个工具一定能让你满意。不过说实在的，除了临时没有装photoshop需要用这个，一般谁会用呢，无论功能和性能，肯定都是不如photoshop的。</p>"},{"layout":"post","title":"键盘事件的KeyCode分析","_content":"\n## keyup和keydown事件以及keyCode和which属性 ##\n\n我想关于键盘事件最常见的实例就是回车提交表单了，恐怕每个前端都有一段烂熟于胸的代码用来实现这个功能。以前我也只是做了这样一个功能，也许它的代码是这样的：\n\n    function enter (p_event) {\n        var _keyCode = p_event.which ? p_event.which : p_event.keyCode;\n        var _ENTER_CODE = 13;\n        if (_ENTER_CODE === _keyCode) {\n            //enter code...\n        }\n    }\n\n如果需要兼容ie8及以下，那还需要这几行代码：\n\n    if (typeof p_event === 'undefined') {\n        p_event = window.event;\n    }\n\n当然，enter还需要绑定到一个键盘事件中，键盘事件有三种，我以前倾向于使用keyup [1]，这样的体验比较好，符合人的习惯，在松开按键的时候生效。不过有时候keydown也是很棒的选择，比如说用户希望可以快速触发时，比如游戏中，我还记得WOW有一款插件是专门修改为按下触发技能的。\n<!-- more -->\n    document.getElementById('enter_input').onkeyup = enter;\n\n---\n\n也许enter回车这样没问题，但其他按键呢？于是我做了一组测试，发现了一些问题\n\n在keyup和keydown事件中：\n\n* IE只有keyCode，which为undefined。\n* Firefox的which有值，而keyCode为0，但F1-12键则恰好相反，which为0，keyCode有值。\n* Chrome和Opare中which和keyCode都有值。\n\n按键码的一些差异：\n\n* 在IE、Safari中和Chrome、Firefox、Opare中存在差异。\n* ‘+ =’键是187 => 61。\n* ‘; :’键是186 => 59。\n* ‘- _’键是189 => 45, Opera很诡异的是109。\n* win键只有IE8和Safari是91，Opera是219，其他无法触发。\n* Meta [2] 键是93，但Opera和Chrome无法触发\n\n## keypress事件和charCode属性 ##\n\n这里其实有一个很重要但很多人都没搞清楚过的问题，那就是另外一个事件keypress，这个事情是怎么回事？曾经我只是单纯的认为它和keydown是一样的，因为它们在按下键盘后都会一直触发直到松开。而且w3school中文上的说法是\n\n>onkeypress 事件会在键盘按键被按下并释放一个键时发生\n\n不过最近看到了一个属性charCode，让我初步认识到了区别所在，似乎w3school的说法不太对。起初我以为charCode和keyCode还有which是不同浏览器实现的不同名称，但似乎charCode是mozila弄出来的一个东西，那就应该和其他2个有什么区别，因此我决定好好实验一番，来分析一下这些事件与属性究竟是怎么回事。\n\n首先在我认为最强大的Chrome中测试了一下，只有在keypress事件中，charCode才有值，而在keyup和keydown中都为0，另外我发现小键盘区域大部分按键是无法触发keypress的，还有win键、ctrl、alt、meta等都无法触发。\n\n---\n\n经过上面的测试，我大概发现了keypress的意义，**keypress只有按下可产出字符的按键时才会触发**，也因此keypress才能使用charCode，charCode的意义也很明显了，是**按键的字符的代码**，而不是keyCode或者which按键代码的意思。\n\n为了进一步检验我的理解，我试验了space、enter都有charCode值，而小键盘在点亮了Num Lock之后也有了charCode，并且按住shift或者切换Caps Lock后，charCode会发生变化也足以证明charCode是字符的unicode值，比如按下“A”时，会有小写和大写的65、97之分。\n\n---\n\n另外关于浏览器的兼容性：\n\n* IE8及以下和Opera12+是不支持charCode属性的。\n* 而在Firefox中，keypress事件触发时keyCode是没有值的。\n\n可以用以下代码试验。\n\n    document.body.onkeypress = function (p_event) {\n        p_event = p_event ? p_event : event;\n        alert('charCode is ' + p_event.charCode);\n    }\n\n如果在测试的过程中回车之类的按键触发了某些浏览器行为，可以这样避免，在事件方法的最后加上这行代码：\n\n    e.preventDefault ? e.preventDefault() : event.returnValue = false;\n\n---\n\n关于标准，在W3C标准中，其实无论是which、keyCode还是charCode都已经不推荐使用了，取而代之的是which和keyCode为key，charCode为char。不过遗憾的是目前所有浏览器都还没有实现key和char。\n\n---\n\n> 注1：不过IE6是不支持keyup的，只能用keydown。\n> 注2：meta按键就是一般在win键旁边的一个鼠标+一个菜单样式的按键，按键一般是用来弹出鼠标右键菜单的。\n\n---\n\n参考文章：\n\n* [Key codes of keydown and keyup events](http://www.javascripter.net/faq/keycodes.htm)\n* [Mozilla - keypress](https://developer.mozilla.org/en-US/docs/Web/Reference/Events/keypress)\n* [W3C Standard](http://www.w3.org/TR/DOM-Level-3-Events/#event-type-keypress)\n* [MSDN - charCode property](http://msdn.microsoft.com/en-us/library/ie/ff974890)\n\n\n","source":"_posts/2013-06-06-event-keycode.md","raw":"---\nlayout: post\ntitle: 键盘事件的KeyCode分析\ntags: [Javascript,event,which,keycode,charcode,unicode,事件]\ncategory: Tech\n---\n\n## keyup和keydown事件以及keyCode和which属性 ##\n\n我想关于键盘事件最常见的实例就是回车提交表单了，恐怕每个前端都有一段烂熟于胸的代码用来实现这个功能。以前我也只是做了这样一个功能，也许它的代码是这样的：\n\n    function enter (p_event) {\n        var _keyCode = p_event.which ? p_event.which : p_event.keyCode;\n        var _ENTER_CODE = 13;\n        if (_ENTER_CODE === _keyCode) {\n            //enter code...\n        }\n    }\n\n如果需要兼容ie8及以下，那还需要这几行代码：\n\n    if (typeof p_event === 'undefined') {\n        p_event = window.event;\n    }\n\n当然，enter还需要绑定到一个键盘事件中，键盘事件有三种，我以前倾向于使用keyup [1]，这样的体验比较好，符合人的习惯，在松开按键的时候生效。不过有时候keydown也是很棒的选择，比如说用户希望可以快速触发时，比如游戏中，我还记得WOW有一款插件是专门修改为按下触发技能的。\n<!-- more -->\n    document.getElementById('enter_input').onkeyup = enter;\n\n---\n\n也许enter回车这样没问题，但其他按键呢？于是我做了一组测试，发现了一些问题\n\n在keyup和keydown事件中：\n\n* IE只有keyCode，which为undefined。\n* Firefox的which有值，而keyCode为0，但F1-12键则恰好相反，which为0，keyCode有值。\n* Chrome和Opare中which和keyCode都有值。\n\n按键码的一些差异：\n\n* 在IE、Safari中和Chrome、Firefox、Opare中存在差异。\n* ‘+ =’键是187 => 61。\n* ‘; :’键是186 => 59。\n* ‘- _’键是189 => 45, Opera很诡异的是109。\n* win键只有IE8和Safari是91，Opera是219，其他无法触发。\n* Meta [2] 键是93，但Opera和Chrome无法触发\n\n## keypress事件和charCode属性 ##\n\n这里其实有一个很重要但很多人都没搞清楚过的问题，那就是另外一个事件keypress，这个事情是怎么回事？曾经我只是单纯的认为它和keydown是一样的，因为它们在按下键盘后都会一直触发直到松开。而且w3school中文上的说法是\n\n>onkeypress 事件会在键盘按键被按下并释放一个键时发生\n\n不过最近看到了一个属性charCode，让我初步认识到了区别所在，似乎w3school的说法不太对。起初我以为charCode和keyCode还有which是不同浏览器实现的不同名称，但似乎charCode是mozila弄出来的一个东西，那就应该和其他2个有什么区别，因此我决定好好实验一番，来分析一下这些事件与属性究竟是怎么回事。\n\n首先在我认为最强大的Chrome中测试了一下，只有在keypress事件中，charCode才有值，而在keyup和keydown中都为0，另外我发现小键盘区域大部分按键是无法触发keypress的，还有win键、ctrl、alt、meta等都无法触发。\n\n---\n\n经过上面的测试，我大概发现了keypress的意义，**keypress只有按下可产出字符的按键时才会触发**，也因此keypress才能使用charCode，charCode的意义也很明显了，是**按键的字符的代码**，而不是keyCode或者which按键代码的意思。\n\n为了进一步检验我的理解，我试验了space、enter都有charCode值，而小键盘在点亮了Num Lock之后也有了charCode，并且按住shift或者切换Caps Lock后，charCode会发生变化也足以证明charCode是字符的unicode值，比如按下“A”时，会有小写和大写的65、97之分。\n\n---\n\n另外关于浏览器的兼容性：\n\n* IE8及以下和Opera12+是不支持charCode属性的。\n* 而在Firefox中，keypress事件触发时keyCode是没有值的。\n\n可以用以下代码试验。\n\n    document.body.onkeypress = function (p_event) {\n        p_event = p_event ? p_event : event;\n        alert('charCode is ' + p_event.charCode);\n    }\n\n如果在测试的过程中回车之类的按键触发了某些浏览器行为，可以这样避免，在事件方法的最后加上这行代码：\n\n    e.preventDefault ? e.preventDefault() : event.returnValue = false;\n\n---\n\n关于标准，在W3C标准中，其实无论是which、keyCode还是charCode都已经不推荐使用了，取而代之的是which和keyCode为key，charCode为char。不过遗憾的是目前所有浏览器都还没有实现key和char。\n\n---\n\n> 注1：不过IE6是不支持keyup的，只能用keydown。\n> 注2：meta按键就是一般在win键旁边的一个鼠标+一个菜单样式的按键，按键一般是用来弹出鼠标右键菜单的。\n\n---\n\n参考文章：\n\n* [Key codes of keydown and keyup events](http://www.javascripter.net/faq/keycodes.htm)\n* [Mozilla - keypress](https://developer.mozilla.org/en-US/docs/Web/Reference/Events/keypress)\n* [W3C Standard](http://www.w3.org/TR/DOM-Level-3-Events/#event-type-keypress)\n* [MSDN - charCode property](http://msdn.microsoft.com/en-us/library/ie/ff974890)\n\n\n","slug":"event-keycode","published":1,"date":"2013-06-05T16:00:00.000Z","updated":"2021-11-28T11:37:27.160Z","comments":1,"photos":[],"link":"","_id":"ckwj65511000evyjhd18o2abm","content":"<h2 id=\"keyup和keydown事件以及keyCode和which属性\"><a href=\"#keyup和keydown事件以及keyCode和which属性\" class=\"headerlink\" title=\"keyup和keydown事件以及keyCode和which属性\"></a>keyup和keydown事件以及keyCode和which属性</h2><p>我想关于键盘事件最常见的实例就是回车提交表单了，恐怕每个前端都有一段烂熟于胸的代码用来实现这个功能。以前我也只是做了这样一个功能，也许它的代码是这样的：</p>\n<pre><code>function enter (p_event) &#123;\n    var _keyCode = p_event.which ? p_event.which : p_event.keyCode;\n    var _ENTER_CODE = 13;\n    if (_ENTER_CODE === _keyCode) &#123;\n        //enter code...\n    &#125;\n&#125;\n</code></pre>\n<p>如果需要兼容ie8及以下，那还需要这几行代码：</p>\n<pre><code>if (typeof p_event === &#39;undefined&#39;) &#123;\n    p_event = window.event;\n&#125;\n</code></pre>\n<p>当然，enter还需要绑定到一个键盘事件中，键盘事件有三种，我以前倾向于使用keyup [1]，这样的体验比较好，符合人的习惯，在松开按键的时候生效。不过有时候keydown也是很棒的选择，比如说用户希望可以快速触发时，比如游戏中，我还记得WOW有一款插件是专门修改为按下触发技能的。</p>\n<span id=\"more\"></span>\n<pre><code>document.getElementById(&#39;enter_input&#39;).onkeyup = enter;\n</code></pre>\n<hr>\n<p>也许enter回车这样没问题，但其他按键呢？于是我做了一组测试，发现了一些问题</p>\n<p>在keyup和keydown事件中：</p>\n<ul>\n<li>IE只有keyCode，which为undefined。</li>\n<li>Firefox的which有值，而keyCode为0，但F1-12键则恰好相反，which为0，keyCode有值。</li>\n<li>Chrome和Opare中which和keyCode都有值。</li>\n</ul>\n<p>按键码的一些差异：</p>\n<ul>\n<li>在IE、Safari中和Chrome、Firefox、Opare中存在差异。</li>\n<li>‘+ =’键是187 =&gt; 61。</li>\n<li>‘; :’键是186 =&gt; 59。</li>\n<li>‘- _’键是189 =&gt; 45, Opera很诡异的是109。</li>\n<li>win键只有IE8和Safari是91，Opera是219，其他无法触发。</li>\n<li>Meta [2] 键是93，但Opera和Chrome无法触发</li>\n</ul>\n<h2 id=\"keypress事件和charCode属性\"><a href=\"#keypress事件和charCode属性\" class=\"headerlink\" title=\"keypress事件和charCode属性\"></a>keypress事件和charCode属性</h2><p>这里其实有一个很重要但很多人都没搞清楚过的问题，那就是另外一个事件keypress，这个事情是怎么回事？曾经我只是单纯的认为它和keydown是一样的，因为它们在按下键盘后都会一直触发直到松开。而且w3school中文上的说法是</p>\n<blockquote>\n<p>onkeypress 事件会在键盘按键被按下并释放一个键时发生</p>\n</blockquote>\n<p>不过最近看到了一个属性charCode，让我初步认识到了区别所在，似乎w3school的说法不太对。起初我以为charCode和keyCode还有which是不同浏览器实现的不同名称，但似乎charCode是mozila弄出来的一个东西，那就应该和其他2个有什么区别，因此我决定好好实验一番，来分析一下这些事件与属性究竟是怎么回事。</p>\n<p>首先在我认为最强大的Chrome中测试了一下，只有在keypress事件中，charCode才有值，而在keyup和keydown中都为0，另外我发现小键盘区域大部分按键是无法触发keypress的，还有win键、ctrl、alt、meta等都无法触发。</p>\n<hr>\n<p>经过上面的测试，我大概发现了keypress的意义，<strong>keypress只有按下可产出字符的按键时才会触发</strong>，也因此keypress才能使用charCode，charCode的意义也很明显了，是<strong>按键的字符的代码</strong>，而不是keyCode或者which按键代码的意思。</p>\n<p>为了进一步检验我的理解，我试验了space、enter都有charCode值，而小键盘在点亮了Num Lock之后也有了charCode，并且按住shift或者切换Caps Lock后，charCode会发生变化也足以证明charCode是字符的unicode值，比如按下“A”时，会有小写和大写的65、97之分。</p>\n<hr>\n<p>另外关于浏览器的兼容性：</p>\n<ul>\n<li>IE8及以下和Opera12+是不支持charCode属性的。</li>\n<li>而在Firefox中，keypress事件触发时keyCode是没有值的。</li>\n</ul>\n<p>可以用以下代码试验。</p>\n<pre><code>document.body.onkeypress = function (p_event) &#123;\n    p_event = p_event ? p_event : event;\n    alert(&#39;charCode is &#39; + p_event.charCode);\n&#125;\n</code></pre>\n<p>如果在测试的过程中回车之类的按键触发了某些浏览器行为，可以这样避免，在事件方法的最后加上这行代码：</p>\n<pre><code>e.preventDefault ? e.preventDefault() : event.returnValue = false;\n</code></pre>\n<hr>\n<p>关于标准，在W3C标准中，其实无论是which、keyCode还是charCode都已经不推荐使用了，取而代之的是which和keyCode为key，charCode为char。不过遗憾的是目前所有浏览器都还没有实现key和char。</p>\n<hr>\n<blockquote>\n<p>注1：不过IE6是不支持keyup的，只能用keydown。<br>注2：meta按键就是一般在win键旁边的一个鼠标+一个菜单样式的按键，按键一般是用来弹出鼠标右键菜单的。</p>\n</blockquote>\n<hr>\n<p>参考文章：</p>\n<ul>\n<li><a href=\"http://www.javascripter.net/faq/keycodes.htm\">Key codes of keydown and keyup events</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/Reference/Events/keypress\">Mozilla - keypress</a></li>\n<li><a href=\"http://www.w3.org/TR/DOM-Level-3-Events/#event-type-keypress\">W3C Standard</a></li>\n<li><a href=\"http://msdn.microsoft.com/en-us/library/ie/ff974890\">MSDN - charCode property</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"keyup和keydown事件以及keyCode和which属性\"><a href=\"#keyup和keydown事件以及keyCode和which属性\" class=\"headerlink\" title=\"keyup和keydown事件以及keyCode和which属性\"></a>keyup和keydown事件以及keyCode和which属性</h2><p>我想关于键盘事件最常见的实例就是回车提交表单了，恐怕每个前端都有一段烂熟于胸的代码用来实现这个功能。以前我也只是做了这样一个功能，也许它的代码是这样的：</p>\n<pre><code>function enter (p_event) &#123;\n    var _keyCode = p_event.which ? p_event.which : p_event.keyCode;\n    var _ENTER_CODE = 13;\n    if (_ENTER_CODE === _keyCode) &#123;\n        //enter code...\n    &#125;\n&#125;\n</code></pre>\n<p>如果需要兼容ie8及以下，那还需要这几行代码：</p>\n<pre><code>if (typeof p_event === &#39;undefined&#39;) &#123;\n    p_event = window.event;\n&#125;\n</code></pre>\n<p>当然，enter还需要绑定到一个键盘事件中，键盘事件有三种，我以前倾向于使用keyup [1]，这样的体验比较好，符合人的习惯，在松开按键的时候生效。不过有时候keydown也是很棒的选择，比如说用户希望可以快速触发时，比如游戏中，我还记得WOW有一款插件是专门修改为按下触发技能的。</p>","more":"<pre><code>document.getElementById(&#39;enter_input&#39;).onkeyup = enter;\n</code></pre>\n<hr>\n<p>也许enter回车这样没问题，但其他按键呢？于是我做了一组测试，发现了一些问题</p>\n<p>在keyup和keydown事件中：</p>\n<ul>\n<li>IE只有keyCode，which为undefined。</li>\n<li>Firefox的which有值，而keyCode为0，但F1-12键则恰好相反，which为0，keyCode有值。</li>\n<li>Chrome和Opare中which和keyCode都有值。</li>\n</ul>\n<p>按键码的一些差异：</p>\n<ul>\n<li>在IE、Safari中和Chrome、Firefox、Opare中存在差异。</li>\n<li>‘+ =’键是187 =&gt; 61。</li>\n<li>‘; :’键是186 =&gt; 59。</li>\n<li>‘- _’键是189 =&gt; 45, Opera很诡异的是109。</li>\n<li>win键只有IE8和Safari是91，Opera是219，其他无法触发。</li>\n<li>Meta [2] 键是93，但Opera和Chrome无法触发</li>\n</ul>\n<h2 id=\"keypress事件和charCode属性\"><a href=\"#keypress事件和charCode属性\" class=\"headerlink\" title=\"keypress事件和charCode属性\"></a>keypress事件和charCode属性</h2><p>这里其实有一个很重要但很多人都没搞清楚过的问题，那就是另外一个事件keypress，这个事情是怎么回事？曾经我只是单纯的认为它和keydown是一样的，因为它们在按下键盘后都会一直触发直到松开。而且w3school中文上的说法是</p>\n<blockquote>\n<p>onkeypress 事件会在键盘按键被按下并释放一个键时发生</p>\n</blockquote>\n<p>不过最近看到了一个属性charCode，让我初步认识到了区别所在，似乎w3school的说法不太对。起初我以为charCode和keyCode还有which是不同浏览器实现的不同名称，但似乎charCode是mozila弄出来的一个东西，那就应该和其他2个有什么区别，因此我决定好好实验一番，来分析一下这些事件与属性究竟是怎么回事。</p>\n<p>首先在我认为最强大的Chrome中测试了一下，只有在keypress事件中，charCode才有值，而在keyup和keydown中都为0，另外我发现小键盘区域大部分按键是无法触发keypress的，还有win键、ctrl、alt、meta等都无法触发。</p>\n<hr>\n<p>经过上面的测试，我大概发现了keypress的意义，<strong>keypress只有按下可产出字符的按键时才会触发</strong>，也因此keypress才能使用charCode，charCode的意义也很明显了，是<strong>按键的字符的代码</strong>，而不是keyCode或者which按键代码的意思。</p>\n<p>为了进一步检验我的理解，我试验了space、enter都有charCode值，而小键盘在点亮了Num Lock之后也有了charCode，并且按住shift或者切换Caps Lock后，charCode会发生变化也足以证明charCode是字符的unicode值，比如按下“A”时，会有小写和大写的65、97之分。</p>\n<hr>\n<p>另外关于浏览器的兼容性：</p>\n<ul>\n<li>IE8及以下和Opera12+是不支持charCode属性的。</li>\n<li>而在Firefox中，keypress事件触发时keyCode是没有值的。</li>\n</ul>\n<p>可以用以下代码试验。</p>\n<pre><code>document.body.onkeypress = function (p_event) &#123;\n    p_event = p_event ? p_event : event;\n    alert(&#39;charCode is &#39; + p_event.charCode);\n&#125;\n</code></pre>\n<p>如果在测试的过程中回车之类的按键触发了某些浏览器行为，可以这样避免，在事件方法的最后加上这行代码：</p>\n<pre><code>e.preventDefault ? e.preventDefault() : event.returnValue = false;\n</code></pre>\n<hr>\n<p>关于标准，在W3C标准中，其实无论是which、keyCode还是charCode都已经不推荐使用了，取而代之的是which和keyCode为key，charCode为char。不过遗憾的是目前所有浏览器都还没有实现key和char。</p>\n<hr>\n<blockquote>\n<p>注1：不过IE6是不支持keyup的，只能用keydown。<br>注2：meta按键就是一般在win键旁边的一个鼠标+一个菜单样式的按键，按键一般是用来弹出鼠标右键菜单的。</p>\n</blockquote>\n<hr>\n<p>参考文章：</p>\n<ul>\n<li><a href=\"http://www.javascripter.net/faq/keycodes.htm\">Key codes of keydown and keyup events</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/Reference/Events/keypress\">Mozilla - keypress</a></li>\n<li><a href=\"http://www.w3.org/TR/DOM-Level-3-Events/#event-type-keypress\">W3C Standard</a></li>\n<li><a href=\"http://msdn.microsoft.com/en-us/library/ie/ff974890\">MSDN - charCode property</a></li>\n</ul>"},{"layout":"post","title":"Javascript的Unit Test","_content":"\n### 单元测试Unit Test ###\n\n很早就知道单元测试这样一个概念，但直到几个月前，我真正开始接触和使用它。究竟什么是单元测试？我想也许很多使用了很久的人也不一定能描述的十分清楚，所以写了这篇文章来尝试描述它的特征和原则，以帮助更多人。\n\n##### 什么是单元测试？ #####\n\n先来看看单元测试的定义，在维基百科英文版中可以找到Kolawa Adam在 _Automated Defect Prevention: Best Practices in Software Management_ 一书中对单元测试的定义：\n\n> In computer programming, unit testing is a method by which individual units of source code, sets of one or more computer program modules together with associated control data, usage procedures, and operating procedures are tested to determine if they are fit for use.\n\n重点在于最后，单元测试的目的显而易见，用来确定是否适合使用。而测试的方法则包括控制数据，使用和操作过程。那么以我的理解，每个单元测试就是一段用于测试一个模块或接口是否能达到预期结果的代码。开发人员需要使用代码来定义一个可用的衡量标准，并且可以快速检验。\n\n很快我发现有一个误区，许多人认为单元测试必须是一个runner集中运行所有单元的测试，并一目了然。不，这仅仅是一种自动化单元测试的最佳实践，在一些小型项目中单元测试可能仅仅是一组去除其他特性的接口调用。甚至在一些图形处理或布局的项目中单元测试可以结合自身特性变的十分有趣，比如[Masonry](http://masonry.desandro.com/)，一个网格布局库，在它的单元测试中不是一个红或绿的条目，而是一行一行的小格布局用以说明布局被完成的事实，这样比代码检查布局是否正确再以颜色显示结果来得更直观高效，也避免了测试程序本身的bug导致的失误。\n\n打个比方，单元测试就像一把尺子，当测量的对象是一个曲面时，也许可以花费大力气去将它抽象成平面，但我更提倡量身定做一把弯曲的尺子去适应这个曲面。无论怎样，单元测试是为了生产代码而写，它应当足够的自由奔放，去适应各种各样的生产代码。\n<!-- more -->\n##### 为什么要单元测试？ #####\n\n也许定义中已经很清楚的指明了其意义，确认某段代码或模块或接口是否适合使用，但我想会有更多的人认为，直接在测试环境中使用软件可以更加确保软件是否可用。不，在实际使用过程中会伴随着一大批的附带操作大量增加测试时间，并且无法保证其测试覆盖率。所以我认为单元测试的目的并不仅仅是确认是否可用，而是更高效更稳定的确认其是否可用。\n\n随着项目规模的增加，函数、方法、变量都在递增，尤其是进度的不足，来自产品经理的压力，还有QA所带来的各种Bug报告会让原本整洁的代码变得一片混乱。我甚至见过同一个接口以不同的名称出现在8个不同的控制器中。这时也许我们首先想到的是重构，可是等等，在重构结束时我们如何确定项目仅仅是被重构了，而不是被改写了？此时单元测试将是一根救命稻草，它是一个衡量标准，告诉开发人员这么做是否将改变结果。\n\n不仅仅是这样。许多人认为单元测试，甚至整个测试都是在编码结束后的一道工序，而修复bug也不过是在做垃圾掩埋一类的工作。但测试应该伴随整个编码或软件周期进行，还有将在后面提到的TDD这样有趣的东西，单元测试将超前于编码。我的意思是，单元测试应该是一个框架、标准，经常被形容被脚手架，像建筑一样，脚手架的高度至少应该和大楼高度不相上下，甚至一开始就搭好脚手架。\n\n##### 如何做单元测试？ #####\n\n弄清了单元测试的目的和意义，但如何开始？很简单，首先它是一个检验，所以应该只有pass或fail两种情况。而检验的对象应该是某个接口或模块，所以应该调用它获得一个结果。检验这个结果就是单元测试的基本动作，就拿一个除法函数来做例子：\n\n    function division (a, b) {\n        return a / b;\n    }\n    var result = division(4, 2);\n    if (result === 2) {\n        alert('pass');\n    } else {\n        alert('fail');\n    }\n\n显然，将会提示pass通过。但是问题来了，这个测试的用例太单一和普通了，如果使用0做除数呢？是NaN？还是Infinity？或者在实际使用时，产品需要一个0来代替这样一个不符合数学概念的结果去适应必须为数字类型的某种计算，于是division出现了一个bug。另外当覆盖率增加，也意味着用例的增加，我们需要把if条件语句提出来做成一个函数多次调用。还有alert方法，如果用例太多，我相信你会点确认点到手软，也许可以直接显示在页面上。\n\n所以我添加了一个关于除数为0的用例，并重构了代码：\n\n    function division (a, b) {\n        if (b === 0) {\n            return 0;\n        } else {\n            return a / b;\n        }\n    }\n    function matcher (name, result, expect) {\n        if (result === expect) {\n            _print(name + '- pass');\n        } else {\n            _print(name + '- fail');\n        }\n        function _print (str) {\n            var _bar = document.createElement('p');\n            _bar.innerText = str;\n            document.body.appendChild(_bar);\n        }\n    }\n    matcher('normal', division(4, 2), 2);\n    matcher('zero', division(5, 0), 0);\n\n现在可以使用matcher方法添加许多测试用例，并且还能为该用例命名，在页面中直接显示每个用例是否通过。这样一个基本的单元测试就完成了，当然它的覆盖率还远远不够，这里仅作为一个例子。另外为了提高效率还应该使用颜色来标记是否通过，可以一目了然。\n\n##### 测试驱动开发 #####\n\nTDD是Test Driven Development 的缩写，也就是测试驱动开发。\n\n通常传统软件工程将测试描述为软件生命周期的一个环节，并且是在编码之后。但敏捷开发大师Kent Beck在2003年出版了 _Test Driven Development By Example_ 一书，从而确立了测试驱动开发这个领域。\n\nTDD需要遵循如下规则：\n\n* 写一个单元测试去描述程序的一个方面。\n* 运行它应该会失败，因为程序还缺少这个特性。\n* 为这个程序添加一些尽可能简单的代码保证测试通过。\n* 重构这部分代码，直到代码没有重复、代码责任清晰并且结构简单。\n* 持续重复这样做，积累代码。\n\n另外，衡量是否使用了TDD的一个重要标准是测试对代码的覆盖率，覆盖率在80%以下说明一个团队没有充分掌握TDD，当然高覆盖率也不能说一定使用了TDD，这仅仅是一个参考指标。\n\n在我看来，TDD是一种开发技术，而非测试技术，所以它对于代码构建的意义远大于代码测试。也许最终的代码和先开发再测试写的测试代码基本一致，但它们仍然是有很大不同的。TDD具有很强的目的性，在直接结果的指导下开发生产代码，然后不断围绕这个目标去改进代码，其优势是高效和去冗余的。所以其特点应该是由需求得出测试，由测试代码得出生产代码。打个比方就像是自行车的两个轮子，虽然都是在向同一个方向转动，但是后轮是施力的，带动车子向前，而前轮是受力的，被向前的车子带动而转。\n\n##### 行为驱动开发 #####\n\n所谓的BDD行为驱动开发，即Behaviour Driven Development，是一种新的敏捷开发方法。它更趋向于需求，需要共同利益者的参与，强调用户故事（User Story）和行为。2009年，在伦敦发表的“敏捷规格，BDD和极限测试交流”[3]中，[Dan North](http://dannorth.net/)对BDD给出了如下定义：\n\n> BDD是第二代的、由外及内的、基于拉(pull)的、多方利益相关者的(stakeholder)、多种可扩展的、高自动化的敏捷方法。它描述了一个交互循环，可以具有带有良好定义的输出（即工作中交付的结果）：已测试过的软件。\n\n另外最主观的区别就是用词，‘example’取代了‘test’，‘describe’取代了‘class’，‘behaviour’取代了‘method’等等。这正是其特征之一，自然语言的加入，使得非程序人员也能参与到测试用例的编写中来，也大大降低了客户、用户、项目管理者与开发者之间来回翻译的成本。\n\n简单来说，我认为BDD更加注重业务需求而不是技术，虽然看起来BDD确实是比ATDD做的更好，但这是一种误导，这仅仅是就某种环境下而言的。而且以国内的现状来看TDD要比BDD更适合，因为它不需要所有人员的理解和加入。\n\n### 单元测试框架 ###\n\n无论如何，单元测试永远是少不了的。其实在单元测试中测试代码和生产代码应该是等量的，正如Robert C. Martin在其 _Clean Code: A Handbook of Agile Software Craftsmanship_ 一书中所写：\n    \n> 测试必须随生产代码的演进而修改，测试越脏就越难修改\n\n于是新的测试很难被加入其中，测试代码的维护变得异常困难，最终在各种压力之中只有扔掉测试代码组。但是没有了测试代码，就失去了确保对代码的改动能如愿以偿的能力，各种问题随之而来。因此，单元测试也需要一种行之有效的实践来确保其质量和可维护性。\n\n所以正如生产代码一样，测试代码也有框架，下面介绍几种主流的Javascript的单元测试框架。\n\n#### [Jasmine](http://pivotal.github.io/jasmine/) ####\n\n有一类框架叫做xUnit，来源于著名的JAVA测试框架JUnit，xUnit则代表了一种模式，并且使用这样的命名。在Javascript中也有这样的一个老牌框架JsUnit，他的作者是Edward Hieatt来自[Pivotal Labs](http://pivotallabs.com/)，但在几年前JsUnit就已经停止维护了，他们带来了新的BDD框架Jasmine。\n\nJasmine不依赖于任何框架，所以适用于所有的Javascript代码。使用一个全局函数 `describe` 来描述每个测试，并且可以嵌套。describe函数有2个参数，一个是字符串用于描述，一个是函数用于测试。在该函数中可以使用全局函数 `it` 来定义Specs，也就是单元测试的主要内容， 使用 `expect` 函数来测试：\n\n    describe('A suite', function () {\n        it('is a spec', function () {\n            var a = true;\n            expect(a).toBe(true);\n        });\n    });\n\n另外如果想去掉某个describe，无须注释掉整段代码，只需要在describe前面加上x即可忽略该describe。\n\n##### Matcher #####\n\ntoBe方法是一个基本的 `matcher` 用来定义判断规则，可以看得出来Jasmine的方法是非常语义化的，“expect ‘a’ to be true”，如果想判断否定条件，则只需要在toBe前调用 `not` 方法：\n\n    expect(a).not().toBe(false);\n\n除了toBe这样基本的还有许多其他的[Matcher](https://github.com/pivotal/jasmine/wiki/Matchers)，比如 `toEqual` 。很多初学Jasmine会弄不清和toBe的区别，一个简单的例子就能明白它们的区别：\n\n    expect({}).not().toBe({});\n    expect({}).toEqual({});\n\n一个新建的Object不是（not to be）另一个新建的Object，但是它们是相等（to equal）的。还有 `toMatch` 可以使用字符串或者正则表达式来验证，以及其他一些特殊验证，比如undefined或者boolean的判断， `toThrow` 可以检查函数所抛出的异常。另外Jasmine还支持自定义Matcher，以NaN的检查为例，像这样使用beforeEach方法在每个测试执行前添加一个matcher：\n\n    beforeEach(function () {\n        this.addMatchers({\n            toBeNaN: function (expected) {\n                return isNaN(expected);\n            }\n        });\n    });\n\n可以想到，其参数expected是传入的一个期望的字面量，而在expect方法中传入的参数，可以通过 `this.acturl` 获取，是否调用了 `not` 方法则可以通过 `this.isNot` 获取，这是一个boolean值。最后测试输出的失败信息应该使用 `this.message` 来定义，不过它是一个function，然后在其中返回一个信息。所以继续增进toBeNaN：\n\n    beforeEach(function () {\n        this.addMatchers({\n            toBeNaN: function (expected) {\n                var actual = this.actual;\n                var not = this.isNot ? ' not' : '';\n                this.message = function () {\n                    return 'Expected ' + actual + not + ' to be NaN ' + expected;\n                };\n                return isNaN(expected);\n            }\n        });\n    });\n\n这样一个完整的matcher就创建成了。\n\n另外需要说明的是对应beforeEach是在每个spec之前执行， `afterEach` 方法则是在每个spec之后执行。这是一种AOP，即面向方面的编程（Aspect Oriented Programming）。比如有时候为了测试一个对象，可能需要多次创建和销毁它，所以为了避免冗余代码，使用它们是最佳选择。\n\n还可以使用 `jasmine.any` 方法来代表一类数据传入matcher中，比如\n\n    expect(123).toEqual(jasmine.any(Number));\n    expect(function () {}).toEqual(jasmine.any(Function));\n\n##### Spy方法 #####\n\n一个Spy能监测任何function的调用和获取其参数。这里有2个特殊的Matcher， `toHaveBeenCalled` 可以检查function是否被调用过，还有 `toHaveBeenCalledWith` 可以传入参数检查是否和这些参数一起被调用过，像这样使用 `spyOn` 来注册一个对象中的方法：\n\n    var foo, a = null;\n    beforeEach(function () {\n        var foo = {\n            set: function (str) {\n                a = str;\n            }\n        }\n        spyOn(foo, 'set');\n        foo.set(123);\n    });\n    it('tracks calls', function () {\n        expect(foo.set).toHaveBeenCalled();\n        expect(foo.set).toHaveBeenCalled(123);\n        expect(foo.set.calls[0].args[0]).toEqual(123);\n        expect(foo.set.mostRecentCall.args[0]).toEqual(123);\n        expect(a).toBeNull();\n    });\n\n在测试时该function将带有一个被调用的数组 `calls` ，而 `args` 数组就是调用时传入的参数，另外特殊属性 `mostRencentCall` 则代表最后一次调用，和calls[calls.length]一致。需要特别注意的是，这些调用将不会对变量产生作用，所以 `a` 仍为null。\n\n如果需要调用产生实际的作用，可以在spyOn方法后调用 `andCallThrough` 方法。还可以通过调用 `andReturn` 方法设定一个返回值给function。 `andCallFake` 则可以传入一个function作为参数去代替原本的function。\n\n    spyOn(foo, 'set').andCallThrough();\n\n甚至在没有function的时候可以使用Jasmine的 `createSpy` 和 `createSpyObj` 创建一个spy：\n\n    foo = jasmine.createSpy('foo');\n    obj = jasmine.createSpyObj('obj', [set, do]);\n\n    foo(123);\n    obj.set(123);\n    obj.do();\n\n其效果相当于spyOn使用在了已存在的function上。\n\n##### 时间控制 #####\n\n上面的方法都在程序顺序执行的前提下执行，但 `setTimeout` 以及 `setInterval` 两个方法会使代码分离在时间轴上。所以Jasmine提供了 `Clock` 方法来模拟时间，以获取setTimeout的不同状态。\n\n    beforeEach(function () {\n        jasmine.Clock.useMock();\n    });\n    it('set time', function () {\n        var str = 0;\n        setTimeout(function () {\n            str++;\n        }, 100);\n        expect(str).toEqual(0);\n        jasmine.Click.tick(101);\n        expect(str).toEqual(1);\n        jasmine.Click.tick(200);\n        expect(str).toEqual(3);\n    });\n\n使用Clock的方法 `useMock` 来开始时间控制，然后在it中使用 `tick` 方法来推进时间。\n\n##### 异步 #####\n\nJavascript最大的特色之一就是异步，之前介绍的方法如果存在异步调用，大部分测试时可能会不通过。因此，需要等异步回调之后再进行测试。\n\nJasmine提供了 `runs` 和 `waitsFor` 两个方法来完成这个异步的等待。需要将waitsFor方法夹在多个runs方法中，runs方法中的语句会按顺序直接执行，然后进入waitsFor方法，如果waitsFor返回false，则继续执行waitsFor，直到返回true才执行后面的runs方法。\n\n    var cb = false;\n    var ajax = {\n        success: function () {\n            cb = true;\n        }\n    };\n    spyOn(ajax, 'success');\n    it('async callback', function () {\n        runs(function () {\n            _toAjax(ajax);\n        });\n        waitsFor(function () {\n            return ajax.success.callCount > 0;\n        });\n        runs(function () {\n            expect(cb).toBeTruthy();\n        });\n    });\n\n如此，只要在waitsFor中判断回调函数是否被调用了即可完成异步测试。上面代码中我使用一个方法名直接代替了ajax请求方法来缩减不必要的代码。在第一个runs方法中发出了一个ajax请求，然后在waitsFor中等待其被调用，当第二个runs执行时说明回调函数已经被调用了，进行测试。\n\n#### [Qunit](http://qunitjs.com/) ####\n\n它是由jQuery团队开发的一款测试套件，最初依赖于jQuery库，在2009年时脱离jQuery的依赖，变成了一个真正的测试框架，适用于所有Javascript代码。\n\nQunit采用断言（Assert）来进行测试，相比于Jasmine的matcher更加多的类型，Qunit更集中在测试的度上。 `deepEqual` 用于比较一些纵向数据，比如Object或者Function等。而最常用的 `ok` 则直接判断是否为true。异步方面Qunit也很有趣，通过 `stop` 来停止测试等待异步返回，然后使用 `start` 继续测试，这要比Jasmine的过程化的等待更自由一些，不过有时也许会更难写一些。Qunit还拥有3组AOP的方法( `done` 和 'begin' )来对应于整个测试，测试和模块。\n\n对于Function的跟踪测试，Qunit似乎完全没有考虑。不过可以使用另外一个测试框架为Qunit带来的插件 [sinon-qunit](http://sinonjs.org/qunit/)。这样就可以在test中使用 `spy` 方法了。\n\n#### [Sinon](http://sinonjs.org/) ####\n\nSinon并不是一个典型的单元测试框架，更像一个库，最主要的是对Function的测试，包括 `Spy` 和 `Stub` 两个部分，Spy用于侦测Function，而Stub更像是一个Spy的插件或者助手，在Function调用前后做一些特殊的处理，比如修改配置或者回调。它正好极大的弥补了Qunit的不足，所以通常会使用Qunit+Sinon来进行单元测试。\n\n值得一提的是，Sinon的作者[Christian Johansen](http://tddjs.com/)就是 _Test-Driven JavaScript Development_ 一书的作者，这本书针对Javascript很详细的描述了单元测试的每个环节。\n\n#### [Mocha](http://visionmedia.github.io/mocha) ####\n\n它的作者就是在Github上粉丝6K的超级Jser [TJ Holowaychuk](https://github.com/visionmedia)，可以在他的页面上看到过去一年的提交量是5700多，拥有300多个项目，无论是谁都难以想象他是如何进行coding的。\n\n理所当然的，Mocha充满了Geek感，不但可以在bash中进行测试，而且还拥有一整套命令对测试进行操作。甚至使用 `diff` 可以查看当前测试与上一次成功测试的代码不一致。\n\n不仅仅是这样，Mocha非常得自由。Mocha将更多的方法集中在了describe和it中，比如异步的测试就非常棒，在it的回调函数中会获取一个参数 `done` ，类型是function，用于异步回调，当执行这个函数时就会继续测试。还可以使用 `only` 和 `skip` 去选择测试时需要的部分。Mocha的接口也一样自由，除了 `BDD` 风格和Jasmine类似的接口，还有 `TDD` 风格的 （suite test setup teardown suiteSetup suiteTeardown），还有AMD风格的 `exports`，Qunit风格等。同时测试报告也可以任意组织，无论是列表、进度条、还是飞机跑道这样奇特的样式都可以在bash中显示。\n\n### 前端测试工具 ###\n\n#### Client/Server 测试 ####\n\n相比于服务端开发，前端开发在测试方面始终面临着一个严峻的问题，那就是浏览器兼容性。[Paul Irish](http://www.paulirish.com/)曾发表文章[Browser Market Pollution: IE[x] Is the New IE6](http://www.paulirish.com/2011/browser-market-pollution-iex-is-the-new-ie6/)阐述了一个奇怪的设想，未来你可能需要在76个浏览器上开发，因为每次IE的新版本都是一个特别的浏览器，而且还有它对之前所有版本的兼容模式也是一样。虽然没人认为微软会继续如此愚蠢，不过这也说明了一个问题，前端开发中浏览器兼容性是一个永远的问题，而且我认为即使解决了浏览器的兼容性问题，未来在移动开发方面，设备兼容性也是一个问题。\n\n所以在自动化测试方面也是如此，即使所有的单元测试集中在了一个runner中，前端测试仍然要面对至少4个浏览器内核以及3个电脑操作系统加2个或更多移动操作系统，何况还有令移动开发人员头疼的Android的碎片化问题。不过可以安心的是，早已存在这样的工具可以捕获不同设备上的不同浏览器，并使之随时更新测试结果，甚至可以在一个终端上看到所有结果。\n\n##### 工具介绍 #####\n\n[JSTD（Javascript Test Driver）](https://code.google.com/p/js-test-driver/)是一个最早的C/S测试工具，来自Google，基于JAVA编写，跨平台，使用命令行控制，还有很好的编辑器支持，最常用于eclipse。不过它无法显示测试对象的设备及浏览器版本，只有浏览器名是不够的。另外JSTD已经慢慢不再活跃，它的早正如它的老。\n\nGoogle的新贵[Karma](http://karma-runner.github.io/)出现了，它使用Nodejs构建，因此跨平台，还支持PhantomJS浏览器，还支持多种框架，包括以上介绍的Jasmine、Qunit和Mocha。一次可以在多个浏览器及设备中进行测试，并控制浏览器行为和测试报告。虽然它不支持Nodejs的测试，不过没什么影响，因为Nodejs并不依赖于浏览器。\n\n还有[TestSwarm](http://swarm.jquery.org/)，出自jQuery之父John Resig之手，看来jQuery的强大果然不是偶然的，在测试方面非常到位，各种工具齐全。它最特别的地方在于所有测试环境由服务器提供，包括各种版本的主流浏览器以及iOS5的iphone设备，不过目前加入已经受限。\n\n最受瞩目的当属[Buster](http://www.busterjs.org/)，其作者之一就是[Christian Johansen](http://tddjs.com/)。和Karma很像，也使用Nodejs编写跨平台并且支持PhantomJS，一次测试所有客户端。更重要的是支持Nodejs的测试，同样支持各种主流测试框架。不过目前还在Beta测试中，很多bug而且不能很好的兼容Windows系统。它的目标还包括整合[Browser Stack](http://www.browserstack.com/)。\n\n#### 基于网页的测试 ####\n\n到目前为止我们的测试看起来十分的完美了，但是别忘了，在前端开发中存在交互问题，不能期待QA玩了命的点击某个按钮或者刷新一个页面并输入一句乱码之类的东西来测试代码。即使是开发者本身也会受不了，如果产品本身拥有一堆复杂的表单和逻辑的话。\n\n[Selenium](http://www.seleniumhq.org/)是一个测试工具集，由Thoughtworks开发，分为两部分。Selenium IDE是一个Firefox浏览器的插件，可以录制用户行为，并快速测试。\n\n而Selenium WebDriver是一个多语言的驱动浏览器的工具，支持Python、Java、Ruby、Perl、PHP或.Net。并且可以操作IE、Firefox、Safari和Chrome等主流浏览器。通过 `open` , `type` , `click` , `waitForxxx` 等指令来模拟用户行为，比如用Java测试：\n\n    public void testNew() throws Exception {\n        selenium.open(\"/\");\n        selenium.type(\"q\", \"selenium rc\");\n        selenium.click(\"btnG\");\n        selenium.waitForPageToLoad(\"30000\");\n        assertTrue(selenium.isTextPresent(\"Results * for selenium rc\"));\n    }\n\n首先跳转到跟目录，然后选择类型，点击按钮G，并等待页面载入30秒，然后使用断言测试。这样就完成了一次用户基本行为的模拟，不过复杂的模拟以及在一些非链接的操作还需要格外注意，比如Ajax请求或者Pjax的无刷新等等。\n\n另外还有一款可以模拟用户行为的网页测试工具[WATIR](http://watir.com/)，是Web Application Testing in Ruby的缩写，显然它只支持Ruby语言来操作浏览器模拟用户行为。官方声称它是一个简单而灵活的工具，无论怎样至少就官方网站的设计来看要比Selenium简约多了。同样支持模拟链接点击，按钮点击，还有表单的填写等行为。不过WATIR不支持Ajax的测试。和其他Ruby库一样需要gem来安装它：\n\n    gem install watir --no-rdoc --no-ri\n\n然后使用它\n\n    require 'rubygems'\n    require 'watir'\n    require 'watir-webdriver'\n    browser = Watir::Browser.new\n    browser.goto 'http://www.example.com/form'\n    browser.test_field(:name => 'entry.0.single').set 'Watir'\n    browser.radio(:value => 'Watir').set\n    browser.radio(:value => 'Watir').clear\n    browser.checkbox(:value => 'Ruby').set\n    browser.checkbox(:value => 'Javascript').clear\n    browser.button(:name => 'submit').click\n\n这样就使用watir完成了一次表单填写。\n\n#### 持续集成测试 ####\n\n持续集成就是通常所谓的CI(Continuous integration)，持续不断的自动化测试新加入代码后的项目。它并不属于单元测试，而是另外的范畴，不过通过使用CI服务可以很容易的在Github上测试项目，而这也就是持续集成的意义。\n\n下面以我的jQ小插件[Dialog](https://github.com/tychio/dialog#unit)为例介绍一下Travis-CI的使用方法，注册[Travis](https://travis-ci.org)，然后链接自己的Github，选择要进行持续集成的项目。此时会显示build failing，那是因为还没有在项目中进行相关配置。\n\n首先需要使用Grunt等工具配置好测试框架的自动化测试，细节可以参考我之前的文章[改进我的Workflow](http://www.tychio.net/tech/2013/09/25/improve-workflow.html)。然后在 `package.json` 中添加一下代码来指定执行的脚本：\n\n    \"scripts\": {\n        \"test\": \"grunt jasmine:test\"\n    }\n\n接着添加一个文件 `.travis.yml` 来配置travis：\n\n    language: node_js\n    node_js: \n      - \"0.8\"\n    before_script:\n      - npm install -g grunt-cli\n\n`language` 是集成测试所使用的语言，这里前端开发当然是使用Nodejs，在 `node_js` 中指定版本即可。当然Travis还支持其他多种语言，以及后端数据库等。\n\n`before_script` 则是在测试前执行的脚本程序，这里在全局安装Grunt-cli即可，因为默认的Travis会执行 `npm install` 将package.json中指定的Node包安装到项目。\n\n最后在Github中还需要在项目的Setting中的Service Hooks中配置Travis，输入Token并保存。或者直接在Travis中点击该项目条目中的扳手图标进入Github，会自动配置好。\n\n另外，如果在Github上为README文件添加一行\n    \n    [![Build Status](https://travis-ci.org/tychio/dialog.png?branch=master)](https://travis-ci.org/tychio/dialog)\n\n就可以持续直观的显示其测试结果。\n\n### 参考文章 ###\n\n* [Better unit testing](http://esj.com/articles/2012/09/24/better-unit-testing.aspx)\n\n* [Javascript Unit Test tools Q/A](http://stackoverflow.com/questions/300855/javascript-unit-test-tools-for-tdd)\n\n* [Tools to unit test your JavaScript](http://www.ibm.com/developerworks/web/library/wa-tools/)\n\n* [Agile Aliiance Guide Test Driven Development](http://guide.agilealliance.org/guide/tdd.html)\n\n* [Agile Aliiance Guide Behaviour Driven Development](http://guide.agilealliance.org/guide/bdd.html)\n\n* [BDD: ATDD done well?](http://www.infoq.com/news/2011/02/BDD-ATDD)\n\n* [Unit test wiki](http://en.wikipedia.org/wiki/Unit_test)\n\n* [BDD Wiki](http://en.wikipedia.org/wiki/Behavior-driven_development)\n\n* [Aspect-oriented Programming wiki](http://en.wikipedia.org/wiki/Aspect-oriented_programming)\n\n* [Selenium Tutorial Guru99](https://www.guru99.com/selenium-tutorial.html)\n","source":"_posts/2013-07-10-unit-test.md","raw":"---\nlayout: post\ntitle: Javascript的Unit Test\ntags: [test,unit,jasmine,CI,karma,单元测试,TDD,BDD]\ncategory: Tech\n---\n\n### 单元测试Unit Test ###\n\n很早就知道单元测试这样一个概念，但直到几个月前，我真正开始接触和使用它。究竟什么是单元测试？我想也许很多使用了很久的人也不一定能描述的十分清楚，所以写了这篇文章来尝试描述它的特征和原则，以帮助更多人。\n\n##### 什么是单元测试？ #####\n\n先来看看单元测试的定义，在维基百科英文版中可以找到Kolawa Adam在 _Automated Defect Prevention: Best Practices in Software Management_ 一书中对单元测试的定义：\n\n> In computer programming, unit testing is a method by which individual units of source code, sets of one or more computer program modules together with associated control data, usage procedures, and operating procedures are tested to determine if they are fit for use.\n\n重点在于最后，单元测试的目的显而易见，用来确定是否适合使用。而测试的方法则包括控制数据，使用和操作过程。那么以我的理解，每个单元测试就是一段用于测试一个模块或接口是否能达到预期结果的代码。开发人员需要使用代码来定义一个可用的衡量标准，并且可以快速检验。\n\n很快我发现有一个误区，许多人认为单元测试必须是一个runner集中运行所有单元的测试，并一目了然。不，这仅仅是一种自动化单元测试的最佳实践，在一些小型项目中单元测试可能仅仅是一组去除其他特性的接口调用。甚至在一些图形处理或布局的项目中单元测试可以结合自身特性变的十分有趣，比如[Masonry](http://masonry.desandro.com/)，一个网格布局库，在它的单元测试中不是一个红或绿的条目，而是一行一行的小格布局用以说明布局被完成的事实，这样比代码检查布局是否正确再以颜色显示结果来得更直观高效，也避免了测试程序本身的bug导致的失误。\n\n打个比方，单元测试就像一把尺子，当测量的对象是一个曲面时，也许可以花费大力气去将它抽象成平面，但我更提倡量身定做一把弯曲的尺子去适应这个曲面。无论怎样，单元测试是为了生产代码而写，它应当足够的自由奔放，去适应各种各样的生产代码。\n<!-- more -->\n##### 为什么要单元测试？ #####\n\n也许定义中已经很清楚的指明了其意义，确认某段代码或模块或接口是否适合使用，但我想会有更多的人认为，直接在测试环境中使用软件可以更加确保软件是否可用。不，在实际使用过程中会伴随着一大批的附带操作大量增加测试时间，并且无法保证其测试覆盖率。所以我认为单元测试的目的并不仅仅是确认是否可用，而是更高效更稳定的确认其是否可用。\n\n随着项目规模的增加，函数、方法、变量都在递增，尤其是进度的不足，来自产品经理的压力，还有QA所带来的各种Bug报告会让原本整洁的代码变得一片混乱。我甚至见过同一个接口以不同的名称出现在8个不同的控制器中。这时也许我们首先想到的是重构，可是等等，在重构结束时我们如何确定项目仅仅是被重构了，而不是被改写了？此时单元测试将是一根救命稻草，它是一个衡量标准，告诉开发人员这么做是否将改变结果。\n\n不仅仅是这样。许多人认为单元测试，甚至整个测试都是在编码结束后的一道工序，而修复bug也不过是在做垃圾掩埋一类的工作。但测试应该伴随整个编码或软件周期进行，还有将在后面提到的TDD这样有趣的东西，单元测试将超前于编码。我的意思是，单元测试应该是一个框架、标准，经常被形容被脚手架，像建筑一样，脚手架的高度至少应该和大楼高度不相上下，甚至一开始就搭好脚手架。\n\n##### 如何做单元测试？ #####\n\n弄清了单元测试的目的和意义，但如何开始？很简单，首先它是一个检验，所以应该只有pass或fail两种情况。而检验的对象应该是某个接口或模块，所以应该调用它获得一个结果。检验这个结果就是单元测试的基本动作，就拿一个除法函数来做例子：\n\n    function division (a, b) {\n        return a / b;\n    }\n    var result = division(4, 2);\n    if (result === 2) {\n        alert('pass');\n    } else {\n        alert('fail');\n    }\n\n显然，将会提示pass通过。但是问题来了，这个测试的用例太单一和普通了，如果使用0做除数呢？是NaN？还是Infinity？或者在实际使用时，产品需要一个0来代替这样一个不符合数学概念的结果去适应必须为数字类型的某种计算，于是division出现了一个bug。另外当覆盖率增加，也意味着用例的增加，我们需要把if条件语句提出来做成一个函数多次调用。还有alert方法，如果用例太多，我相信你会点确认点到手软，也许可以直接显示在页面上。\n\n所以我添加了一个关于除数为0的用例，并重构了代码：\n\n    function division (a, b) {\n        if (b === 0) {\n            return 0;\n        } else {\n            return a / b;\n        }\n    }\n    function matcher (name, result, expect) {\n        if (result === expect) {\n            _print(name + '- pass');\n        } else {\n            _print(name + '- fail');\n        }\n        function _print (str) {\n            var _bar = document.createElement('p');\n            _bar.innerText = str;\n            document.body.appendChild(_bar);\n        }\n    }\n    matcher('normal', division(4, 2), 2);\n    matcher('zero', division(5, 0), 0);\n\n现在可以使用matcher方法添加许多测试用例，并且还能为该用例命名，在页面中直接显示每个用例是否通过。这样一个基本的单元测试就完成了，当然它的覆盖率还远远不够，这里仅作为一个例子。另外为了提高效率还应该使用颜色来标记是否通过，可以一目了然。\n\n##### 测试驱动开发 #####\n\nTDD是Test Driven Development 的缩写，也就是测试驱动开发。\n\n通常传统软件工程将测试描述为软件生命周期的一个环节，并且是在编码之后。但敏捷开发大师Kent Beck在2003年出版了 _Test Driven Development By Example_ 一书，从而确立了测试驱动开发这个领域。\n\nTDD需要遵循如下规则：\n\n* 写一个单元测试去描述程序的一个方面。\n* 运行它应该会失败，因为程序还缺少这个特性。\n* 为这个程序添加一些尽可能简单的代码保证测试通过。\n* 重构这部分代码，直到代码没有重复、代码责任清晰并且结构简单。\n* 持续重复这样做，积累代码。\n\n另外，衡量是否使用了TDD的一个重要标准是测试对代码的覆盖率，覆盖率在80%以下说明一个团队没有充分掌握TDD，当然高覆盖率也不能说一定使用了TDD，这仅仅是一个参考指标。\n\n在我看来，TDD是一种开发技术，而非测试技术，所以它对于代码构建的意义远大于代码测试。也许最终的代码和先开发再测试写的测试代码基本一致，但它们仍然是有很大不同的。TDD具有很强的目的性，在直接结果的指导下开发生产代码，然后不断围绕这个目标去改进代码，其优势是高效和去冗余的。所以其特点应该是由需求得出测试，由测试代码得出生产代码。打个比方就像是自行车的两个轮子，虽然都是在向同一个方向转动，但是后轮是施力的，带动车子向前，而前轮是受力的，被向前的车子带动而转。\n\n##### 行为驱动开发 #####\n\n所谓的BDD行为驱动开发，即Behaviour Driven Development，是一种新的敏捷开发方法。它更趋向于需求，需要共同利益者的参与，强调用户故事（User Story）和行为。2009年，在伦敦发表的“敏捷规格，BDD和极限测试交流”[3]中，[Dan North](http://dannorth.net/)对BDD给出了如下定义：\n\n> BDD是第二代的、由外及内的、基于拉(pull)的、多方利益相关者的(stakeholder)、多种可扩展的、高自动化的敏捷方法。它描述了一个交互循环，可以具有带有良好定义的输出（即工作中交付的结果）：已测试过的软件。\n\n另外最主观的区别就是用词，‘example’取代了‘test’，‘describe’取代了‘class’，‘behaviour’取代了‘method’等等。这正是其特征之一，自然语言的加入，使得非程序人员也能参与到测试用例的编写中来，也大大降低了客户、用户、项目管理者与开发者之间来回翻译的成本。\n\n简单来说，我认为BDD更加注重业务需求而不是技术，虽然看起来BDD确实是比ATDD做的更好，但这是一种误导，这仅仅是就某种环境下而言的。而且以国内的现状来看TDD要比BDD更适合，因为它不需要所有人员的理解和加入。\n\n### 单元测试框架 ###\n\n无论如何，单元测试永远是少不了的。其实在单元测试中测试代码和生产代码应该是等量的，正如Robert C. Martin在其 _Clean Code: A Handbook of Agile Software Craftsmanship_ 一书中所写：\n    \n> 测试必须随生产代码的演进而修改，测试越脏就越难修改\n\n于是新的测试很难被加入其中，测试代码的维护变得异常困难，最终在各种压力之中只有扔掉测试代码组。但是没有了测试代码，就失去了确保对代码的改动能如愿以偿的能力，各种问题随之而来。因此，单元测试也需要一种行之有效的实践来确保其质量和可维护性。\n\n所以正如生产代码一样，测试代码也有框架，下面介绍几种主流的Javascript的单元测试框架。\n\n#### [Jasmine](http://pivotal.github.io/jasmine/) ####\n\n有一类框架叫做xUnit，来源于著名的JAVA测试框架JUnit，xUnit则代表了一种模式，并且使用这样的命名。在Javascript中也有这样的一个老牌框架JsUnit，他的作者是Edward Hieatt来自[Pivotal Labs](http://pivotallabs.com/)，但在几年前JsUnit就已经停止维护了，他们带来了新的BDD框架Jasmine。\n\nJasmine不依赖于任何框架，所以适用于所有的Javascript代码。使用一个全局函数 `describe` 来描述每个测试，并且可以嵌套。describe函数有2个参数，一个是字符串用于描述，一个是函数用于测试。在该函数中可以使用全局函数 `it` 来定义Specs，也就是单元测试的主要内容， 使用 `expect` 函数来测试：\n\n    describe('A suite', function () {\n        it('is a spec', function () {\n            var a = true;\n            expect(a).toBe(true);\n        });\n    });\n\n另外如果想去掉某个describe，无须注释掉整段代码，只需要在describe前面加上x即可忽略该describe。\n\n##### Matcher #####\n\ntoBe方法是一个基本的 `matcher` 用来定义判断规则，可以看得出来Jasmine的方法是非常语义化的，“expect ‘a’ to be true”，如果想判断否定条件，则只需要在toBe前调用 `not` 方法：\n\n    expect(a).not().toBe(false);\n\n除了toBe这样基本的还有许多其他的[Matcher](https://github.com/pivotal/jasmine/wiki/Matchers)，比如 `toEqual` 。很多初学Jasmine会弄不清和toBe的区别，一个简单的例子就能明白它们的区别：\n\n    expect({}).not().toBe({});\n    expect({}).toEqual({});\n\n一个新建的Object不是（not to be）另一个新建的Object，但是它们是相等（to equal）的。还有 `toMatch` 可以使用字符串或者正则表达式来验证，以及其他一些特殊验证，比如undefined或者boolean的判断， `toThrow` 可以检查函数所抛出的异常。另外Jasmine还支持自定义Matcher，以NaN的检查为例，像这样使用beforeEach方法在每个测试执行前添加一个matcher：\n\n    beforeEach(function () {\n        this.addMatchers({\n            toBeNaN: function (expected) {\n                return isNaN(expected);\n            }\n        });\n    });\n\n可以想到，其参数expected是传入的一个期望的字面量，而在expect方法中传入的参数，可以通过 `this.acturl` 获取，是否调用了 `not` 方法则可以通过 `this.isNot` 获取，这是一个boolean值。最后测试输出的失败信息应该使用 `this.message` 来定义，不过它是一个function，然后在其中返回一个信息。所以继续增进toBeNaN：\n\n    beforeEach(function () {\n        this.addMatchers({\n            toBeNaN: function (expected) {\n                var actual = this.actual;\n                var not = this.isNot ? ' not' : '';\n                this.message = function () {\n                    return 'Expected ' + actual + not + ' to be NaN ' + expected;\n                };\n                return isNaN(expected);\n            }\n        });\n    });\n\n这样一个完整的matcher就创建成了。\n\n另外需要说明的是对应beforeEach是在每个spec之前执行， `afterEach` 方法则是在每个spec之后执行。这是一种AOP，即面向方面的编程（Aspect Oriented Programming）。比如有时候为了测试一个对象，可能需要多次创建和销毁它，所以为了避免冗余代码，使用它们是最佳选择。\n\n还可以使用 `jasmine.any` 方法来代表一类数据传入matcher中，比如\n\n    expect(123).toEqual(jasmine.any(Number));\n    expect(function () {}).toEqual(jasmine.any(Function));\n\n##### Spy方法 #####\n\n一个Spy能监测任何function的调用和获取其参数。这里有2个特殊的Matcher， `toHaveBeenCalled` 可以检查function是否被调用过，还有 `toHaveBeenCalledWith` 可以传入参数检查是否和这些参数一起被调用过，像这样使用 `spyOn` 来注册一个对象中的方法：\n\n    var foo, a = null;\n    beforeEach(function () {\n        var foo = {\n            set: function (str) {\n                a = str;\n            }\n        }\n        spyOn(foo, 'set');\n        foo.set(123);\n    });\n    it('tracks calls', function () {\n        expect(foo.set).toHaveBeenCalled();\n        expect(foo.set).toHaveBeenCalled(123);\n        expect(foo.set.calls[0].args[0]).toEqual(123);\n        expect(foo.set.mostRecentCall.args[0]).toEqual(123);\n        expect(a).toBeNull();\n    });\n\n在测试时该function将带有一个被调用的数组 `calls` ，而 `args` 数组就是调用时传入的参数，另外特殊属性 `mostRencentCall` 则代表最后一次调用，和calls[calls.length]一致。需要特别注意的是，这些调用将不会对变量产生作用，所以 `a` 仍为null。\n\n如果需要调用产生实际的作用，可以在spyOn方法后调用 `andCallThrough` 方法。还可以通过调用 `andReturn` 方法设定一个返回值给function。 `andCallFake` 则可以传入一个function作为参数去代替原本的function。\n\n    spyOn(foo, 'set').andCallThrough();\n\n甚至在没有function的时候可以使用Jasmine的 `createSpy` 和 `createSpyObj` 创建一个spy：\n\n    foo = jasmine.createSpy('foo');\n    obj = jasmine.createSpyObj('obj', [set, do]);\n\n    foo(123);\n    obj.set(123);\n    obj.do();\n\n其效果相当于spyOn使用在了已存在的function上。\n\n##### 时间控制 #####\n\n上面的方法都在程序顺序执行的前提下执行，但 `setTimeout` 以及 `setInterval` 两个方法会使代码分离在时间轴上。所以Jasmine提供了 `Clock` 方法来模拟时间，以获取setTimeout的不同状态。\n\n    beforeEach(function () {\n        jasmine.Clock.useMock();\n    });\n    it('set time', function () {\n        var str = 0;\n        setTimeout(function () {\n            str++;\n        }, 100);\n        expect(str).toEqual(0);\n        jasmine.Click.tick(101);\n        expect(str).toEqual(1);\n        jasmine.Click.tick(200);\n        expect(str).toEqual(3);\n    });\n\n使用Clock的方法 `useMock` 来开始时间控制，然后在it中使用 `tick` 方法来推进时间。\n\n##### 异步 #####\n\nJavascript最大的特色之一就是异步，之前介绍的方法如果存在异步调用，大部分测试时可能会不通过。因此，需要等异步回调之后再进行测试。\n\nJasmine提供了 `runs` 和 `waitsFor` 两个方法来完成这个异步的等待。需要将waitsFor方法夹在多个runs方法中，runs方法中的语句会按顺序直接执行，然后进入waitsFor方法，如果waitsFor返回false，则继续执行waitsFor，直到返回true才执行后面的runs方法。\n\n    var cb = false;\n    var ajax = {\n        success: function () {\n            cb = true;\n        }\n    };\n    spyOn(ajax, 'success');\n    it('async callback', function () {\n        runs(function () {\n            _toAjax(ajax);\n        });\n        waitsFor(function () {\n            return ajax.success.callCount > 0;\n        });\n        runs(function () {\n            expect(cb).toBeTruthy();\n        });\n    });\n\n如此，只要在waitsFor中判断回调函数是否被调用了即可完成异步测试。上面代码中我使用一个方法名直接代替了ajax请求方法来缩减不必要的代码。在第一个runs方法中发出了一个ajax请求，然后在waitsFor中等待其被调用，当第二个runs执行时说明回调函数已经被调用了，进行测试。\n\n#### [Qunit](http://qunitjs.com/) ####\n\n它是由jQuery团队开发的一款测试套件，最初依赖于jQuery库，在2009年时脱离jQuery的依赖，变成了一个真正的测试框架，适用于所有Javascript代码。\n\nQunit采用断言（Assert）来进行测试，相比于Jasmine的matcher更加多的类型，Qunit更集中在测试的度上。 `deepEqual` 用于比较一些纵向数据，比如Object或者Function等。而最常用的 `ok` 则直接判断是否为true。异步方面Qunit也很有趣，通过 `stop` 来停止测试等待异步返回，然后使用 `start` 继续测试，这要比Jasmine的过程化的等待更自由一些，不过有时也许会更难写一些。Qunit还拥有3组AOP的方法( `done` 和 'begin' )来对应于整个测试，测试和模块。\n\n对于Function的跟踪测试，Qunit似乎完全没有考虑。不过可以使用另外一个测试框架为Qunit带来的插件 [sinon-qunit](http://sinonjs.org/qunit/)。这样就可以在test中使用 `spy` 方法了。\n\n#### [Sinon](http://sinonjs.org/) ####\n\nSinon并不是一个典型的单元测试框架，更像一个库，最主要的是对Function的测试，包括 `Spy` 和 `Stub` 两个部分，Spy用于侦测Function，而Stub更像是一个Spy的插件或者助手，在Function调用前后做一些特殊的处理，比如修改配置或者回调。它正好极大的弥补了Qunit的不足，所以通常会使用Qunit+Sinon来进行单元测试。\n\n值得一提的是，Sinon的作者[Christian Johansen](http://tddjs.com/)就是 _Test-Driven JavaScript Development_ 一书的作者，这本书针对Javascript很详细的描述了单元测试的每个环节。\n\n#### [Mocha](http://visionmedia.github.io/mocha) ####\n\n它的作者就是在Github上粉丝6K的超级Jser [TJ Holowaychuk](https://github.com/visionmedia)，可以在他的页面上看到过去一年的提交量是5700多，拥有300多个项目，无论是谁都难以想象他是如何进行coding的。\n\n理所当然的，Mocha充满了Geek感，不但可以在bash中进行测试，而且还拥有一整套命令对测试进行操作。甚至使用 `diff` 可以查看当前测试与上一次成功测试的代码不一致。\n\n不仅仅是这样，Mocha非常得自由。Mocha将更多的方法集中在了describe和it中，比如异步的测试就非常棒，在it的回调函数中会获取一个参数 `done` ，类型是function，用于异步回调，当执行这个函数时就会继续测试。还可以使用 `only` 和 `skip` 去选择测试时需要的部分。Mocha的接口也一样自由，除了 `BDD` 风格和Jasmine类似的接口，还有 `TDD` 风格的 （suite test setup teardown suiteSetup suiteTeardown），还有AMD风格的 `exports`，Qunit风格等。同时测试报告也可以任意组织，无论是列表、进度条、还是飞机跑道这样奇特的样式都可以在bash中显示。\n\n### 前端测试工具 ###\n\n#### Client/Server 测试 ####\n\n相比于服务端开发，前端开发在测试方面始终面临着一个严峻的问题，那就是浏览器兼容性。[Paul Irish](http://www.paulirish.com/)曾发表文章[Browser Market Pollution: IE[x] Is the New IE6](http://www.paulirish.com/2011/browser-market-pollution-iex-is-the-new-ie6/)阐述了一个奇怪的设想，未来你可能需要在76个浏览器上开发，因为每次IE的新版本都是一个特别的浏览器，而且还有它对之前所有版本的兼容模式也是一样。虽然没人认为微软会继续如此愚蠢，不过这也说明了一个问题，前端开发中浏览器兼容性是一个永远的问题，而且我认为即使解决了浏览器的兼容性问题，未来在移动开发方面，设备兼容性也是一个问题。\n\n所以在自动化测试方面也是如此，即使所有的单元测试集中在了一个runner中，前端测试仍然要面对至少4个浏览器内核以及3个电脑操作系统加2个或更多移动操作系统，何况还有令移动开发人员头疼的Android的碎片化问题。不过可以安心的是，早已存在这样的工具可以捕获不同设备上的不同浏览器，并使之随时更新测试结果，甚至可以在一个终端上看到所有结果。\n\n##### 工具介绍 #####\n\n[JSTD（Javascript Test Driver）](https://code.google.com/p/js-test-driver/)是一个最早的C/S测试工具，来自Google，基于JAVA编写，跨平台，使用命令行控制，还有很好的编辑器支持，最常用于eclipse。不过它无法显示测试对象的设备及浏览器版本，只有浏览器名是不够的。另外JSTD已经慢慢不再活跃，它的早正如它的老。\n\nGoogle的新贵[Karma](http://karma-runner.github.io/)出现了，它使用Nodejs构建，因此跨平台，还支持PhantomJS浏览器，还支持多种框架，包括以上介绍的Jasmine、Qunit和Mocha。一次可以在多个浏览器及设备中进行测试，并控制浏览器行为和测试报告。虽然它不支持Nodejs的测试，不过没什么影响，因为Nodejs并不依赖于浏览器。\n\n还有[TestSwarm](http://swarm.jquery.org/)，出自jQuery之父John Resig之手，看来jQuery的强大果然不是偶然的，在测试方面非常到位，各种工具齐全。它最特别的地方在于所有测试环境由服务器提供，包括各种版本的主流浏览器以及iOS5的iphone设备，不过目前加入已经受限。\n\n最受瞩目的当属[Buster](http://www.busterjs.org/)，其作者之一就是[Christian Johansen](http://tddjs.com/)。和Karma很像，也使用Nodejs编写跨平台并且支持PhantomJS，一次测试所有客户端。更重要的是支持Nodejs的测试，同样支持各种主流测试框架。不过目前还在Beta测试中，很多bug而且不能很好的兼容Windows系统。它的目标还包括整合[Browser Stack](http://www.browserstack.com/)。\n\n#### 基于网页的测试 ####\n\n到目前为止我们的测试看起来十分的完美了，但是别忘了，在前端开发中存在交互问题，不能期待QA玩了命的点击某个按钮或者刷新一个页面并输入一句乱码之类的东西来测试代码。即使是开发者本身也会受不了，如果产品本身拥有一堆复杂的表单和逻辑的话。\n\n[Selenium](http://www.seleniumhq.org/)是一个测试工具集，由Thoughtworks开发，分为两部分。Selenium IDE是一个Firefox浏览器的插件，可以录制用户行为，并快速测试。\n\n而Selenium WebDriver是一个多语言的驱动浏览器的工具，支持Python、Java、Ruby、Perl、PHP或.Net。并且可以操作IE、Firefox、Safari和Chrome等主流浏览器。通过 `open` , `type` , `click` , `waitForxxx` 等指令来模拟用户行为，比如用Java测试：\n\n    public void testNew() throws Exception {\n        selenium.open(\"/\");\n        selenium.type(\"q\", \"selenium rc\");\n        selenium.click(\"btnG\");\n        selenium.waitForPageToLoad(\"30000\");\n        assertTrue(selenium.isTextPresent(\"Results * for selenium rc\"));\n    }\n\n首先跳转到跟目录，然后选择类型，点击按钮G，并等待页面载入30秒，然后使用断言测试。这样就完成了一次用户基本行为的模拟，不过复杂的模拟以及在一些非链接的操作还需要格外注意，比如Ajax请求或者Pjax的无刷新等等。\n\n另外还有一款可以模拟用户行为的网页测试工具[WATIR](http://watir.com/)，是Web Application Testing in Ruby的缩写，显然它只支持Ruby语言来操作浏览器模拟用户行为。官方声称它是一个简单而灵活的工具，无论怎样至少就官方网站的设计来看要比Selenium简约多了。同样支持模拟链接点击，按钮点击，还有表单的填写等行为。不过WATIR不支持Ajax的测试。和其他Ruby库一样需要gem来安装它：\n\n    gem install watir --no-rdoc --no-ri\n\n然后使用它\n\n    require 'rubygems'\n    require 'watir'\n    require 'watir-webdriver'\n    browser = Watir::Browser.new\n    browser.goto 'http://www.example.com/form'\n    browser.test_field(:name => 'entry.0.single').set 'Watir'\n    browser.radio(:value => 'Watir').set\n    browser.radio(:value => 'Watir').clear\n    browser.checkbox(:value => 'Ruby').set\n    browser.checkbox(:value => 'Javascript').clear\n    browser.button(:name => 'submit').click\n\n这样就使用watir完成了一次表单填写。\n\n#### 持续集成测试 ####\n\n持续集成就是通常所谓的CI(Continuous integration)，持续不断的自动化测试新加入代码后的项目。它并不属于单元测试，而是另外的范畴，不过通过使用CI服务可以很容易的在Github上测试项目，而这也就是持续集成的意义。\n\n下面以我的jQ小插件[Dialog](https://github.com/tychio/dialog#unit)为例介绍一下Travis-CI的使用方法，注册[Travis](https://travis-ci.org)，然后链接自己的Github，选择要进行持续集成的项目。此时会显示build failing，那是因为还没有在项目中进行相关配置。\n\n首先需要使用Grunt等工具配置好测试框架的自动化测试，细节可以参考我之前的文章[改进我的Workflow](http://www.tychio.net/tech/2013/09/25/improve-workflow.html)。然后在 `package.json` 中添加一下代码来指定执行的脚本：\n\n    \"scripts\": {\n        \"test\": \"grunt jasmine:test\"\n    }\n\n接着添加一个文件 `.travis.yml` 来配置travis：\n\n    language: node_js\n    node_js: \n      - \"0.8\"\n    before_script:\n      - npm install -g grunt-cli\n\n`language` 是集成测试所使用的语言，这里前端开发当然是使用Nodejs，在 `node_js` 中指定版本即可。当然Travis还支持其他多种语言，以及后端数据库等。\n\n`before_script` 则是在测试前执行的脚本程序，这里在全局安装Grunt-cli即可，因为默认的Travis会执行 `npm install` 将package.json中指定的Node包安装到项目。\n\n最后在Github中还需要在项目的Setting中的Service Hooks中配置Travis，输入Token并保存。或者直接在Travis中点击该项目条目中的扳手图标进入Github，会自动配置好。\n\n另外，如果在Github上为README文件添加一行\n    \n    [![Build Status](https://travis-ci.org/tychio/dialog.png?branch=master)](https://travis-ci.org/tychio/dialog)\n\n就可以持续直观的显示其测试结果。\n\n### 参考文章 ###\n\n* [Better unit testing](http://esj.com/articles/2012/09/24/better-unit-testing.aspx)\n\n* [Javascript Unit Test tools Q/A](http://stackoverflow.com/questions/300855/javascript-unit-test-tools-for-tdd)\n\n* [Tools to unit test your JavaScript](http://www.ibm.com/developerworks/web/library/wa-tools/)\n\n* [Agile Aliiance Guide Test Driven Development](http://guide.agilealliance.org/guide/tdd.html)\n\n* [Agile Aliiance Guide Behaviour Driven Development](http://guide.agilealliance.org/guide/bdd.html)\n\n* [BDD: ATDD done well?](http://www.infoq.com/news/2011/02/BDD-ATDD)\n\n* [Unit test wiki](http://en.wikipedia.org/wiki/Unit_test)\n\n* [BDD Wiki](http://en.wikipedia.org/wiki/Behavior-driven_development)\n\n* [Aspect-oriented Programming wiki](http://en.wikipedia.org/wiki/Aspect-oriented_programming)\n\n* [Selenium Tutorial Guru99](https://www.guru99.com/selenium-tutorial.html)\n","slug":"unit-test","published":1,"date":"2013-07-09T16:00:00.000Z","updated":"2021-11-28T11:37:27.160Z","comments":1,"photos":[],"link":"","_id":"ckwj65511000gvyjhbktl1ivx","content":"<h3 id=\"单元测试Unit-Test\"><a href=\"#单元测试Unit-Test\" class=\"headerlink\" title=\"单元测试Unit Test\"></a>单元测试Unit Test</h3><p>很早就知道单元测试这样一个概念，但直到几个月前，我真正开始接触和使用它。究竟什么是单元测试？我想也许很多使用了很久的人也不一定能描述的十分清楚，所以写了这篇文章来尝试描述它的特征和原则，以帮助更多人。</p>\n<h5 id=\"什么是单元测试？\"><a href=\"#什么是单元测试？\" class=\"headerlink\" title=\"什么是单元测试？\"></a>什么是单元测试？</h5><p>先来看看单元测试的定义，在维基百科英文版中可以找到Kolawa Adam在 <em>Automated Defect Prevention: Best Practices in Software Management</em> 一书中对单元测试的定义：</p>\n<blockquote>\n<p>In computer programming, unit testing is a method by which individual units of source code, sets of one or more computer program modules together with associated control data, usage procedures, and operating procedures are tested to determine if they are fit for use.</p>\n</blockquote>\n<p>重点在于最后，单元测试的目的显而易见，用来确定是否适合使用。而测试的方法则包括控制数据，使用和操作过程。那么以我的理解，每个单元测试就是一段用于测试一个模块或接口是否能达到预期结果的代码。开发人员需要使用代码来定义一个可用的衡量标准，并且可以快速检验。</p>\n<p>很快我发现有一个误区，许多人认为单元测试必须是一个runner集中运行所有单元的测试，并一目了然。不，这仅仅是一种自动化单元测试的最佳实践，在一些小型项目中单元测试可能仅仅是一组去除其他特性的接口调用。甚至在一些图形处理或布局的项目中单元测试可以结合自身特性变的十分有趣，比如<a href=\"http://masonry.desandro.com/\">Masonry</a>，一个网格布局库，在它的单元测试中不是一个红或绿的条目，而是一行一行的小格布局用以说明布局被完成的事实，这样比代码检查布局是否正确再以颜色显示结果来得更直观高效，也避免了测试程序本身的bug导致的失误。</p>\n<p>打个比方，单元测试就像一把尺子，当测量的对象是一个曲面时，也许可以花费大力气去将它抽象成平面，但我更提倡量身定做一把弯曲的尺子去适应这个曲面。无论怎样，单元测试是为了生产代码而写，它应当足够的自由奔放，去适应各种各样的生产代码。</p>\n<span id=\"more\"></span>\n<h5 id=\"为什么要单元测试？\"><a href=\"#为什么要单元测试？\" class=\"headerlink\" title=\"为什么要单元测试？\"></a>为什么要单元测试？</h5><p>也许定义中已经很清楚的指明了其意义，确认某段代码或模块或接口是否适合使用，但我想会有更多的人认为，直接在测试环境中使用软件可以更加确保软件是否可用。不，在实际使用过程中会伴随着一大批的附带操作大量增加测试时间，并且无法保证其测试覆盖率。所以我认为单元测试的目的并不仅仅是确认是否可用，而是更高效更稳定的确认其是否可用。</p>\n<p>随着项目规模的增加，函数、方法、变量都在递增，尤其是进度的不足，来自产品经理的压力，还有QA所带来的各种Bug报告会让原本整洁的代码变得一片混乱。我甚至见过同一个接口以不同的名称出现在8个不同的控制器中。这时也许我们首先想到的是重构，可是等等，在重构结束时我们如何确定项目仅仅是被重构了，而不是被改写了？此时单元测试将是一根救命稻草，它是一个衡量标准，告诉开发人员这么做是否将改变结果。</p>\n<p>不仅仅是这样。许多人认为单元测试，甚至整个测试都是在编码结束后的一道工序，而修复bug也不过是在做垃圾掩埋一类的工作。但测试应该伴随整个编码或软件周期进行，还有将在后面提到的TDD这样有趣的东西，单元测试将超前于编码。我的意思是，单元测试应该是一个框架、标准，经常被形容被脚手架，像建筑一样，脚手架的高度至少应该和大楼高度不相上下，甚至一开始就搭好脚手架。</p>\n<h5 id=\"如何做单元测试？\"><a href=\"#如何做单元测试？\" class=\"headerlink\" title=\"如何做单元测试？\"></a>如何做单元测试？</h5><p>弄清了单元测试的目的和意义，但如何开始？很简单，首先它是一个检验，所以应该只有pass或fail两种情况。而检验的对象应该是某个接口或模块，所以应该调用它获得一个结果。检验这个结果就是单元测试的基本动作，就拿一个除法函数来做例子：</p>\n<pre><code>function division (a, b) &#123;\n    return a / b;\n&#125;\nvar result = division(4, 2);\nif (result === 2) &#123;\n    alert(&#39;pass&#39;);\n&#125; else &#123;\n    alert(&#39;fail&#39;);\n&#125;\n</code></pre>\n<p>显然，将会提示pass通过。但是问题来了，这个测试的用例太单一和普通了，如果使用0做除数呢？是NaN？还是Infinity？或者在实际使用时，产品需要一个0来代替这样一个不符合数学概念的结果去适应必须为数字类型的某种计算，于是division出现了一个bug。另外当覆盖率增加，也意味着用例的增加，我们需要把if条件语句提出来做成一个函数多次调用。还有alert方法，如果用例太多，我相信你会点确认点到手软，也许可以直接显示在页面上。</p>\n<p>所以我添加了一个关于除数为0的用例，并重构了代码：</p>\n<pre><code>function division (a, b) &#123;\n    if (b === 0) &#123;\n        return 0;\n    &#125; else &#123;\n        return a / b;\n    &#125;\n&#125;\nfunction matcher (name, result, expect) &#123;\n    if (result === expect) &#123;\n        _print(name + &#39;- pass&#39;);\n    &#125; else &#123;\n        _print(name + &#39;- fail&#39;);\n    &#125;\n    function _print (str) &#123;\n        var _bar = document.createElement(&#39;p&#39;);\n        _bar.innerText = str;\n        document.body.appendChild(_bar);\n    &#125;\n&#125;\nmatcher(&#39;normal&#39;, division(4, 2), 2);\nmatcher(&#39;zero&#39;, division(5, 0), 0);\n</code></pre>\n<p>现在可以使用matcher方法添加许多测试用例，并且还能为该用例命名，在页面中直接显示每个用例是否通过。这样一个基本的单元测试就完成了，当然它的覆盖率还远远不够，这里仅作为一个例子。另外为了提高效率还应该使用颜色来标记是否通过，可以一目了然。</p>\n<h5 id=\"测试驱动开发\"><a href=\"#测试驱动开发\" class=\"headerlink\" title=\"测试驱动开发\"></a>测试驱动开发</h5><p>TDD是Test Driven Development 的缩写，也就是测试驱动开发。</p>\n<p>通常传统软件工程将测试描述为软件生命周期的一个环节，并且是在编码之后。但敏捷开发大师Kent Beck在2003年出版了 <em>Test Driven Development By Example</em> 一书，从而确立了测试驱动开发这个领域。</p>\n<p>TDD需要遵循如下规则：</p>\n<ul>\n<li>写一个单元测试去描述程序的一个方面。</li>\n<li>运行它应该会失败，因为程序还缺少这个特性。</li>\n<li>为这个程序添加一些尽可能简单的代码保证测试通过。</li>\n<li>重构这部分代码，直到代码没有重复、代码责任清晰并且结构简单。</li>\n<li>持续重复这样做，积累代码。</li>\n</ul>\n<p>另外，衡量是否使用了TDD的一个重要标准是测试对代码的覆盖率，覆盖率在80%以下说明一个团队没有充分掌握TDD，当然高覆盖率也不能说一定使用了TDD，这仅仅是一个参考指标。</p>\n<p>在我看来，TDD是一种开发技术，而非测试技术，所以它对于代码构建的意义远大于代码测试。也许最终的代码和先开发再测试写的测试代码基本一致，但它们仍然是有很大不同的。TDD具有很强的目的性，在直接结果的指导下开发生产代码，然后不断围绕这个目标去改进代码，其优势是高效和去冗余的。所以其特点应该是由需求得出测试，由测试代码得出生产代码。打个比方就像是自行车的两个轮子，虽然都是在向同一个方向转动，但是后轮是施力的，带动车子向前，而前轮是受力的，被向前的车子带动而转。</p>\n<h5 id=\"行为驱动开发\"><a href=\"#行为驱动开发\" class=\"headerlink\" title=\"行为驱动开发\"></a>行为驱动开发</h5><p>所谓的BDD行为驱动开发，即Behaviour Driven Development，是一种新的敏捷开发方法。它更趋向于需求，需要共同利益者的参与，强调用户故事（User Story）和行为。2009年，在伦敦发表的“敏捷规格，BDD和极限测试交流”[3]中，<a href=\"http://dannorth.net/\">Dan North</a>对BDD给出了如下定义：</p>\n<blockquote>\n<p>BDD是第二代的、由外及内的、基于拉(pull)的、多方利益相关者的(stakeholder)、多种可扩展的、高自动化的敏捷方法。它描述了一个交互循环，可以具有带有良好定义的输出（即工作中交付的结果）：已测试过的软件。</p>\n</blockquote>\n<p>另外最主观的区别就是用词，‘example’取代了‘test’，‘describe’取代了‘class’，‘behaviour’取代了‘method’等等。这正是其特征之一，自然语言的加入，使得非程序人员也能参与到测试用例的编写中来，也大大降低了客户、用户、项目管理者与开发者之间来回翻译的成本。</p>\n<p>简单来说，我认为BDD更加注重业务需求而不是技术，虽然看起来BDD确实是比ATDD做的更好，但这是一种误导，这仅仅是就某种环境下而言的。而且以国内的现状来看TDD要比BDD更适合，因为它不需要所有人员的理解和加入。</p>\n<h3 id=\"单元测试框架\"><a href=\"#单元测试框架\" class=\"headerlink\" title=\"单元测试框架\"></a>单元测试框架</h3><p>无论如何，单元测试永远是少不了的。其实在单元测试中测试代码和生产代码应该是等量的，正如Robert C. Martin在其 <em>Clean Code: A Handbook of Agile Software Craftsmanship</em> 一书中所写：</p>\n<blockquote>\n<p>测试必须随生产代码的演进而修改，测试越脏就越难修改</p>\n</blockquote>\n<p>于是新的测试很难被加入其中，测试代码的维护变得异常困难，最终在各种压力之中只有扔掉测试代码组。但是没有了测试代码，就失去了确保对代码的改动能如愿以偿的能力，各种问题随之而来。因此，单元测试也需要一种行之有效的实践来确保其质量和可维护性。</p>\n<p>所以正如生产代码一样，测试代码也有框架，下面介绍几种主流的Javascript的单元测试框架。</p>\n<h4 id=\"Jasmine\"><a href=\"#Jasmine\" class=\"headerlink\" title=\"Jasmine\"></a><a href=\"http://pivotal.github.io/jasmine/\">Jasmine</a></h4><p>有一类框架叫做xUnit，来源于著名的JAVA测试框架JUnit，xUnit则代表了一种模式，并且使用这样的命名。在Javascript中也有这样的一个老牌框架JsUnit，他的作者是Edward Hieatt来自<a href=\"http://pivotallabs.com/\">Pivotal Labs</a>，但在几年前JsUnit就已经停止维护了，他们带来了新的BDD框架Jasmine。</p>\n<p>Jasmine不依赖于任何框架，所以适用于所有的Javascript代码。使用一个全局函数 <code>describe</code> 来描述每个测试，并且可以嵌套。describe函数有2个参数，一个是字符串用于描述，一个是函数用于测试。在该函数中可以使用全局函数 <code>it</code> 来定义Specs，也就是单元测试的主要内容， 使用 <code>expect</code> 函数来测试：</p>\n<pre><code>describe(&#39;A suite&#39;, function () &#123;\n    it(&#39;is a spec&#39;, function () &#123;\n        var a = true;\n        expect(a).toBe(true);\n    &#125;);\n&#125;);\n</code></pre>\n<p>另外如果想去掉某个describe，无须注释掉整段代码，只需要在describe前面加上x即可忽略该describe。</p>\n<h5 id=\"Matcher\"><a href=\"#Matcher\" class=\"headerlink\" title=\"Matcher\"></a>Matcher</h5><p>toBe方法是一个基本的 <code>matcher</code> 用来定义判断规则，可以看得出来Jasmine的方法是非常语义化的，“expect ‘a’ to be true”，如果想判断否定条件，则只需要在toBe前调用 <code>not</code> 方法：</p>\n<pre><code>expect(a).not().toBe(false);\n</code></pre>\n<p>除了toBe这样基本的还有许多其他的<a href=\"https://github.com/pivotal/jasmine/wiki/Matchers\">Matcher</a>，比如 <code>toEqual</code> 。很多初学Jasmine会弄不清和toBe的区别，一个简单的例子就能明白它们的区别：</p>\n<pre><code>expect(&#123;&#125;).not().toBe(&#123;&#125;);\nexpect(&#123;&#125;).toEqual(&#123;&#125;);\n</code></pre>\n<p>一个新建的Object不是（not to be）另一个新建的Object，但是它们是相等（to equal）的。还有 <code>toMatch</code> 可以使用字符串或者正则表达式来验证，以及其他一些特殊验证，比如undefined或者boolean的判断， <code>toThrow</code> 可以检查函数所抛出的异常。另外Jasmine还支持自定义Matcher，以NaN的检查为例，像这样使用beforeEach方法在每个测试执行前添加一个matcher：</p>\n<pre><code>beforeEach(function () &#123;\n    this.addMatchers(&#123;\n        toBeNaN: function (expected) &#123;\n            return isNaN(expected);\n        &#125;\n    &#125;);\n&#125;);\n</code></pre>\n<p>可以想到，其参数expected是传入的一个期望的字面量，而在expect方法中传入的参数，可以通过 <code>this.acturl</code> 获取，是否调用了 <code>not</code> 方法则可以通过 <code>this.isNot</code> 获取，这是一个boolean值。最后测试输出的失败信息应该使用 <code>this.message</code> 来定义，不过它是一个function，然后在其中返回一个信息。所以继续增进toBeNaN：</p>\n<pre><code>beforeEach(function () &#123;\n    this.addMatchers(&#123;\n        toBeNaN: function (expected) &#123;\n            var actual = this.actual;\n            var not = this.isNot ? &#39; not&#39; : &#39;&#39;;\n            this.message = function () &#123;\n                return &#39;Expected &#39; + actual + not + &#39; to be NaN &#39; + expected;\n            &#125;;\n            return isNaN(expected);\n        &#125;\n    &#125;);\n&#125;);\n</code></pre>\n<p>这样一个完整的matcher就创建成了。</p>\n<p>另外需要说明的是对应beforeEach是在每个spec之前执行， <code>afterEach</code> 方法则是在每个spec之后执行。这是一种AOP，即面向方面的编程（Aspect Oriented Programming）。比如有时候为了测试一个对象，可能需要多次创建和销毁它，所以为了避免冗余代码，使用它们是最佳选择。</p>\n<p>还可以使用 <code>jasmine.any</code> 方法来代表一类数据传入matcher中，比如</p>\n<pre><code>expect(123).toEqual(jasmine.any(Number));\nexpect(function () &#123;&#125;).toEqual(jasmine.any(Function));\n</code></pre>\n<h5 id=\"Spy方法\"><a href=\"#Spy方法\" class=\"headerlink\" title=\"Spy方法\"></a>Spy方法</h5><p>一个Spy能监测任何function的调用和获取其参数。这里有2个特殊的Matcher， <code>toHaveBeenCalled</code> 可以检查function是否被调用过，还有 <code>toHaveBeenCalledWith</code> 可以传入参数检查是否和这些参数一起被调用过，像这样使用 <code>spyOn</code> 来注册一个对象中的方法：</p>\n<pre><code>var foo, a = null;\nbeforeEach(function () &#123;\n    var foo = &#123;\n        set: function (str) &#123;\n            a = str;\n        &#125;\n    &#125;\n    spyOn(foo, &#39;set&#39;);\n    foo.set(123);\n&#125;);\nit(&#39;tracks calls&#39;, function () &#123;\n    expect(foo.set).toHaveBeenCalled();\n    expect(foo.set).toHaveBeenCalled(123);\n    expect(foo.set.calls[0].args[0]).toEqual(123);\n    expect(foo.set.mostRecentCall.args[0]).toEqual(123);\n    expect(a).toBeNull();\n&#125;);\n</code></pre>\n<p>在测试时该function将带有一个被调用的数组 <code>calls</code> ，而 <code>args</code> 数组就是调用时传入的参数，另外特殊属性 <code>mostRencentCall</code> 则代表最后一次调用，和calls[calls.length]一致。需要特别注意的是，这些调用将不会对变量产生作用，所以 <code>a</code> 仍为null。</p>\n<p>如果需要调用产生实际的作用，可以在spyOn方法后调用 <code>andCallThrough</code> 方法。还可以通过调用 <code>andReturn</code> 方法设定一个返回值给function。 <code>andCallFake</code> 则可以传入一个function作为参数去代替原本的function。</p>\n<pre><code>spyOn(foo, &#39;set&#39;).andCallThrough();\n</code></pre>\n<p>甚至在没有function的时候可以使用Jasmine的 <code>createSpy</code> 和 <code>createSpyObj</code> 创建一个spy：</p>\n<pre><code>foo = jasmine.createSpy(&#39;foo&#39;);\nobj = jasmine.createSpyObj(&#39;obj&#39;, [set, do]);\n\nfoo(123);\nobj.set(123);\nobj.do();\n</code></pre>\n<p>其效果相当于spyOn使用在了已存在的function上。</p>\n<h5 id=\"时间控制\"><a href=\"#时间控制\" class=\"headerlink\" title=\"时间控制\"></a>时间控制</h5><p>上面的方法都在程序顺序执行的前提下执行，但 <code>setTimeout</code> 以及 <code>setInterval</code> 两个方法会使代码分离在时间轴上。所以Jasmine提供了 <code>Clock</code> 方法来模拟时间，以获取setTimeout的不同状态。</p>\n<pre><code>beforeEach(function () &#123;\n    jasmine.Clock.useMock();\n&#125;);\nit(&#39;set time&#39;, function () &#123;\n    var str = 0;\n    setTimeout(function () &#123;\n        str++;\n    &#125;, 100);\n    expect(str).toEqual(0);\n    jasmine.Click.tick(101);\n    expect(str).toEqual(1);\n    jasmine.Click.tick(200);\n    expect(str).toEqual(3);\n&#125;);\n</code></pre>\n<p>使用Clock的方法 <code>useMock</code> 来开始时间控制，然后在it中使用 <code>tick</code> 方法来推进时间。</p>\n<h5 id=\"异步\"><a href=\"#异步\" class=\"headerlink\" title=\"异步\"></a>异步</h5><p>Javascript最大的特色之一就是异步，之前介绍的方法如果存在异步调用，大部分测试时可能会不通过。因此，需要等异步回调之后再进行测试。</p>\n<p>Jasmine提供了 <code>runs</code> 和 <code>waitsFor</code> 两个方法来完成这个异步的等待。需要将waitsFor方法夹在多个runs方法中，runs方法中的语句会按顺序直接执行，然后进入waitsFor方法，如果waitsFor返回false，则继续执行waitsFor，直到返回true才执行后面的runs方法。</p>\n<pre><code>var cb = false;\nvar ajax = &#123;\n    success: function () &#123;\n        cb = true;\n    &#125;\n&#125;;\nspyOn(ajax, &#39;success&#39;);\nit(&#39;async callback&#39;, function () &#123;\n    runs(function () &#123;\n        _toAjax(ajax);\n    &#125;);\n    waitsFor(function () &#123;\n        return ajax.success.callCount &gt; 0;\n    &#125;);\n    runs(function () &#123;\n        expect(cb).toBeTruthy();\n    &#125;);\n&#125;);\n</code></pre>\n<p>如此，只要在waitsFor中判断回调函数是否被调用了即可完成异步测试。上面代码中我使用一个方法名直接代替了ajax请求方法来缩减不必要的代码。在第一个runs方法中发出了一个ajax请求，然后在waitsFor中等待其被调用，当第二个runs执行时说明回调函数已经被调用了，进行测试。</p>\n<h4 id=\"Qunit\"><a href=\"#Qunit\" class=\"headerlink\" title=\"Qunit\"></a><a href=\"http://qunitjs.com/\">Qunit</a></h4><p>它是由jQuery团队开发的一款测试套件，最初依赖于jQuery库，在2009年时脱离jQuery的依赖，变成了一个真正的测试框架，适用于所有Javascript代码。</p>\n<p>Qunit采用断言（Assert）来进行测试，相比于Jasmine的matcher更加多的类型，Qunit更集中在测试的度上。 <code>deepEqual</code> 用于比较一些纵向数据，比如Object或者Function等。而最常用的 <code>ok</code> 则直接判断是否为true。异步方面Qunit也很有趣，通过 <code>stop</code> 来停止测试等待异步返回，然后使用 <code>start</code> 继续测试，这要比Jasmine的过程化的等待更自由一些，不过有时也许会更难写一些。Qunit还拥有3组AOP的方法( <code>done</code> 和 ‘begin’ )来对应于整个测试，测试和模块。</p>\n<p>对于Function的跟踪测试，Qunit似乎完全没有考虑。不过可以使用另外一个测试框架为Qunit带来的插件 <a href=\"http://sinonjs.org/qunit/\">sinon-qunit</a>。这样就可以在test中使用 <code>spy</code> 方法了。</p>\n<h4 id=\"Sinon\"><a href=\"#Sinon\" class=\"headerlink\" title=\"Sinon\"></a><a href=\"http://sinonjs.org/\">Sinon</a></h4><p>Sinon并不是一个典型的单元测试框架，更像一个库，最主要的是对Function的测试，包括 <code>Spy</code> 和 <code>Stub</code> 两个部分，Spy用于侦测Function，而Stub更像是一个Spy的插件或者助手，在Function调用前后做一些特殊的处理，比如修改配置或者回调。它正好极大的弥补了Qunit的不足，所以通常会使用Qunit+Sinon来进行单元测试。</p>\n<p>值得一提的是，Sinon的作者<a href=\"http://tddjs.com/\">Christian Johansen</a>就是 <em>Test-Driven JavaScript Development</em> 一书的作者，这本书针对Javascript很详细的描述了单元测试的每个环节。</p>\n<h4 id=\"Mocha\"><a href=\"#Mocha\" class=\"headerlink\" title=\"Mocha\"></a><a href=\"http://visionmedia.github.io/mocha\">Mocha</a></h4><p>它的作者就是在Github上粉丝6K的超级Jser <a href=\"https://github.com/visionmedia\">TJ Holowaychuk</a>，可以在他的页面上看到过去一年的提交量是5700多，拥有300多个项目，无论是谁都难以想象他是如何进行coding的。</p>\n<p>理所当然的，Mocha充满了Geek感，不但可以在bash中进行测试，而且还拥有一整套命令对测试进行操作。甚至使用 <code>diff</code> 可以查看当前测试与上一次成功测试的代码不一致。</p>\n<p>不仅仅是这样，Mocha非常得自由。Mocha将更多的方法集中在了describe和it中，比如异步的测试就非常棒，在it的回调函数中会获取一个参数 <code>done</code> ，类型是function，用于异步回调，当执行这个函数时就会继续测试。还可以使用 <code>only</code> 和 <code>skip</code> 去选择测试时需要的部分。Mocha的接口也一样自由，除了 <code>BDD</code> 风格和Jasmine类似的接口，还有 <code>TDD</code> 风格的 （suite test setup teardown suiteSetup suiteTeardown），还有AMD风格的 <code>exports</code>，Qunit风格等。同时测试报告也可以任意组织，无论是列表、进度条、还是飞机跑道这样奇特的样式都可以在bash中显示。</p>\n<h3 id=\"前端测试工具\"><a href=\"#前端测试工具\" class=\"headerlink\" title=\"前端测试工具\"></a>前端测试工具</h3><h4 id=\"Client-Server-测试\"><a href=\"#Client-Server-测试\" class=\"headerlink\" title=\"Client/Server 测试\"></a>Client/Server 测试</h4><p>相比于服务端开发，前端开发在测试方面始终面临着一个严峻的问题，那就是浏览器兼容性。<a href=\"http://www.paulirish.com/\">Paul Irish</a>曾发表文章<a href=\"http://www.paulirish.com/2011/browser-market-pollution-iex-is-the-new-ie6/\">Browser Market Pollution: IE[x] Is the New IE6</a>阐述了一个奇怪的设想，未来你可能需要在76个浏览器上开发，因为每次IE的新版本都是一个特别的浏览器，而且还有它对之前所有版本的兼容模式也是一样。虽然没人认为微软会继续如此愚蠢，不过这也说明了一个问题，前端开发中浏览器兼容性是一个永远的问题，而且我认为即使解决了浏览器的兼容性问题，未来在移动开发方面，设备兼容性也是一个问题。</p>\n<p>所以在自动化测试方面也是如此，即使所有的单元测试集中在了一个runner中，前端测试仍然要面对至少4个浏览器内核以及3个电脑操作系统加2个或更多移动操作系统，何况还有令移动开发人员头疼的Android的碎片化问题。不过可以安心的是，早已存在这样的工具可以捕获不同设备上的不同浏览器，并使之随时更新测试结果，甚至可以在一个终端上看到所有结果。</p>\n<h5 id=\"工具介绍\"><a href=\"#工具介绍\" class=\"headerlink\" title=\"工具介绍\"></a>工具介绍</h5><p><a href=\"https://code.google.com/p/js-test-driver/\">JSTD（Javascript Test Driver）</a>是一个最早的C/S测试工具，来自Google，基于JAVA编写，跨平台，使用命令行控制，还有很好的编辑器支持，最常用于eclipse。不过它无法显示测试对象的设备及浏览器版本，只有浏览器名是不够的。另外JSTD已经慢慢不再活跃，它的早正如它的老。</p>\n<p>Google的新贵<a href=\"http://karma-runner.github.io/\">Karma</a>出现了，它使用Nodejs构建，因此跨平台，还支持PhantomJS浏览器，还支持多种框架，包括以上介绍的Jasmine、Qunit和Mocha。一次可以在多个浏览器及设备中进行测试，并控制浏览器行为和测试报告。虽然它不支持Nodejs的测试，不过没什么影响，因为Nodejs并不依赖于浏览器。</p>\n<p>还有<a href=\"http://swarm.jquery.org/\">TestSwarm</a>，出自jQuery之父John Resig之手，看来jQuery的强大果然不是偶然的，在测试方面非常到位，各种工具齐全。它最特别的地方在于所有测试环境由服务器提供，包括各种版本的主流浏览器以及iOS5的iphone设备，不过目前加入已经受限。</p>\n<p>最受瞩目的当属<a href=\"http://www.busterjs.org/\">Buster</a>，其作者之一就是<a href=\"http://tddjs.com/\">Christian Johansen</a>。和Karma很像，也使用Nodejs编写跨平台并且支持PhantomJS，一次测试所有客户端。更重要的是支持Nodejs的测试，同样支持各种主流测试框架。不过目前还在Beta测试中，很多bug而且不能很好的兼容Windows系统。它的目标还包括整合<a href=\"http://www.browserstack.com/\">Browser Stack</a>。</p>\n<h4 id=\"基于网页的测试\"><a href=\"#基于网页的测试\" class=\"headerlink\" title=\"基于网页的测试\"></a>基于网页的测试</h4><p>到目前为止我们的测试看起来十分的完美了，但是别忘了，在前端开发中存在交互问题，不能期待QA玩了命的点击某个按钮或者刷新一个页面并输入一句乱码之类的东西来测试代码。即使是开发者本身也会受不了，如果产品本身拥有一堆复杂的表单和逻辑的话。</p>\n<p><a href=\"http://www.seleniumhq.org/\">Selenium</a>是一个测试工具集，由Thoughtworks开发，分为两部分。Selenium IDE是一个Firefox浏览器的插件，可以录制用户行为，并快速测试。</p>\n<p>而Selenium WebDriver是一个多语言的驱动浏览器的工具，支持Python、Java、Ruby、Perl、PHP或.Net。并且可以操作IE、Firefox、Safari和Chrome等主流浏览器。通过 <code>open</code> , <code>type</code> , <code>click</code> , <code>waitForxxx</code> 等指令来模拟用户行为，比如用Java测试：</p>\n<pre><code>public void testNew() throws Exception &#123;\n    selenium.open(&quot;/&quot;);\n    selenium.type(&quot;q&quot;, &quot;selenium rc&quot;);\n    selenium.click(&quot;btnG&quot;);\n    selenium.waitForPageToLoad(&quot;30000&quot;);\n    assertTrue(selenium.isTextPresent(&quot;Results * for selenium rc&quot;));\n&#125;\n</code></pre>\n<p>首先跳转到跟目录，然后选择类型，点击按钮G，并等待页面载入30秒，然后使用断言测试。这样就完成了一次用户基本行为的模拟，不过复杂的模拟以及在一些非链接的操作还需要格外注意，比如Ajax请求或者Pjax的无刷新等等。</p>\n<p>另外还有一款可以模拟用户行为的网页测试工具<a href=\"http://watir.com/\">WATIR</a>，是Web Application Testing in Ruby的缩写，显然它只支持Ruby语言来操作浏览器模拟用户行为。官方声称它是一个简单而灵活的工具，无论怎样至少就官方网站的设计来看要比Selenium简约多了。同样支持模拟链接点击，按钮点击，还有表单的填写等行为。不过WATIR不支持Ajax的测试。和其他Ruby库一样需要gem来安装它：</p>\n<pre><code>gem install watir --no-rdoc --no-ri\n</code></pre>\n<p>然后使用它</p>\n<pre><code>require &#39;rubygems&#39;\nrequire &#39;watir&#39;\nrequire &#39;watir-webdriver&#39;\nbrowser = Watir::Browser.new\nbrowser.goto &#39;http://www.example.com/form&#39;\nbrowser.test_field(:name =&gt; &#39;entry.0.single&#39;).set &#39;Watir&#39;\nbrowser.radio(:value =&gt; &#39;Watir&#39;).set\nbrowser.radio(:value =&gt; &#39;Watir&#39;).clear\nbrowser.checkbox(:value =&gt; &#39;Ruby&#39;).set\nbrowser.checkbox(:value =&gt; &#39;Javascript&#39;).clear\nbrowser.button(:name =&gt; &#39;submit&#39;).click\n</code></pre>\n<p>这样就使用watir完成了一次表单填写。</p>\n<h4 id=\"持续集成测试\"><a href=\"#持续集成测试\" class=\"headerlink\" title=\"持续集成测试\"></a>持续集成测试</h4><p>持续集成就是通常所谓的CI(Continuous integration)，持续不断的自动化测试新加入代码后的项目。它并不属于单元测试，而是另外的范畴，不过通过使用CI服务可以很容易的在Github上测试项目，而这也就是持续集成的意义。</p>\n<p>下面以我的jQ小插件<a href=\"https://github.com/tychio/dialog#unit\">Dialog</a>为例介绍一下Travis-CI的使用方法，注册<a href=\"https://travis-ci.org/\">Travis</a>，然后链接自己的Github，选择要进行持续集成的项目。此时会显示build failing，那是因为还没有在项目中进行相关配置。</p>\n<p>首先需要使用Grunt等工具配置好测试框架的自动化测试，细节可以参考我之前的文章<a href=\"http://www.tychio.net/tech/2013/09/25/improve-workflow.html\">改进我的Workflow</a>。然后在 <code>package.json</code> 中添加一下代码来指定执行的脚本：</p>\n<pre><code>&quot;scripts&quot;: &#123;\n    &quot;test&quot;: &quot;grunt jasmine:test&quot;\n&#125;\n</code></pre>\n<p>接着添加一个文件 <code>.travis.yml</code> 来配置travis：</p>\n<pre><code>language: node_js\nnode_js: \n  - &quot;0.8&quot;\nbefore_script:\n  - npm install -g grunt-cli\n</code></pre>\n<p><code>language</code> 是集成测试所使用的语言，这里前端开发当然是使用Nodejs，在 <code>node_js</code> 中指定版本即可。当然Travis还支持其他多种语言，以及后端数据库等。</p>\n<p><code>before_script</code> 则是在测试前执行的脚本程序，这里在全局安装Grunt-cli即可，因为默认的Travis会执行 <code>npm install</code> 将package.json中指定的Node包安装到项目。</p>\n<p>最后在Github中还需要在项目的Setting中的Service Hooks中配置Travis，输入Token并保存。或者直接在Travis中点击该项目条目中的扳手图标进入Github，会自动配置好。</p>\n<p>另外，如果在Github上为README文件添加一行</p>\n<pre><code>[![Build Status](https://travis-ci.org/tychio/dialog.png?branch=master)](https://travis-ci.org/tychio/dialog)\n</code></pre>\n<p>就可以持续直观的显示其测试结果。</p>\n<h3 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h3><ul>\n<li><p><a href=\"http://esj.com/articles/2012/09/24/better-unit-testing.aspx\">Better unit testing</a></p>\n</li>\n<li><p><a href=\"http://stackoverflow.com/questions/300855/javascript-unit-test-tools-for-tdd\">Javascript Unit Test tools Q/A</a></p>\n</li>\n<li><p><a href=\"http://www.ibm.com/developerworks/web/library/wa-tools/\">Tools to unit test your JavaScript</a></p>\n</li>\n<li><p><a href=\"http://guide.agilealliance.org/guide/tdd.html\">Agile Aliiance Guide Test Driven Development</a></p>\n</li>\n<li><p><a href=\"http://guide.agilealliance.org/guide/bdd.html\">Agile Aliiance Guide Behaviour Driven Development</a></p>\n</li>\n<li><p><a href=\"http://www.infoq.com/news/2011/02/BDD-ATDD\">BDD: ATDD done well?</a></p>\n</li>\n<li><p><a href=\"http://en.wikipedia.org/wiki/Unit_test\">Unit test wiki</a></p>\n</li>\n<li><p><a href=\"http://en.wikipedia.org/wiki/Behavior-driven_development\">BDD Wiki</a></p>\n</li>\n<li><p><a href=\"http://en.wikipedia.org/wiki/Aspect-oriented_programming\">Aspect-oriented Programming wiki</a></p>\n</li>\n<li><p><a href=\"https://www.guru99.com/selenium-tutorial.html\">Selenium Tutorial Guru99</a></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"单元测试Unit-Test\"><a href=\"#单元测试Unit-Test\" class=\"headerlink\" title=\"单元测试Unit Test\"></a>单元测试Unit Test</h3><p>很早就知道单元测试这样一个概念，但直到几个月前，我真正开始接触和使用它。究竟什么是单元测试？我想也许很多使用了很久的人也不一定能描述的十分清楚，所以写了这篇文章来尝试描述它的特征和原则，以帮助更多人。</p>\n<h5 id=\"什么是单元测试？\"><a href=\"#什么是单元测试？\" class=\"headerlink\" title=\"什么是单元测试？\"></a>什么是单元测试？</h5><p>先来看看单元测试的定义，在维基百科英文版中可以找到Kolawa Adam在 <em>Automated Defect Prevention: Best Practices in Software Management</em> 一书中对单元测试的定义：</p>\n<blockquote>\n<p>In computer programming, unit testing is a method by which individual units of source code, sets of one or more computer program modules together with associated control data, usage procedures, and operating procedures are tested to determine if they are fit for use.</p>\n</blockquote>\n<p>重点在于最后，单元测试的目的显而易见，用来确定是否适合使用。而测试的方法则包括控制数据，使用和操作过程。那么以我的理解，每个单元测试就是一段用于测试一个模块或接口是否能达到预期结果的代码。开发人员需要使用代码来定义一个可用的衡量标准，并且可以快速检验。</p>\n<p>很快我发现有一个误区，许多人认为单元测试必须是一个runner集中运行所有单元的测试，并一目了然。不，这仅仅是一种自动化单元测试的最佳实践，在一些小型项目中单元测试可能仅仅是一组去除其他特性的接口调用。甚至在一些图形处理或布局的项目中单元测试可以结合自身特性变的十分有趣，比如<a href=\"http://masonry.desandro.com/\">Masonry</a>，一个网格布局库，在它的单元测试中不是一个红或绿的条目，而是一行一行的小格布局用以说明布局被完成的事实，这样比代码检查布局是否正确再以颜色显示结果来得更直观高效，也避免了测试程序本身的bug导致的失误。</p>\n<p>打个比方，单元测试就像一把尺子，当测量的对象是一个曲面时，也许可以花费大力气去将它抽象成平面，但我更提倡量身定做一把弯曲的尺子去适应这个曲面。无论怎样，单元测试是为了生产代码而写，它应当足够的自由奔放，去适应各种各样的生产代码。</p>","more":"<h5 id=\"为什么要单元测试？\"><a href=\"#为什么要单元测试？\" class=\"headerlink\" title=\"为什么要单元测试？\"></a>为什么要单元测试？</h5><p>也许定义中已经很清楚的指明了其意义，确认某段代码或模块或接口是否适合使用，但我想会有更多的人认为，直接在测试环境中使用软件可以更加确保软件是否可用。不，在实际使用过程中会伴随着一大批的附带操作大量增加测试时间，并且无法保证其测试覆盖率。所以我认为单元测试的目的并不仅仅是确认是否可用，而是更高效更稳定的确认其是否可用。</p>\n<p>随着项目规模的增加，函数、方法、变量都在递增，尤其是进度的不足，来自产品经理的压力，还有QA所带来的各种Bug报告会让原本整洁的代码变得一片混乱。我甚至见过同一个接口以不同的名称出现在8个不同的控制器中。这时也许我们首先想到的是重构，可是等等，在重构结束时我们如何确定项目仅仅是被重构了，而不是被改写了？此时单元测试将是一根救命稻草，它是一个衡量标准，告诉开发人员这么做是否将改变结果。</p>\n<p>不仅仅是这样。许多人认为单元测试，甚至整个测试都是在编码结束后的一道工序，而修复bug也不过是在做垃圾掩埋一类的工作。但测试应该伴随整个编码或软件周期进行，还有将在后面提到的TDD这样有趣的东西，单元测试将超前于编码。我的意思是，单元测试应该是一个框架、标准，经常被形容被脚手架，像建筑一样，脚手架的高度至少应该和大楼高度不相上下，甚至一开始就搭好脚手架。</p>\n<h5 id=\"如何做单元测试？\"><a href=\"#如何做单元测试？\" class=\"headerlink\" title=\"如何做单元测试？\"></a>如何做单元测试？</h5><p>弄清了单元测试的目的和意义，但如何开始？很简单，首先它是一个检验，所以应该只有pass或fail两种情况。而检验的对象应该是某个接口或模块，所以应该调用它获得一个结果。检验这个结果就是单元测试的基本动作，就拿一个除法函数来做例子：</p>\n<pre><code>function division (a, b) &#123;\n    return a / b;\n&#125;\nvar result = division(4, 2);\nif (result === 2) &#123;\n    alert(&#39;pass&#39;);\n&#125; else &#123;\n    alert(&#39;fail&#39;);\n&#125;\n</code></pre>\n<p>显然，将会提示pass通过。但是问题来了，这个测试的用例太单一和普通了，如果使用0做除数呢？是NaN？还是Infinity？或者在实际使用时，产品需要一个0来代替这样一个不符合数学概念的结果去适应必须为数字类型的某种计算，于是division出现了一个bug。另外当覆盖率增加，也意味着用例的增加，我们需要把if条件语句提出来做成一个函数多次调用。还有alert方法，如果用例太多，我相信你会点确认点到手软，也许可以直接显示在页面上。</p>\n<p>所以我添加了一个关于除数为0的用例，并重构了代码：</p>\n<pre><code>function division (a, b) &#123;\n    if (b === 0) &#123;\n        return 0;\n    &#125; else &#123;\n        return a / b;\n    &#125;\n&#125;\nfunction matcher (name, result, expect) &#123;\n    if (result === expect) &#123;\n        _print(name + &#39;- pass&#39;);\n    &#125; else &#123;\n        _print(name + &#39;- fail&#39;);\n    &#125;\n    function _print (str) &#123;\n        var _bar = document.createElement(&#39;p&#39;);\n        _bar.innerText = str;\n        document.body.appendChild(_bar);\n    &#125;\n&#125;\nmatcher(&#39;normal&#39;, division(4, 2), 2);\nmatcher(&#39;zero&#39;, division(5, 0), 0);\n</code></pre>\n<p>现在可以使用matcher方法添加许多测试用例，并且还能为该用例命名，在页面中直接显示每个用例是否通过。这样一个基本的单元测试就完成了，当然它的覆盖率还远远不够，这里仅作为一个例子。另外为了提高效率还应该使用颜色来标记是否通过，可以一目了然。</p>\n<h5 id=\"测试驱动开发\"><a href=\"#测试驱动开发\" class=\"headerlink\" title=\"测试驱动开发\"></a>测试驱动开发</h5><p>TDD是Test Driven Development 的缩写，也就是测试驱动开发。</p>\n<p>通常传统软件工程将测试描述为软件生命周期的一个环节，并且是在编码之后。但敏捷开发大师Kent Beck在2003年出版了 <em>Test Driven Development By Example</em> 一书，从而确立了测试驱动开发这个领域。</p>\n<p>TDD需要遵循如下规则：</p>\n<ul>\n<li>写一个单元测试去描述程序的一个方面。</li>\n<li>运行它应该会失败，因为程序还缺少这个特性。</li>\n<li>为这个程序添加一些尽可能简单的代码保证测试通过。</li>\n<li>重构这部分代码，直到代码没有重复、代码责任清晰并且结构简单。</li>\n<li>持续重复这样做，积累代码。</li>\n</ul>\n<p>另外，衡量是否使用了TDD的一个重要标准是测试对代码的覆盖率，覆盖率在80%以下说明一个团队没有充分掌握TDD，当然高覆盖率也不能说一定使用了TDD，这仅仅是一个参考指标。</p>\n<p>在我看来，TDD是一种开发技术，而非测试技术，所以它对于代码构建的意义远大于代码测试。也许最终的代码和先开发再测试写的测试代码基本一致，但它们仍然是有很大不同的。TDD具有很强的目的性，在直接结果的指导下开发生产代码，然后不断围绕这个目标去改进代码，其优势是高效和去冗余的。所以其特点应该是由需求得出测试，由测试代码得出生产代码。打个比方就像是自行车的两个轮子，虽然都是在向同一个方向转动，但是后轮是施力的，带动车子向前，而前轮是受力的，被向前的车子带动而转。</p>\n<h5 id=\"行为驱动开发\"><a href=\"#行为驱动开发\" class=\"headerlink\" title=\"行为驱动开发\"></a>行为驱动开发</h5><p>所谓的BDD行为驱动开发，即Behaviour Driven Development，是一种新的敏捷开发方法。它更趋向于需求，需要共同利益者的参与，强调用户故事（User Story）和行为。2009年，在伦敦发表的“敏捷规格，BDD和极限测试交流”[3]中，<a href=\"http://dannorth.net/\">Dan North</a>对BDD给出了如下定义：</p>\n<blockquote>\n<p>BDD是第二代的、由外及内的、基于拉(pull)的、多方利益相关者的(stakeholder)、多种可扩展的、高自动化的敏捷方法。它描述了一个交互循环，可以具有带有良好定义的输出（即工作中交付的结果）：已测试过的软件。</p>\n</blockquote>\n<p>另外最主观的区别就是用词，‘example’取代了‘test’，‘describe’取代了‘class’，‘behaviour’取代了‘method’等等。这正是其特征之一，自然语言的加入，使得非程序人员也能参与到测试用例的编写中来，也大大降低了客户、用户、项目管理者与开发者之间来回翻译的成本。</p>\n<p>简单来说，我认为BDD更加注重业务需求而不是技术，虽然看起来BDD确实是比ATDD做的更好，但这是一种误导，这仅仅是就某种环境下而言的。而且以国内的现状来看TDD要比BDD更适合，因为它不需要所有人员的理解和加入。</p>\n<h3 id=\"单元测试框架\"><a href=\"#单元测试框架\" class=\"headerlink\" title=\"单元测试框架\"></a>单元测试框架</h3><p>无论如何，单元测试永远是少不了的。其实在单元测试中测试代码和生产代码应该是等量的，正如Robert C. Martin在其 <em>Clean Code: A Handbook of Agile Software Craftsmanship</em> 一书中所写：</p>\n<blockquote>\n<p>测试必须随生产代码的演进而修改，测试越脏就越难修改</p>\n</blockquote>\n<p>于是新的测试很难被加入其中，测试代码的维护变得异常困难，最终在各种压力之中只有扔掉测试代码组。但是没有了测试代码，就失去了确保对代码的改动能如愿以偿的能力，各种问题随之而来。因此，单元测试也需要一种行之有效的实践来确保其质量和可维护性。</p>\n<p>所以正如生产代码一样，测试代码也有框架，下面介绍几种主流的Javascript的单元测试框架。</p>\n<h4 id=\"Jasmine\"><a href=\"#Jasmine\" class=\"headerlink\" title=\"Jasmine\"></a><a href=\"http://pivotal.github.io/jasmine/\">Jasmine</a></h4><p>有一类框架叫做xUnit，来源于著名的JAVA测试框架JUnit，xUnit则代表了一种模式，并且使用这样的命名。在Javascript中也有这样的一个老牌框架JsUnit，他的作者是Edward Hieatt来自<a href=\"http://pivotallabs.com/\">Pivotal Labs</a>，但在几年前JsUnit就已经停止维护了，他们带来了新的BDD框架Jasmine。</p>\n<p>Jasmine不依赖于任何框架，所以适用于所有的Javascript代码。使用一个全局函数 <code>describe</code> 来描述每个测试，并且可以嵌套。describe函数有2个参数，一个是字符串用于描述，一个是函数用于测试。在该函数中可以使用全局函数 <code>it</code> 来定义Specs，也就是单元测试的主要内容， 使用 <code>expect</code> 函数来测试：</p>\n<pre><code>describe(&#39;A suite&#39;, function () &#123;\n    it(&#39;is a spec&#39;, function () &#123;\n        var a = true;\n        expect(a).toBe(true);\n    &#125;);\n&#125;);\n</code></pre>\n<p>另外如果想去掉某个describe，无须注释掉整段代码，只需要在describe前面加上x即可忽略该describe。</p>\n<h5 id=\"Matcher\"><a href=\"#Matcher\" class=\"headerlink\" title=\"Matcher\"></a>Matcher</h5><p>toBe方法是一个基本的 <code>matcher</code> 用来定义判断规则，可以看得出来Jasmine的方法是非常语义化的，“expect ‘a’ to be true”，如果想判断否定条件，则只需要在toBe前调用 <code>not</code> 方法：</p>\n<pre><code>expect(a).not().toBe(false);\n</code></pre>\n<p>除了toBe这样基本的还有许多其他的<a href=\"https://github.com/pivotal/jasmine/wiki/Matchers\">Matcher</a>，比如 <code>toEqual</code> 。很多初学Jasmine会弄不清和toBe的区别，一个简单的例子就能明白它们的区别：</p>\n<pre><code>expect(&#123;&#125;).not().toBe(&#123;&#125;);\nexpect(&#123;&#125;).toEqual(&#123;&#125;);\n</code></pre>\n<p>一个新建的Object不是（not to be）另一个新建的Object，但是它们是相等（to equal）的。还有 <code>toMatch</code> 可以使用字符串或者正则表达式来验证，以及其他一些特殊验证，比如undefined或者boolean的判断， <code>toThrow</code> 可以检查函数所抛出的异常。另外Jasmine还支持自定义Matcher，以NaN的检查为例，像这样使用beforeEach方法在每个测试执行前添加一个matcher：</p>\n<pre><code>beforeEach(function () &#123;\n    this.addMatchers(&#123;\n        toBeNaN: function (expected) &#123;\n            return isNaN(expected);\n        &#125;\n    &#125;);\n&#125;);\n</code></pre>\n<p>可以想到，其参数expected是传入的一个期望的字面量，而在expect方法中传入的参数，可以通过 <code>this.acturl</code> 获取，是否调用了 <code>not</code> 方法则可以通过 <code>this.isNot</code> 获取，这是一个boolean值。最后测试输出的失败信息应该使用 <code>this.message</code> 来定义，不过它是一个function，然后在其中返回一个信息。所以继续增进toBeNaN：</p>\n<pre><code>beforeEach(function () &#123;\n    this.addMatchers(&#123;\n        toBeNaN: function (expected) &#123;\n            var actual = this.actual;\n            var not = this.isNot ? &#39; not&#39; : &#39;&#39;;\n            this.message = function () &#123;\n                return &#39;Expected &#39; + actual + not + &#39; to be NaN &#39; + expected;\n            &#125;;\n            return isNaN(expected);\n        &#125;\n    &#125;);\n&#125;);\n</code></pre>\n<p>这样一个完整的matcher就创建成了。</p>\n<p>另外需要说明的是对应beforeEach是在每个spec之前执行， <code>afterEach</code> 方法则是在每个spec之后执行。这是一种AOP，即面向方面的编程（Aspect Oriented Programming）。比如有时候为了测试一个对象，可能需要多次创建和销毁它，所以为了避免冗余代码，使用它们是最佳选择。</p>\n<p>还可以使用 <code>jasmine.any</code> 方法来代表一类数据传入matcher中，比如</p>\n<pre><code>expect(123).toEqual(jasmine.any(Number));\nexpect(function () &#123;&#125;).toEqual(jasmine.any(Function));\n</code></pre>\n<h5 id=\"Spy方法\"><a href=\"#Spy方法\" class=\"headerlink\" title=\"Spy方法\"></a>Spy方法</h5><p>一个Spy能监测任何function的调用和获取其参数。这里有2个特殊的Matcher， <code>toHaveBeenCalled</code> 可以检查function是否被调用过，还有 <code>toHaveBeenCalledWith</code> 可以传入参数检查是否和这些参数一起被调用过，像这样使用 <code>spyOn</code> 来注册一个对象中的方法：</p>\n<pre><code>var foo, a = null;\nbeforeEach(function () &#123;\n    var foo = &#123;\n        set: function (str) &#123;\n            a = str;\n        &#125;\n    &#125;\n    spyOn(foo, &#39;set&#39;);\n    foo.set(123);\n&#125;);\nit(&#39;tracks calls&#39;, function () &#123;\n    expect(foo.set).toHaveBeenCalled();\n    expect(foo.set).toHaveBeenCalled(123);\n    expect(foo.set.calls[0].args[0]).toEqual(123);\n    expect(foo.set.mostRecentCall.args[0]).toEqual(123);\n    expect(a).toBeNull();\n&#125;);\n</code></pre>\n<p>在测试时该function将带有一个被调用的数组 <code>calls</code> ，而 <code>args</code> 数组就是调用时传入的参数，另外特殊属性 <code>mostRencentCall</code> 则代表最后一次调用，和calls[calls.length]一致。需要特别注意的是，这些调用将不会对变量产生作用，所以 <code>a</code> 仍为null。</p>\n<p>如果需要调用产生实际的作用，可以在spyOn方法后调用 <code>andCallThrough</code> 方法。还可以通过调用 <code>andReturn</code> 方法设定一个返回值给function。 <code>andCallFake</code> 则可以传入一个function作为参数去代替原本的function。</p>\n<pre><code>spyOn(foo, &#39;set&#39;).andCallThrough();\n</code></pre>\n<p>甚至在没有function的时候可以使用Jasmine的 <code>createSpy</code> 和 <code>createSpyObj</code> 创建一个spy：</p>\n<pre><code>foo = jasmine.createSpy(&#39;foo&#39;);\nobj = jasmine.createSpyObj(&#39;obj&#39;, [set, do]);\n\nfoo(123);\nobj.set(123);\nobj.do();\n</code></pre>\n<p>其效果相当于spyOn使用在了已存在的function上。</p>\n<h5 id=\"时间控制\"><a href=\"#时间控制\" class=\"headerlink\" title=\"时间控制\"></a>时间控制</h5><p>上面的方法都在程序顺序执行的前提下执行，但 <code>setTimeout</code> 以及 <code>setInterval</code> 两个方法会使代码分离在时间轴上。所以Jasmine提供了 <code>Clock</code> 方法来模拟时间，以获取setTimeout的不同状态。</p>\n<pre><code>beforeEach(function () &#123;\n    jasmine.Clock.useMock();\n&#125;);\nit(&#39;set time&#39;, function () &#123;\n    var str = 0;\n    setTimeout(function () &#123;\n        str++;\n    &#125;, 100);\n    expect(str).toEqual(0);\n    jasmine.Click.tick(101);\n    expect(str).toEqual(1);\n    jasmine.Click.tick(200);\n    expect(str).toEqual(3);\n&#125;);\n</code></pre>\n<p>使用Clock的方法 <code>useMock</code> 来开始时间控制，然后在it中使用 <code>tick</code> 方法来推进时间。</p>\n<h5 id=\"异步\"><a href=\"#异步\" class=\"headerlink\" title=\"异步\"></a>异步</h5><p>Javascript最大的特色之一就是异步，之前介绍的方法如果存在异步调用，大部分测试时可能会不通过。因此，需要等异步回调之后再进行测试。</p>\n<p>Jasmine提供了 <code>runs</code> 和 <code>waitsFor</code> 两个方法来完成这个异步的等待。需要将waitsFor方法夹在多个runs方法中，runs方法中的语句会按顺序直接执行，然后进入waitsFor方法，如果waitsFor返回false，则继续执行waitsFor，直到返回true才执行后面的runs方法。</p>\n<pre><code>var cb = false;\nvar ajax = &#123;\n    success: function () &#123;\n        cb = true;\n    &#125;\n&#125;;\nspyOn(ajax, &#39;success&#39;);\nit(&#39;async callback&#39;, function () &#123;\n    runs(function () &#123;\n        _toAjax(ajax);\n    &#125;);\n    waitsFor(function () &#123;\n        return ajax.success.callCount &gt; 0;\n    &#125;);\n    runs(function () &#123;\n        expect(cb).toBeTruthy();\n    &#125;);\n&#125;);\n</code></pre>\n<p>如此，只要在waitsFor中判断回调函数是否被调用了即可完成异步测试。上面代码中我使用一个方法名直接代替了ajax请求方法来缩减不必要的代码。在第一个runs方法中发出了一个ajax请求，然后在waitsFor中等待其被调用，当第二个runs执行时说明回调函数已经被调用了，进行测试。</p>\n<h4 id=\"Qunit\"><a href=\"#Qunit\" class=\"headerlink\" title=\"Qunit\"></a><a href=\"http://qunitjs.com/\">Qunit</a></h4><p>它是由jQuery团队开发的一款测试套件，最初依赖于jQuery库，在2009年时脱离jQuery的依赖，变成了一个真正的测试框架，适用于所有Javascript代码。</p>\n<p>Qunit采用断言（Assert）来进行测试，相比于Jasmine的matcher更加多的类型，Qunit更集中在测试的度上。 <code>deepEqual</code> 用于比较一些纵向数据，比如Object或者Function等。而最常用的 <code>ok</code> 则直接判断是否为true。异步方面Qunit也很有趣，通过 <code>stop</code> 来停止测试等待异步返回，然后使用 <code>start</code> 继续测试，这要比Jasmine的过程化的等待更自由一些，不过有时也许会更难写一些。Qunit还拥有3组AOP的方法( <code>done</code> 和 ‘begin’ )来对应于整个测试，测试和模块。</p>\n<p>对于Function的跟踪测试，Qunit似乎完全没有考虑。不过可以使用另外一个测试框架为Qunit带来的插件 <a href=\"http://sinonjs.org/qunit/\">sinon-qunit</a>。这样就可以在test中使用 <code>spy</code> 方法了。</p>\n<h4 id=\"Sinon\"><a href=\"#Sinon\" class=\"headerlink\" title=\"Sinon\"></a><a href=\"http://sinonjs.org/\">Sinon</a></h4><p>Sinon并不是一个典型的单元测试框架，更像一个库，最主要的是对Function的测试，包括 <code>Spy</code> 和 <code>Stub</code> 两个部分，Spy用于侦测Function，而Stub更像是一个Spy的插件或者助手，在Function调用前后做一些特殊的处理，比如修改配置或者回调。它正好极大的弥补了Qunit的不足，所以通常会使用Qunit+Sinon来进行单元测试。</p>\n<p>值得一提的是，Sinon的作者<a href=\"http://tddjs.com/\">Christian Johansen</a>就是 <em>Test-Driven JavaScript Development</em> 一书的作者，这本书针对Javascript很详细的描述了单元测试的每个环节。</p>\n<h4 id=\"Mocha\"><a href=\"#Mocha\" class=\"headerlink\" title=\"Mocha\"></a><a href=\"http://visionmedia.github.io/mocha\">Mocha</a></h4><p>它的作者就是在Github上粉丝6K的超级Jser <a href=\"https://github.com/visionmedia\">TJ Holowaychuk</a>，可以在他的页面上看到过去一年的提交量是5700多，拥有300多个项目，无论是谁都难以想象他是如何进行coding的。</p>\n<p>理所当然的，Mocha充满了Geek感，不但可以在bash中进行测试，而且还拥有一整套命令对测试进行操作。甚至使用 <code>diff</code> 可以查看当前测试与上一次成功测试的代码不一致。</p>\n<p>不仅仅是这样，Mocha非常得自由。Mocha将更多的方法集中在了describe和it中，比如异步的测试就非常棒，在it的回调函数中会获取一个参数 <code>done</code> ，类型是function，用于异步回调，当执行这个函数时就会继续测试。还可以使用 <code>only</code> 和 <code>skip</code> 去选择测试时需要的部分。Mocha的接口也一样自由，除了 <code>BDD</code> 风格和Jasmine类似的接口，还有 <code>TDD</code> 风格的 （suite test setup teardown suiteSetup suiteTeardown），还有AMD风格的 <code>exports</code>，Qunit风格等。同时测试报告也可以任意组织，无论是列表、进度条、还是飞机跑道这样奇特的样式都可以在bash中显示。</p>\n<h3 id=\"前端测试工具\"><a href=\"#前端测试工具\" class=\"headerlink\" title=\"前端测试工具\"></a>前端测试工具</h3><h4 id=\"Client-Server-测试\"><a href=\"#Client-Server-测试\" class=\"headerlink\" title=\"Client/Server 测试\"></a>Client/Server 测试</h4><p>相比于服务端开发，前端开发在测试方面始终面临着一个严峻的问题，那就是浏览器兼容性。<a href=\"http://www.paulirish.com/\">Paul Irish</a>曾发表文章<a href=\"http://www.paulirish.com/2011/browser-market-pollution-iex-is-the-new-ie6/\">Browser Market Pollution: IE[x] Is the New IE6</a>阐述了一个奇怪的设想，未来你可能需要在76个浏览器上开发，因为每次IE的新版本都是一个特别的浏览器，而且还有它对之前所有版本的兼容模式也是一样。虽然没人认为微软会继续如此愚蠢，不过这也说明了一个问题，前端开发中浏览器兼容性是一个永远的问题，而且我认为即使解决了浏览器的兼容性问题，未来在移动开发方面，设备兼容性也是一个问题。</p>\n<p>所以在自动化测试方面也是如此，即使所有的单元测试集中在了一个runner中，前端测试仍然要面对至少4个浏览器内核以及3个电脑操作系统加2个或更多移动操作系统，何况还有令移动开发人员头疼的Android的碎片化问题。不过可以安心的是，早已存在这样的工具可以捕获不同设备上的不同浏览器，并使之随时更新测试结果，甚至可以在一个终端上看到所有结果。</p>\n<h5 id=\"工具介绍\"><a href=\"#工具介绍\" class=\"headerlink\" title=\"工具介绍\"></a>工具介绍</h5><p><a href=\"https://code.google.com/p/js-test-driver/\">JSTD（Javascript Test Driver）</a>是一个最早的C/S测试工具，来自Google，基于JAVA编写，跨平台，使用命令行控制，还有很好的编辑器支持，最常用于eclipse。不过它无法显示测试对象的设备及浏览器版本，只有浏览器名是不够的。另外JSTD已经慢慢不再活跃，它的早正如它的老。</p>\n<p>Google的新贵<a href=\"http://karma-runner.github.io/\">Karma</a>出现了，它使用Nodejs构建，因此跨平台，还支持PhantomJS浏览器，还支持多种框架，包括以上介绍的Jasmine、Qunit和Mocha。一次可以在多个浏览器及设备中进行测试，并控制浏览器行为和测试报告。虽然它不支持Nodejs的测试，不过没什么影响，因为Nodejs并不依赖于浏览器。</p>\n<p>还有<a href=\"http://swarm.jquery.org/\">TestSwarm</a>，出自jQuery之父John Resig之手，看来jQuery的强大果然不是偶然的，在测试方面非常到位，各种工具齐全。它最特别的地方在于所有测试环境由服务器提供，包括各种版本的主流浏览器以及iOS5的iphone设备，不过目前加入已经受限。</p>\n<p>最受瞩目的当属<a href=\"http://www.busterjs.org/\">Buster</a>，其作者之一就是<a href=\"http://tddjs.com/\">Christian Johansen</a>。和Karma很像，也使用Nodejs编写跨平台并且支持PhantomJS，一次测试所有客户端。更重要的是支持Nodejs的测试，同样支持各种主流测试框架。不过目前还在Beta测试中，很多bug而且不能很好的兼容Windows系统。它的目标还包括整合<a href=\"http://www.browserstack.com/\">Browser Stack</a>。</p>\n<h4 id=\"基于网页的测试\"><a href=\"#基于网页的测试\" class=\"headerlink\" title=\"基于网页的测试\"></a>基于网页的测试</h4><p>到目前为止我们的测试看起来十分的完美了，但是别忘了，在前端开发中存在交互问题，不能期待QA玩了命的点击某个按钮或者刷新一个页面并输入一句乱码之类的东西来测试代码。即使是开发者本身也会受不了，如果产品本身拥有一堆复杂的表单和逻辑的话。</p>\n<p><a href=\"http://www.seleniumhq.org/\">Selenium</a>是一个测试工具集，由Thoughtworks开发，分为两部分。Selenium IDE是一个Firefox浏览器的插件，可以录制用户行为，并快速测试。</p>\n<p>而Selenium WebDriver是一个多语言的驱动浏览器的工具，支持Python、Java、Ruby、Perl、PHP或.Net。并且可以操作IE、Firefox、Safari和Chrome等主流浏览器。通过 <code>open</code> , <code>type</code> , <code>click</code> , <code>waitForxxx</code> 等指令来模拟用户行为，比如用Java测试：</p>\n<pre><code>public void testNew() throws Exception &#123;\n    selenium.open(&quot;/&quot;);\n    selenium.type(&quot;q&quot;, &quot;selenium rc&quot;);\n    selenium.click(&quot;btnG&quot;);\n    selenium.waitForPageToLoad(&quot;30000&quot;);\n    assertTrue(selenium.isTextPresent(&quot;Results * for selenium rc&quot;));\n&#125;\n</code></pre>\n<p>首先跳转到跟目录，然后选择类型，点击按钮G，并等待页面载入30秒，然后使用断言测试。这样就完成了一次用户基本行为的模拟，不过复杂的模拟以及在一些非链接的操作还需要格外注意，比如Ajax请求或者Pjax的无刷新等等。</p>\n<p>另外还有一款可以模拟用户行为的网页测试工具<a href=\"http://watir.com/\">WATIR</a>，是Web Application Testing in Ruby的缩写，显然它只支持Ruby语言来操作浏览器模拟用户行为。官方声称它是一个简单而灵活的工具，无论怎样至少就官方网站的设计来看要比Selenium简约多了。同样支持模拟链接点击，按钮点击，还有表单的填写等行为。不过WATIR不支持Ajax的测试。和其他Ruby库一样需要gem来安装它：</p>\n<pre><code>gem install watir --no-rdoc --no-ri\n</code></pre>\n<p>然后使用它</p>\n<pre><code>require &#39;rubygems&#39;\nrequire &#39;watir&#39;\nrequire &#39;watir-webdriver&#39;\nbrowser = Watir::Browser.new\nbrowser.goto &#39;http://www.example.com/form&#39;\nbrowser.test_field(:name =&gt; &#39;entry.0.single&#39;).set &#39;Watir&#39;\nbrowser.radio(:value =&gt; &#39;Watir&#39;).set\nbrowser.radio(:value =&gt; &#39;Watir&#39;).clear\nbrowser.checkbox(:value =&gt; &#39;Ruby&#39;).set\nbrowser.checkbox(:value =&gt; &#39;Javascript&#39;).clear\nbrowser.button(:name =&gt; &#39;submit&#39;).click\n</code></pre>\n<p>这样就使用watir完成了一次表单填写。</p>\n<h4 id=\"持续集成测试\"><a href=\"#持续集成测试\" class=\"headerlink\" title=\"持续集成测试\"></a>持续集成测试</h4><p>持续集成就是通常所谓的CI(Continuous integration)，持续不断的自动化测试新加入代码后的项目。它并不属于单元测试，而是另外的范畴，不过通过使用CI服务可以很容易的在Github上测试项目，而这也就是持续集成的意义。</p>\n<p>下面以我的jQ小插件<a href=\"https://github.com/tychio/dialog#unit\">Dialog</a>为例介绍一下Travis-CI的使用方法，注册<a href=\"https://travis-ci.org/\">Travis</a>，然后链接自己的Github，选择要进行持续集成的项目。此时会显示build failing，那是因为还没有在项目中进行相关配置。</p>\n<p>首先需要使用Grunt等工具配置好测试框架的自动化测试，细节可以参考我之前的文章<a href=\"http://www.tychio.net/tech/2013/09/25/improve-workflow.html\">改进我的Workflow</a>。然后在 <code>package.json</code> 中添加一下代码来指定执行的脚本：</p>\n<pre><code>&quot;scripts&quot;: &#123;\n    &quot;test&quot;: &quot;grunt jasmine:test&quot;\n&#125;\n</code></pre>\n<p>接着添加一个文件 <code>.travis.yml</code> 来配置travis：</p>\n<pre><code>language: node_js\nnode_js: \n  - &quot;0.8&quot;\nbefore_script:\n  - npm install -g grunt-cli\n</code></pre>\n<p><code>language</code> 是集成测试所使用的语言，这里前端开发当然是使用Nodejs，在 <code>node_js</code> 中指定版本即可。当然Travis还支持其他多种语言，以及后端数据库等。</p>\n<p><code>before_script</code> 则是在测试前执行的脚本程序，这里在全局安装Grunt-cli即可，因为默认的Travis会执行 <code>npm install</code> 将package.json中指定的Node包安装到项目。</p>\n<p>最后在Github中还需要在项目的Setting中的Service Hooks中配置Travis，输入Token并保存。或者直接在Travis中点击该项目条目中的扳手图标进入Github，会自动配置好。</p>\n<p>另外，如果在Github上为README文件添加一行</p>\n<pre><code>[![Build Status](https://travis-ci.org/tychio/dialog.png?branch=master)](https://travis-ci.org/tychio/dialog)\n</code></pre>\n<p>就可以持续直观的显示其测试结果。</p>\n<h3 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h3><ul>\n<li><p><a href=\"http://esj.com/articles/2012/09/24/better-unit-testing.aspx\">Better unit testing</a></p>\n</li>\n<li><p><a href=\"http://stackoverflow.com/questions/300855/javascript-unit-test-tools-for-tdd\">Javascript Unit Test tools Q/A</a></p>\n</li>\n<li><p><a href=\"http://www.ibm.com/developerworks/web/library/wa-tools/\">Tools to unit test your JavaScript</a></p>\n</li>\n<li><p><a href=\"http://guide.agilealliance.org/guide/tdd.html\">Agile Aliiance Guide Test Driven Development</a></p>\n</li>\n<li><p><a href=\"http://guide.agilealliance.org/guide/bdd.html\">Agile Aliiance Guide Behaviour Driven Development</a></p>\n</li>\n<li><p><a href=\"http://www.infoq.com/news/2011/02/BDD-ATDD\">BDD: ATDD done well?</a></p>\n</li>\n<li><p><a href=\"http://en.wikipedia.org/wiki/Unit_test\">Unit test wiki</a></p>\n</li>\n<li><p><a href=\"http://en.wikipedia.org/wiki/Behavior-driven_development\">BDD Wiki</a></p>\n</li>\n<li><p><a href=\"http://en.wikipedia.org/wiki/Aspect-oriented_programming\">Aspect-oriented Programming wiki</a></p>\n</li>\n<li><p><a href=\"https://www.guru99.com/selenium-tutorial.html\">Selenium Tutorial Guru99</a></p>\n</li>\n</ul>"},{"layout":"post","title":"HTML5实现图片上传","_content":"\n最近公司项目准备更换图片上传的插件，原来的是一个Flash控件，其实用起来还是不错的，还有进度条，浏览器支持情况也不错。不过因为某些页面的图片上传涉及到了跨域的问题，Flash似乎解决不了了，所以准备索性换成HTML5的，高端大气上档赤。然后这个HTML5上传图片功能自然落到了我的手上了。\n\n一般来说图片上传无非就是文件操作的问题，本来这是服务器对文件流的一个操作问题，前端应该是管不上的，不过HTML5再次赋予了我们前端神圣而伟大的权利，有了HTML5部分后端失业了lol。\n\n其实以前写过一个上传图片的插件，不过那时还活在IE6年代，只能用iframe搞定，虽然还挺好使的，不过在HTML5面前就是一个战斗力负5的渣渣，不仅需要后端返回各项数据，还必须把保存的临时图片地址再发给后端保存，实际请求是2次，而且还无法告诉用户上传进度与速度。\n<!-- more -->\n### 如何使用 FileReader ? ###\n\n首先FileReader是一个用于读取文件的类，我们可以用new关键字实例化一个文件读取器，像这样：\n    \n    var fr = new FileReader();\n\n但是还有一个问题，这是一个HTML5的API，只有部分浏览器支持它，所以还得加上判断，另外它的支持情况是这样的：\n\n    var fr = false;\n    if (typeof window.FileReader === 'undefined') {\n        fr = new FileReader();\n    }\n\n---\n<table style=\"text-align: center;\">\n    <tr>\n        <th width=\"20%\">IE</th>\n        <th width=\"20%\">Chrome</th>\n        <th width=\"20%\">Firefox</th>\n        <th width=\"20%\">Opera</th>\n        <th width=\"20%\">Safari</th>\n    </tr>\n    <tr>\n        <td>10</td>\n        <td>7</td>\n        <td>3.6</td>\n        <td>12.02</td>\n        <td>6.02</td>\n    </tr>\n</table>\n---\n\n\n使用FileReader很简单，它提供了四个简单的接口用来读取文件，分别是abort，readAsBinaryString，readAsDataURL，readAsText。\n\n##### readAsXXX #####\n\n接口名清楚明白的说明了它的作用，以readAs开头的三个接口自然是用来读取文件的。很显然，所谓的文件，在不同的环境中有不同的格式不同的解释方式，这也正是这三个接口的不同之处。\n\n但在我们弄清楚读取文件获得了什么之前，也许我们更应该关心目标文件是什么，怎么获取。幸运地是DOM中老早就存在一个files方法可以获取我们要的文件，并且它还提供了一些方法和属性。主要的属性有name，size，type，显然这是文件名、文件尺寸和文件类型，虽然它也提供了3个读取文件的方法getAsXXX，但是由于FileReader的存在已经被废弃很久了，同样被废弃的还有fileName和fileSize。\n\n另外不得不说，Chrome在文件操作方面做的最出色，早在chrome13就已经实现了文件的写入，而其他浏览器至今还没有实现。\n\n然后说说读取文件吧，这个过程是需要时间的，所以必须异步读取它，还好我们有load方法，像这样：\n\n    var fr = false;\n    if (typeof window.FileReader === 'undefined') {\n        fr = new FileReader();\n        fr.readAsXXX(document.getElementById('input_file').files[0]);\n        fr.onload = function (p_fr) {\n            console.log(p_fr.target.result);\n        };\n    }\n\n###### readAsBinaryString ######\n\nreadAsBinaryString的result应该是一个二进制流，而log出的结果是一个夹杂着乱码符号的文本，里面还能看到图片是用PS保存的之类的信息。\n\n###### readAsDataURL ######\n\nreadAsDataURL的result则是一个Base64的图片代码，可以直接放入HTML的img标签的属性src上。\n\n###### readAsText ######\n\nreadAsText的result和二进制的显示出来基本是一样的，包括一个信息头，接着大段的乱码应该是图片本身。\n\n该方法还有一个可选的参数[encoding]，即文本的编码方式，默认为urf-8。\n\n##### Abort #####\n\nabort是一个特别的方法，用来打断读取。当图片上传超时或者其他操作需要打断时就可以调用这个接口打断。另外还可以监听abort事件来处理打断后的情况。\n\n### 使用FormData组织表单数据 ###\n\n解决了预览的问题，现在该解决上传的正事了，如果使用HTML5的上传方式那么就必须使用Ajax请求来与服务器通信，但表单中的文件应该如何以参数的方式通过ajax请求传送呢？\n\n在DOM API中，Form提供了一个方法FormData，它可以将表单元素的DOM对象直接转换为参数，通过Ajax请求传送。用起来很简单，使用new关键字将DOM对象传入参数即可：\n\n    var _fd = new FormData(document.getElementsByTagName('form')[0]);\n\n然后只需要在Ajax请求中送出即可：\n\n    xhr.send(_fd);\n\n##### append #####\n\n当然我们也可以加入不在表单中的额外参数，使用append方法即可：\n    \n    var xhr = new XMLHttpRequest();  \n    var formData = new FormData(document.getElementsByTagName('form')[0]);\n    formData.append('param1', 'a parameter');\n    xhr.open('POST', 'uploader.php');\n    xhr.send(formData);\n\nappend方法一般可以传入一对键值组合的参数用来添加到表单数据之中，但它还提供了另外一种用法，传入参数名以及一个Blob或者File，另外还有第三个可选的参数，是该参数的文件名。\n\n至于Blob，是一个类似于文件的Object，我的理解是它在某些环境中可以解析为文件，但是在浏览器中是无法识别的。\n\n##### 支持情况 #####\n\n作为一个HTML5的方法自然也是有浏览器支持的问题的，如下表：\n\n---\n<table style=\"text-align: center;\">\n    <tr>\n        <th width=\"20%\">IE</th>\n        <th width=\"20%\">Chrome</th>\n        <th width=\"20%\">Firefox</th>\n        <th width=\"20%\">Opera</th>\n        <th width=\"20%\">Safari</th>\n    </tr>\n    <tr>\n        <td>10</td>\n        <td>7+</td>\n        <td>4.0</td>\n        <td>12+</td>\n        <td>5+</td>\n    </tr>\n</table>\n---\n\n不过append方法的支持情况就有点不尽人意了，只有Chrome完全支持，Firefox在22以后才支持，其他浏览器均不支持。\n\n### 上传文件 ###\n\n一般来说提交form数据到服务器，上传文件即可交由后端完成。但HTML5需要获取上传进度，就会比较特殊，所以还需要为Ajax请求绑定一些事件来处理不同的情况。\n\n##### Event #####\n\n一般来说，只需要使用XMLHttpRequest的addEventListener方法来绑定事件，像这样\n\n    xhr.addEventListener('load', function (p_event) {\n        // your code...\n    }, false);\n\n除了load事件以外，还有一下一些事件，可以满足上传过程中遇到的各种问题。\n\n1.abort 上传中断时触发。\n2.error 上传出错时触发。\n3.load 文件成功读取完成时触发。\n4.loadend 文件读取结束时无论是否成功触发。\n5.loadstart 文件读取开始时触发。\n6.progress 文件读取过程中每秒触发一次。\n\n###### progress ######\n\nprogress方法比较特殊，会在上传过程中一直触发，并获取当前上传的量 `loaded` 和总量等数据 `total` 。\n主要需要用到的有2个数据，loaded已上传的部分和total总量，单位都是b，利用它们算出上传进度就可以显示百分比或设置进度条的宽度，甚至记录进度改变时花费的时间就能算出上传速度。\n\n另外progress的监听比较特殊，像这样：\n\n    xhr.upload.addEventListener('progress', function (p_event) {\n        var _loaded = p_event.loaded;\n        var _total = p_event.total;\n        var _percent = Math.round(_loaded * 100 / _total);\n        // using percent...\n    }, false);\n\n需要使用xhr.upload的addEventListener方法来监听事件，而不是直接使用xhr。\n\n### INPUT标签 ###\n\n最后，是一个文件上传的老问题，无论是HTML5还是4，file类型的input标签样式总是无法统一，也无法美化。所以我们只能以暴制暴，不能化妆那就整容，用其他元素把它彻底覆盖掉。众所周知的做法是把input隐藏，然后问题来了，如何触发上传。\n\n###### trigger ######\n\n一般首先想到的是模拟触发，比如jQuery中的trigger方法，可以让我们点击甚至其他动作时触发input标签。但是IE由于安全性问题不允许模拟触发file类型的input标签事件，所以如果不支持IE的项目可以使用这个方法轻松搞定。\n\n###### 透明化按钮 ######\n\n既然不能模拟，真实用户的点击行为自然是没问题了吧，于是另一个方法诞生了，将input标签变成透明的，覆盖在一个按钮样式的标签上，如此用户看到的是一个美化的按钮，点击的却是Input标签。但是有一个问题，file类型的Input标签在各浏览器中的尺寸和位置都是不太一致的，尤其是改变其尺寸后，有的浏览器甚至无法改变。所以如何按钮较大或者直接是一个区域时则会出现问题。\n\n###### 鼠标跟随 ######\n\n方法继续进化，虽然点击区域的尺寸可能会很大，但鼠标的点击永远只是一个点，于是只要让Input标签一直跟随鼠标在区域内移动，将可点击部分随时对准鼠标指针，就可以让鼠标在区域内点击到Input标签了。这个方法解决了所有问题，但它的效率很成问题，甚至不能过分使用函数节流，因为移动过快时可能点击不到。\n\n###### Label触发 ######\n\n后来在StackOverflow上看到了一个很不错的方法，就是利用Labal标签的for属性去触发input标签，只要将for的值写成Input的Id即可。但在我的测试中Firefox好像是不能触发的，不知道是否还有其他的属性需要设置。\n\n这四种方法各有各的优劣，只能根据具体情况选择使用了。\n\n##### 多文件上传 Multiple #####\n\n在Input标签上也出现了一个很实用的HTML5的新功能，那就是多文件上传，实现也非常简单，只要加上multiple的属性即可\n\n    <input type=\"file\" name=\"files[]\" multiple=\"multiple\" />\n\n如此在上传的时候就可以选择多个文件，另外在后端接受数据时，每个属性都变成了一个数组，以PHP为例：\n\n    <?php\n        header('Content-type: text/json');\n        print_r($_FILES[\"upload\"][\"name\"]);\n        $rtn = array(\n            \"code\" => 0,\n            \"data\" => ''\n        );\n        if ($_FILES[\"upload\"][\"error\"] > 0) {\n            $rtn[\"code\"] = -1;\n        } else {\n            $rtn[\"data\"] = array(\n                \"name\" => $_FILES[\"upload\"][\"name\"],\n                \"type\" => $_FILES[\"upload\"][\"type\"],\n                \"size\" => $_FILES[\"upload\"][\"size\"],\n                \"path\" => \"\"\n            );\n            if (file_exists(\"img/\".$rtn[\"data\"][\"name\"])) {\n                $rtn[\"code\"] = 1;\n            } else {\n                move_uploaded_file($_FILES[\"upload\"][\"tmp_name\"],\n                    \"img/\".$_FILES[\"upload\"][\"name\"]);\n                $rtn[\"code\"] = 0;\n                $rtn[\"data\"][\"path\"] = \"img/\".$rtn[\"data\"][\"name\"];\n            }\n        }\n        echo json_encode($rtn);\n    ?>\n\n\n### 参考文档： ###\n\n* [W3C FileReader Interface](http://www.w3.org/TR/FileAPI/)\n* [MDN FileReader](https://developer.mozilla.org/en-US/docs/Web/API/FileReader?redirectlocale=en-US&redirectslug=DOM%2FFileReader)\n* [MDN DOM Files](https://developer.mozilla.org/en-US/docs/Web/API/File)\n* [Using FormData to send forms with xhr as key/value pairs](http://robertnyman.com/2013/02/11/using-formdata-to-send-forms-with-xhr-as-keyvalue-pairs/)\n* [MDN FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData)\n* [Whatwg Interface FormData](http://xhr.spec.whatwg.org/#interface-formdata)\n* [W3C Forms multiple](http://www.w3.org/html/wg/drafts/html/master/forms.html#multipart-form-data)\n* [File upload and Progress events with HTML5](http://www.sagarganatra.com/2011/04/file-upload-and-progress-events-with.html)","source":"_posts/2013-08-21-html5-upload-file.md","raw":"---\nlayout: post\ntitle: HTML5实现图片上传\ntags: [html5,html,file,upload]\ncategory: Tech\n---\n\n最近公司项目准备更换图片上传的插件，原来的是一个Flash控件，其实用起来还是不错的，还有进度条，浏览器支持情况也不错。不过因为某些页面的图片上传涉及到了跨域的问题，Flash似乎解决不了了，所以准备索性换成HTML5的，高端大气上档赤。然后这个HTML5上传图片功能自然落到了我的手上了。\n\n一般来说图片上传无非就是文件操作的问题，本来这是服务器对文件流的一个操作问题，前端应该是管不上的，不过HTML5再次赋予了我们前端神圣而伟大的权利，有了HTML5部分后端失业了lol。\n\n其实以前写过一个上传图片的插件，不过那时还活在IE6年代，只能用iframe搞定，虽然还挺好使的，不过在HTML5面前就是一个战斗力负5的渣渣，不仅需要后端返回各项数据，还必须把保存的临时图片地址再发给后端保存，实际请求是2次，而且还无法告诉用户上传进度与速度。\n<!-- more -->\n### 如何使用 FileReader ? ###\n\n首先FileReader是一个用于读取文件的类，我们可以用new关键字实例化一个文件读取器，像这样：\n    \n    var fr = new FileReader();\n\n但是还有一个问题，这是一个HTML5的API，只有部分浏览器支持它，所以还得加上判断，另外它的支持情况是这样的：\n\n    var fr = false;\n    if (typeof window.FileReader === 'undefined') {\n        fr = new FileReader();\n    }\n\n---\n<table style=\"text-align: center;\">\n    <tr>\n        <th width=\"20%\">IE</th>\n        <th width=\"20%\">Chrome</th>\n        <th width=\"20%\">Firefox</th>\n        <th width=\"20%\">Opera</th>\n        <th width=\"20%\">Safari</th>\n    </tr>\n    <tr>\n        <td>10</td>\n        <td>7</td>\n        <td>3.6</td>\n        <td>12.02</td>\n        <td>6.02</td>\n    </tr>\n</table>\n---\n\n\n使用FileReader很简单，它提供了四个简单的接口用来读取文件，分别是abort，readAsBinaryString，readAsDataURL，readAsText。\n\n##### readAsXXX #####\n\n接口名清楚明白的说明了它的作用，以readAs开头的三个接口自然是用来读取文件的。很显然，所谓的文件，在不同的环境中有不同的格式不同的解释方式，这也正是这三个接口的不同之处。\n\n但在我们弄清楚读取文件获得了什么之前，也许我们更应该关心目标文件是什么，怎么获取。幸运地是DOM中老早就存在一个files方法可以获取我们要的文件，并且它还提供了一些方法和属性。主要的属性有name，size，type，显然这是文件名、文件尺寸和文件类型，虽然它也提供了3个读取文件的方法getAsXXX，但是由于FileReader的存在已经被废弃很久了，同样被废弃的还有fileName和fileSize。\n\n另外不得不说，Chrome在文件操作方面做的最出色，早在chrome13就已经实现了文件的写入，而其他浏览器至今还没有实现。\n\n然后说说读取文件吧，这个过程是需要时间的，所以必须异步读取它，还好我们有load方法，像这样：\n\n    var fr = false;\n    if (typeof window.FileReader === 'undefined') {\n        fr = new FileReader();\n        fr.readAsXXX(document.getElementById('input_file').files[0]);\n        fr.onload = function (p_fr) {\n            console.log(p_fr.target.result);\n        };\n    }\n\n###### readAsBinaryString ######\n\nreadAsBinaryString的result应该是一个二进制流，而log出的结果是一个夹杂着乱码符号的文本，里面还能看到图片是用PS保存的之类的信息。\n\n###### readAsDataURL ######\n\nreadAsDataURL的result则是一个Base64的图片代码，可以直接放入HTML的img标签的属性src上。\n\n###### readAsText ######\n\nreadAsText的result和二进制的显示出来基本是一样的，包括一个信息头，接着大段的乱码应该是图片本身。\n\n该方法还有一个可选的参数[encoding]，即文本的编码方式，默认为urf-8。\n\n##### Abort #####\n\nabort是一个特别的方法，用来打断读取。当图片上传超时或者其他操作需要打断时就可以调用这个接口打断。另外还可以监听abort事件来处理打断后的情况。\n\n### 使用FormData组织表单数据 ###\n\n解决了预览的问题，现在该解决上传的正事了，如果使用HTML5的上传方式那么就必须使用Ajax请求来与服务器通信，但表单中的文件应该如何以参数的方式通过ajax请求传送呢？\n\n在DOM API中，Form提供了一个方法FormData，它可以将表单元素的DOM对象直接转换为参数，通过Ajax请求传送。用起来很简单，使用new关键字将DOM对象传入参数即可：\n\n    var _fd = new FormData(document.getElementsByTagName('form')[0]);\n\n然后只需要在Ajax请求中送出即可：\n\n    xhr.send(_fd);\n\n##### append #####\n\n当然我们也可以加入不在表单中的额外参数，使用append方法即可：\n    \n    var xhr = new XMLHttpRequest();  \n    var formData = new FormData(document.getElementsByTagName('form')[0]);\n    formData.append('param1', 'a parameter');\n    xhr.open('POST', 'uploader.php');\n    xhr.send(formData);\n\nappend方法一般可以传入一对键值组合的参数用来添加到表单数据之中，但它还提供了另外一种用法，传入参数名以及一个Blob或者File，另外还有第三个可选的参数，是该参数的文件名。\n\n至于Blob，是一个类似于文件的Object，我的理解是它在某些环境中可以解析为文件，但是在浏览器中是无法识别的。\n\n##### 支持情况 #####\n\n作为一个HTML5的方法自然也是有浏览器支持的问题的，如下表：\n\n---\n<table style=\"text-align: center;\">\n    <tr>\n        <th width=\"20%\">IE</th>\n        <th width=\"20%\">Chrome</th>\n        <th width=\"20%\">Firefox</th>\n        <th width=\"20%\">Opera</th>\n        <th width=\"20%\">Safari</th>\n    </tr>\n    <tr>\n        <td>10</td>\n        <td>7+</td>\n        <td>4.0</td>\n        <td>12+</td>\n        <td>5+</td>\n    </tr>\n</table>\n---\n\n不过append方法的支持情况就有点不尽人意了，只有Chrome完全支持，Firefox在22以后才支持，其他浏览器均不支持。\n\n### 上传文件 ###\n\n一般来说提交form数据到服务器，上传文件即可交由后端完成。但HTML5需要获取上传进度，就会比较特殊，所以还需要为Ajax请求绑定一些事件来处理不同的情况。\n\n##### Event #####\n\n一般来说，只需要使用XMLHttpRequest的addEventListener方法来绑定事件，像这样\n\n    xhr.addEventListener('load', function (p_event) {\n        // your code...\n    }, false);\n\n除了load事件以外，还有一下一些事件，可以满足上传过程中遇到的各种问题。\n\n1.abort 上传中断时触发。\n2.error 上传出错时触发。\n3.load 文件成功读取完成时触发。\n4.loadend 文件读取结束时无论是否成功触发。\n5.loadstart 文件读取开始时触发。\n6.progress 文件读取过程中每秒触发一次。\n\n###### progress ######\n\nprogress方法比较特殊，会在上传过程中一直触发，并获取当前上传的量 `loaded` 和总量等数据 `total` 。\n主要需要用到的有2个数据，loaded已上传的部分和total总量，单位都是b，利用它们算出上传进度就可以显示百分比或设置进度条的宽度，甚至记录进度改变时花费的时间就能算出上传速度。\n\n另外progress的监听比较特殊，像这样：\n\n    xhr.upload.addEventListener('progress', function (p_event) {\n        var _loaded = p_event.loaded;\n        var _total = p_event.total;\n        var _percent = Math.round(_loaded * 100 / _total);\n        // using percent...\n    }, false);\n\n需要使用xhr.upload的addEventListener方法来监听事件，而不是直接使用xhr。\n\n### INPUT标签 ###\n\n最后，是一个文件上传的老问题，无论是HTML5还是4，file类型的input标签样式总是无法统一，也无法美化。所以我们只能以暴制暴，不能化妆那就整容，用其他元素把它彻底覆盖掉。众所周知的做法是把input隐藏，然后问题来了，如何触发上传。\n\n###### trigger ######\n\n一般首先想到的是模拟触发，比如jQuery中的trigger方法，可以让我们点击甚至其他动作时触发input标签。但是IE由于安全性问题不允许模拟触发file类型的input标签事件，所以如果不支持IE的项目可以使用这个方法轻松搞定。\n\n###### 透明化按钮 ######\n\n既然不能模拟，真实用户的点击行为自然是没问题了吧，于是另一个方法诞生了，将input标签变成透明的，覆盖在一个按钮样式的标签上，如此用户看到的是一个美化的按钮，点击的却是Input标签。但是有一个问题，file类型的Input标签在各浏览器中的尺寸和位置都是不太一致的，尤其是改变其尺寸后，有的浏览器甚至无法改变。所以如何按钮较大或者直接是一个区域时则会出现问题。\n\n###### 鼠标跟随 ######\n\n方法继续进化，虽然点击区域的尺寸可能会很大，但鼠标的点击永远只是一个点，于是只要让Input标签一直跟随鼠标在区域内移动，将可点击部分随时对准鼠标指针，就可以让鼠标在区域内点击到Input标签了。这个方法解决了所有问题，但它的效率很成问题，甚至不能过分使用函数节流，因为移动过快时可能点击不到。\n\n###### Label触发 ######\n\n后来在StackOverflow上看到了一个很不错的方法，就是利用Labal标签的for属性去触发input标签，只要将for的值写成Input的Id即可。但在我的测试中Firefox好像是不能触发的，不知道是否还有其他的属性需要设置。\n\n这四种方法各有各的优劣，只能根据具体情况选择使用了。\n\n##### 多文件上传 Multiple #####\n\n在Input标签上也出现了一个很实用的HTML5的新功能，那就是多文件上传，实现也非常简单，只要加上multiple的属性即可\n\n    <input type=\"file\" name=\"files[]\" multiple=\"multiple\" />\n\n如此在上传的时候就可以选择多个文件，另外在后端接受数据时，每个属性都变成了一个数组，以PHP为例：\n\n    <?php\n        header('Content-type: text/json');\n        print_r($_FILES[\"upload\"][\"name\"]);\n        $rtn = array(\n            \"code\" => 0,\n            \"data\" => ''\n        );\n        if ($_FILES[\"upload\"][\"error\"] > 0) {\n            $rtn[\"code\"] = -1;\n        } else {\n            $rtn[\"data\"] = array(\n                \"name\" => $_FILES[\"upload\"][\"name\"],\n                \"type\" => $_FILES[\"upload\"][\"type\"],\n                \"size\" => $_FILES[\"upload\"][\"size\"],\n                \"path\" => \"\"\n            );\n            if (file_exists(\"img/\".$rtn[\"data\"][\"name\"])) {\n                $rtn[\"code\"] = 1;\n            } else {\n                move_uploaded_file($_FILES[\"upload\"][\"tmp_name\"],\n                    \"img/\".$_FILES[\"upload\"][\"name\"]);\n                $rtn[\"code\"] = 0;\n                $rtn[\"data\"][\"path\"] = \"img/\".$rtn[\"data\"][\"name\"];\n            }\n        }\n        echo json_encode($rtn);\n    ?>\n\n\n### 参考文档： ###\n\n* [W3C FileReader Interface](http://www.w3.org/TR/FileAPI/)\n* [MDN FileReader](https://developer.mozilla.org/en-US/docs/Web/API/FileReader?redirectlocale=en-US&redirectslug=DOM%2FFileReader)\n* [MDN DOM Files](https://developer.mozilla.org/en-US/docs/Web/API/File)\n* [Using FormData to send forms with xhr as key/value pairs](http://robertnyman.com/2013/02/11/using-formdata-to-send-forms-with-xhr-as-keyvalue-pairs/)\n* [MDN FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData)\n* [Whatwg Interface FormData](http://xhr.spec.whatwg.org/#interface-formdata)\n* [W3C Forms multiple](http://www.w3.org/html/wg/drafts/html/master/forms.html#multipart-form-data)\n* [File upload and Progress events with HTML5](http://www.sagarganatra.com/2011/04/file-upload-and-progress-events-with.html)","slug":"html5-upload-file","published":1,"date":"2013-08-20T16:00:00.000Z","updated":"2021-11-28T11:37:27.160Z","comments":1,"photos":[],"link":"","_id":"ckwj65513000kvyjhc06b2b53","content":"<p>最近公司项目准备更换图片上传的插件，原来的是一个Flash控件，其实用起来还是不错的，还有进度条，浏览器支持情况也不错。不过因为某些页面的图片上传涉及到了跨域的问题，Flash似乎解决不了了，所以准备索性换成HTML5的，高端大气上档赤。然后这个HTML5上传图片功能自然落到了我的手上了。</p>\n<p>一般来说图片上传无非就是文件操作的问题，本来这是服务器对文件流的一个操作问题，前端应该是管不上的，不过HTML5再次赋予了我们前端神圣而伟大的权利，有了HTML5部分后端失业了lol。</p>\n<p>其实以前写过一个上传图片的插件，不过那时还活在IE6年代，只能用iframe搞定，虽然还挺好使的，不过在HTML5面前就是一个战斗力负5的渣渣，不仅需要后端返回各项数据，还必须把保存的临时图片地址再发给后端保存，实际请求是2次，而且还无法告诉用户上传进度与速度。</p>\n<span id=\"more\"></span>\n<h3 id=\"如何使用-FileReader\"><a href=\"#如何使用-FileReader\" class=\"headerlink\" title=\"如何使用 FileReader ?\"></a>如何使用 FileReader ?</h3><p>首先FileReader是一个用于读取文件的类，我们可以用new关键字实例化一个文件读取器，像这样：</p>\n<pre><code>var fr = new FileReader();\n</code></pre>\n<p>但是还有一个问题，这是一个HTML5的API，只有部分浏览器支持它，所以还得加上判断，另外它的支持情况是这样的：</p>\n<pre><code>var fr = false;\nif (typeof window.FileReader === &#39;undefined&#39;) &#123;\n    fr = new FileReader();\n&#125;\n</code></pre>\n<hr>\n<table style=\"text-align: center;\">\n    <tr>\n        <th width=\"20%\">IE</th>\n        <th width=\"20%\">Chrome</th>\n        <th width=\"20%\">Firefox</th>\n        <th width=\"20%\">Opera</th>\n        <th width=\"20%\">Safari</th>\n    </tr>\n    <tr>\n        <td>10</td>\n        <td>7</td>\n        <td>3.6</td>\n        <td>12.02</td>\n        <td>6.02</td>\n    </tr>\n</table>\n---\n\n\n<p>使用FileReader很简单，它提供了四个简单的接口用来读取文件，分别是abort，readAsBinaryString，readAsDataURL，readAsText。</p>\n<h5 id=\"readAsXXX\"><a href=\"#readAsXXX\" class=\"headerlink\" title=\"readAsXXX\"></a>readAsXXX</h5><p>接口名清楚明白的说明了它的作用，以readAs开头的三个接口自然是用来读取文件的。很显然，所谓的文件，在不同的环境中有不同的格式不同的解释方式，这也正是这三个接口的不同之处。</p>\n<p>但在我们弄清楚读取文件获得了什么之前，也许我们更应该关心目标文件是什么，怎么获取。幸运地是DOM中老早就存在一个files方法可以获取我们要的文件，并且它还提供了一些方法和属性。主要的属性有name，size，type，显然这是文件名、文件尺寸和文件类型，虽然它也提供了3个读取文件的方法getAsXXX，但是由于FileReader的存在已经被废弃很久了，同样被废弃的还有fileName和fileSize。</p>\n<p>另外不得不说，Chrome在文件操作方面做的最出色，早在chrome13就已经实现了文件的写入，而其他浏览器至今还没有实现。</p>\n<p>然后说说读取文件吧，这个过程是需要时间的，所以必须异步读取它，还好我们有load方法，像这样：</p>\n<pre><code>var fr = false;\nif (typeof window.FileReader === &#39;undefined&#39;) &#123;\n    fr = new FileReader();\n    fr.readAsXXX(document.getElementById(&#39;input_file&#39;).files[0]);\n    fr.onload = function (p_fr) &#123;\n        console.log(p_fr.target.result);\n    &#125;;\n&#125;\n</code></pre>\n<h6 id=\"readAsBinaryString\"><a href=\"#readAsBinaryString\" class=\"headerlink\" title=\"readAsBinaryString\"></a>readAsBinaryString</h6><p>readAsBinaryString的result应该是一个二进制流，而log出的结果是一个夹杂着乱码符号的文本，里面还能看到图片是用PS保存的之类的信息。</p>\n<h6 id=\"readAsDataURL\"><a href=\"#readAsDataURL\" class=\"headerlink\" title=\"readAsDataURL\"></a>readAsDataURL</h6><p>readAsDataURL的result则是一个Base64的图片代码，可以直接放入HTML的img标签的属性src上。</p>\n<h6 id=\"readAsText\"><a href=\"#readAsText\" class=\"headerlink\" title=\"readAsText\"></a>readAsText</h6><p>readAsText的result和二进制的显示出来基本是一样的，包括一个信息头，接着大段的乱码应该是图片本身。</p>\n<p>该方法还有一个可选的参数[encoding]，即文本的编码方式，默认为urf-8。</p>\n<h5 id=\"Abort\"><a href=\"#Abort\" class=\"headerlink\" title=\"Abort\"></a>Abort</h5><p>abort是一个特别的方法，用来打断读取。当图片上传超时或者其他操作需要打断时就可以调用这个接口打断。另外还可以监听abort事件来处理打断后的情况。</p>\n<h3 id=\"使用FormData组织表单数据\"><a href=\"#使用FormData组织表单数据\" class=\"headerlink\" title=\"使用FormData组织表单数据\"></a>使用FormData组织表单数据</h3><p>解决了预览的问题，现在该解决上传的正事了，如果使用HTML5的上传方式那么就必须使用Ajax请求来与服务器通信，但表单中的文件应该如何以参数的方式通过ajax请求传送呢？</p>\n<p>在DOM API中，Form提供了一个方法FormData，它可以将表单元素的DOM对象直接转换为参数，通过Ajax请求传送。用起来很简单，使用new关键字将DOM对象传入参数即可：</p>\n<pre><code>var _fd = new FormData(document.getElementsByTagName(&#39;form&#39;)[0]);\n</code></pre>\n<p>然后只需要在Ajax请求中送出即可：</p>\n<pre><code>xhr.send(_fd);\n</code></pre>\n<h5 id=\"append\"><a href=\"#append\" class=\"headerlink\" title=\"append\"></a>append</h5><p>当然我们也可以加入不在表单中的额外参数，使用append方法即可：</p>\n<pre><code>var xhr = new XMLHttpRequest();  \nvar formData = new FormData(document.getElementsByTagName(&#39;form&#39;)[0]);\nformData.append(&#39;param1&#39;, &#39;a parameter&#39;);\nxhr.open(&#39;POST&#39;, &#39;uploader.php&#39;);\nxhr.send(formData);\n</code></pre>\n<p>append方法一般可以传入一对键值组合的参数用来添加到表单数据之中，但它还提供了另外一种用法，传入参数名以及一个Blob或者File，另外还有第三个可选的参数，是该参数的文件名。</p>\n<p>至于Blob，是一个类似于文件的Object，我的理解是它在某些环境中可以解析为文件，但是在浏览器中是无法识别的。</p>\n<h5 id=\"支持情况\"><a href=\"#支持情况\" class=\"headerlink\" title=\"支持情况\"></a>支持情况</h5><p>作为一个HTML5的方法自然也是有浏览器支持的问题的，如下表：</p>\n<hr>\n<table style=\"text-align: center;\">\n    <tr>\n        <th width=\"20%\">IE</th>\n        <th width=\"20%\">Chrome</th>\n        <th width=\"20%\">Firefox</th>\n        <th width=\"20%\">Opera</th>\n        <th width=\"20%\">Safari</th>\n    </tr>\n    <tr>\n        <td>10</td>\n        <td>7+</td>\n        <td>4.0</td>\n        <td>12+</td>\n        <td>5+</td>\n    </tr>\n</table>\n---\n\n<p>不过append方法的支持情况就有点不尽人意了，只有Chrome完全支持，Firefox在22以后才支持，其他浏览器均不支持。</p>\n<h3 id=\"上传文件\"><a href=\"#上传文件\" class=\"headerlink\" title=\"上传文件\"></a>上传文件</h3><p>一般来说提交form数据到服务器，上传文件即可交由后端完成。但HTML5需要获取上传进度，就会比较特殊，所以还需要为Ajax请求绑定一些事件来处理不同的情况。</p>\n<h5 id=\"Event\"><a href=\"#Event\" class=\"headerlink\" title=\"Event\"></a>Event</h5><p>一般来说，只需要使用XMLHttpRequest的addEventListener方法来绑定事件，像这样</p>\n<pre><code>xhr.addEventListener(&#39;load&#39;, function (p_event) &#123;\n    // your code...\n&#125;, false);\n</code></pre>\n<p>除了load事件以外，还有一下一些事件，可以满足上传过程中遇到的各种问题。</p>\n<p>1.abort 上传中断时触发。<br>2.error 上传出错时触发。<br>3.load 文件成功读取完成时触发。<br>4.loadend 文件读取结束时无论是否成功触发。<br>5.loadstart 文件读取开始时触发。<br>6.progress 文件读取过程中每秒触发一次。</p>\n<h6 id=\"progress\"><a href=\"#progress\" class=\"headerlink\" title=\"progress\"></a>progress</h6><p>progress方法比较特殊，会在上传过程中一直触发，并获取当前上传的量 <code>loaded</code> 和总量等数据 <code>total</code> 。<br>主要需要用到的有2个数据，loaded已上传的部分和total总量，单位都是b，利用它们算出上传进度就可以显示百分比或设置进度条的宽度，甚至记录进度改变时花费的时间就能算出上传速度。</p>\n<p>另外progress的监听比较特殊，像这样：</p>\n<pre><code>xhr.upload.addEventListener(&#39;progress&#39;, function (p_event) &#123;\n    var _loaded = p_event.loaded;\n    var _total = p_event.total;\n    var _percent = Math.round(_loaded * 100 / _total);\n    // using percent...\n&#125;, false);\n</code></pre>\n<p>需要使用xhr.upload的addEventListener方法来监听事件，而不是直接使用xhr。</p>\n<h3 id=\"INPUT标签\"><a href=\"#INPUT标签\" class=\"headerlink\" title=\"INPUT标签\"></a>INPUT标签</h3><p>最后，是一个文件上传的老问题，无论是HTML5还是4，file类型的input标签样式总是无法统一，也无法美化。所以我们只能以暴制暴，不能化妆那就整容，用其他元素把它彻底覆盖掉。众所周知的做法是把input隐藏，然后问题来了，如何触发上传。</p>\n<h6 id=\"trigger\"><a href=\"#trigger\" class=\"headerlink\" title=\"trigger\"></a>trigger</h6><p>一般首先想到的是模拟触发，比如jQuery中的trigger方法，可以让我们点击甚至其他动作时触发input标签。但是IE由于安全性问题不允许模拟触发file类型的input标签事件，所以如果不支持IE的项目可以使用这个方法轻松搞定。</p>\n<h6 id=\"透明化按钮\"><a href=\"#透明化按钮\" class=\"headerlink\" title=\"透明化按钮\"></a>透明化按钮</h6><p>既然不能模拟，真实用户的点击行为自然是没问题了吧，于是另一个方法诞生了，将input标签变成透明的，覆盖在一个按钮样式的标签上，如此用户看到的是一个美化的按钮，点击的却是Input标签。但是有一个问题，file类型的Input标签在各浏览器中的尺寸和位置都是不太一致的，尤其是改变其尺寸后，有的浏览器甚至无法改变。所以如何按钮较大或者直接是一个区域时则会出现问题。</p>\n<h6 id=\"鼠标跟随\"><a href=\"#鼠标跟随\" class=\"headerlink\" title=\"鼠标跟随\"></a>鼠标跟随</h6><p>方法继续进化，虽然点击区域的尺寸可能会很大，但鼠标的点击永远只是一个点，于是只要让Input标签一直跟随鼠标在区域内移动，将可点击部分随时对准鼠标指针，就可以让鼠标在区域内点击到Input标签了。这个方法解决了所有问题，但它的效率很成问题，甚至不能过分使用函数节流，因为移动过快时可能点击不到。</p>\n<h6 id=\"Label触发\"><a href=\"#Label触发\" class=\"headerlink\" title=\"Label触发\"></a>Label触发</h6><p>后来在StackOverflow上看到了一个很不错的方法，就是利用Labal标签的for属性去触发input标签，只要将for的值写成Input的Id即可。但在我的测试中Firefox好像是不能触发的，不知道是否还有其他的属性需要设置。</p>\n<p>这四种方法各有各的优劣，只能根据具体情况选择使用了。</p>\n<h5 id=\"多文件上传-Multiple\"><a href=\"#多文件上传-Multiple\" class=\"headerlink\" title=\"多文件上传 Multiple\"></a>多文件上传 Multiple</h5><p>在Input标签上也出现了一个很实用的HTML5的新功能，那就是多文件上传，实现也非常简单，只要加上multiple的属性即可</p>\n<pre><code>&lt;input type=&quot;file&quot; name=&quot;files[]&quot; multiple=&quot;multiple&quot; /&gt;\n</code></pre>\n<p>如此在上传的时候就可以选择多个文件，另外在后端接受数据时，每个属性都变成了一个数组，以PHP为例：</p>\n<pre><code>&lt;?php\n    header(&#39;Content-type: text/json&#39;);\n    print_r($_FILES[&quot;upload&quot;][&quot;name&quot;]);\n    $rtn = array(\n        &quot;code&quot; =&gt; 0,\n        &quot;data&quot; =&gt; &#39;&#39;\n    );\n    if ($_FILES[&quot;upload&quot;][&quot;error&quot;] &gt; 0) &#123;\n        $rtn[&quot;code&quot;] = -1;\n    &#125; else &#123;\n        $rtn[&quot;data&quot;] = array(\n            &quot;name&quot; =&gt; $_FILES[&quot;upload&quot;][&quot;name&quot;],\n            &quot;type&quot; =&gt; $_FILES[&quot;upload&quot;][&quot;type&quot;],\n            &quot;size&quot; =&gt; $_FILES[&quot;upload&quot;][&quot;size&quot;],\n            &quot;path&quot; =&gt; &quot;&quot;\n        );\n        if (file_exists(&quot;img/&quot;.$rtn[&quot;data&quot;][&quot;name&quot;])) &#123;\n            $rtn[&quot;code&quot;] = 1;\n        &#125; else &#123;\n            move_uploaded_file($_FILES[&quot;upload&quot;][&quot;tmp_name&quot;],\n                &quot;img/&quot;.$_FILES[&quot;upload&quot;][&quot;name&quot;]);\n            $rtn[&quot;code&quot;] = 0;\n            $rtn[&quot;data&quot;][&quot;path&quot;] = &quot;img/&quot;.$rtn[&quot;data&quot;][&quot;name&quot;];\n        &#125;\n    &#125;\n    echo json_encode($rtn);\n?&gt;\n</code></pre>\n<h3 id=\"参考文档：\"><a href=\"#参考文档：\" class=\"headerlink\" title=\"参考文档：\"></a>参考文档：</h3><ul>\n<li><a href=\"http://www.w3.org/TR/FileAPI/\">W3C FileReader Interface</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/FileReader?redirectlocale=en-US&redirectslug=DOM/FileReader\">MDN FileReader</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/File\">MDN DOM Files</a></li>\n<li><a href=\"http://robertnyman.com/2013/02/11/using-formdata-to-send-forms-with-xhr-as-keyvalue-pairs/\">Using FormData to send forms with xhr as key/value pairs</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/FormData\">MDN FormData</a></li>\n<li><a href=\"http://xhr.spec.whatwg.org/#interface-formdata\">Whatwg Interface FormData</a></li>\n<li><a href=\"http://www.w3.org/html/wg/drafts/html/master/forms.html#multipart-form-data\">W3C Forms multiple</a></li>\n<li><a href=\"http://www.sagarganatra.com/2011/04/file-upload-and-progress-events-with.html\">File upload and Progress events with HTML5</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>最近公司项目准备更换图片上传的插件，原来的是一个Flash控件，其实用起来还是不错的，还有进度条，浏览器支持情况也不错。不过因为某些页面的图片上传涉及到了跨域的问题，Flash似乎解决不了了，所以准备索性换成HTML5的，高端大气上档赤。然后这个HTML5上传图片功能自然落到了我的手上了。</p>\n<p>一般来说图片上传无非就是文件操作的问题，本来这是服务器对文件流的一个操作问题，前端应该是管不上的，不过HTML5再次赋予了我们前端神圣而伟大的权利，有了HTML5部分后端失业了lol。</p>\n<p>其实以前写过一个上传图片的插件，不过那时还活在IE6年代，只能用iframe搞定，虽然还挺好使的，不过在HTML5面前就是一个战斗力负5的渣渣，不仅需要后端返回各项数据，还必须把保存的临时图片地址再发给后端保存，实际请求是2次，而且还无法告诉用户上传进度与速度。</p>","more":"<h3 id=\"如何使用-FileReader\"><a href=\"#如何使用-FileReader\" class=\"headerlink\" title=\"如何使用 FileReader ?\"></a>如何使用 FileReader ?</h3><p>首先FileReader是一个用于读取文件的类，我们可以用new关键字实例化一个文件读取器，像这样：</p>\n<pre><code>var fr = new FileReader();\n</code></pre>\n<p>但是还有一个问题，这是一个HTML5的API，只有部分浏览器支持它，所以还得加上判断，另外它的支持情况是这样的：</p>\n<pre><code>var fr = false;\nif (typeof window.FileReader === &#39;undefined&#39;) &#123;\n    fr = new FileReader();\n&#125;\n</code></pre>\n<hr>\n<table style=\"text-align: center;\">\n    <tr>\n        <th width=\"20%\">IE</th>\n        <th width=\"20%\">Chrome</th>\n        <th width=\"20%\">Firefox</th>\n        <th width=\"20%\">Opera</th>\n        <th width=\"20%\">Safari</th>\n    </tr>\n    <tr>\n        <td>10</td>\n        <td>7</td>\n        <td>3.6</td>\n        <td>12.02</td>\n        <td>6.02</td>\n    </tr>\n</table>\n---\n\n\n<p>使用FileReader很简单，它提供了四个简单的接口用来读取文件，分别是abort，readAsBinaryString，readAsDataURL，readAsText。</p>\n<h5 id=\"readAsXXX\"><a href=\"#readAsXXX\" class=\"headerlink\" title=\"readAsXXX\"></a>readAsXXX</h5><p>接口名清楚明白的说明了它的作用，以readAs开头的三个接口自然是用来读取文件的。很显然，所谓的文件，在不同的环境中有不同的格式不同的解释方式，这也正是这三个接口的不同之处。</p>\n<p>但在我们弄清楚读取文件获得了什么之前，也许我们更应该关心目标文件是什么，怎么获取。幸运地是DOM中老早就存在一个files方法可以获取我们要的文件，并且它还提供了一些方法和属性。主要的属性有name，size，type，显然这是文件名、文件尺寸和文件类型，虽然它也提供了3个读取文件的方法getAsXXX，但是由于FileReader的存在已经被废弃很久了，同样被废弃的还有fileName和fileSize。</p>\n<p>另外不得不说，Chrome在文件操作方面做的最出色，早在chrome13就已经实现了文件的写入，而其他浏览器至今还没有实现。</p>\n<p>然后说说读取文件吧，这个过程是需要时间的，所以必须异步读取它，还好我们有load方法，像这样：</p>\n<pre><code>var fr = false;\nif (typeof window.FileReader === &#39;undefined&#39;) &#123;\n    fr = new FileReader();\n    fr.readAsXXX(document.getElementById(&#39;input_file&#39;).files[0]);\n    fr.onload = function (p_fr) &#123;\n        console.log(p_fr.target.result);\n    &#125;;\n&#125;\n</code></pre>\n<h6 id=\"readAsBinaryString\"><a href=\"#readAsBinaryString\" class=\"headerlink\" title=\"readAsBinaryString\"></a>readAsBinaryString</h6><p>readAsBinaryString的result应该是一个二进制流，而log出的结果是一个夹杂着乱码符号的文本，里面还能看到图片是用PS保存的之类的信息。</p>\n<h6 id=\"readAsDataURL\"><a href=\"#readAsDataURL\" class=\"headerlink\" title=\"readAsDataURL\"></a>readAsDataURL</h6><p>readAsDataURL的result则是一个Base64的图片代码，可以直接放入HTML的img标签的属性src上。</p>\n<h6 id=\"readAsText\"><a href=\"#readAsText\" class=\"headerlink\" title=\"readAsText\"></a>readAsText</h6><p>readAsText的result和二进制的显示出来基本是一样的，包括一个信息头，接着大段的乱码应该是图片本身。</p>\n<p>该方法还有一个可选的参数[encoding]，即文本的编码方式，默认为urf-8。</p>\n<h5 id=\"Abort\"><a href=\"#Abort\" class=\"headerlink\" title=\"Abort\"></a>Abort</h5><p>abort是一个特别的方法，用来打断读取。当图片上传超时或者其他操作需要打断时就可以调用这个接口打断。另外还可以监听abort事件来处理打断后的情况。</p>\n<h3 id=\"使用FormData组织表单数据\"><a href=\"#使用FormData组织表单数据\" class=\"headerlink\" title=\"使用FormData组织表单数据\"></a>使用FormData组织表单数据</h3><p>解决了预览的问题，现在该解决上传的正事了，如果使用HTML5的上传方式那么就必须使用Ajax请求来与服务器通信，但表单中的文件应该如何以参数的方式通过ajax请求传送呢？</p>\n<p>在DOM API中，Form提供了一个方法FormData，它可以将表单元素的DOM对象直接转换为参数，通过Ajax请求传送。用起来很简单，使用new关键字将DOM对象传入参数即可：</p>\n<pre><code>var _fd = new FormData(document.getElementsByTagName(&#39;form&#39;)[0]);\n</code></pre>\n<p>然后只需要在Ajax请求中送出即可：</p>\n<pre><code>xhr.send(_fd);\n</code></pre>\n<h5 id=\"append\"><a href=\"#append\" class=\"headerlink\" title=\"append\"></a>append</h5><p>当然我们也可以加入不在表单中的额外参数，使用append方法即可：</p>\n<pre><code>var xhr = new XMLHttpRequest();  \nvar formData = new FormData(document.getElementsByTagName(&#39;form&#39;)[0]);\nformData.append(&#39;param1&#39;, &#39;a parameter&#39;);\nxhr.open(&#39;POST&#39;, &#39;uploader.php&#39;);\nxhr.send(formData);\n</code></pre>\n<p>append方法一般可以传入一对键值组合的参数用来添加到表单数据之中，但它还提供了另外一种用法，传入参数名以及一个Blob或者File，另外还有第三个可选的参数，是该参数的文件名。</p>\n<p>至于Blob，是一个类似于文件的Object，我的理解是它在某些环境中可以解析为文件，但是在浏览器中是无法识别的。</p>\n<h5 id=\"支持情况\"><a href=\"#支持情况\" class=\"headerlink\" title=\"支持情况\"></a>支持情况</h5><p>作为一个HTML5的方法自然也是有浏览器支持的问题的，如下表：</p>\n<hr>\n<table style=\"text-align: center;\">\n    <tr>\n        <th width=\"20%\">IE</th>\n        <th width=\"20%\">Chrome</th>\n        <th width=\"20%\">Firefox</th>\n        <th width=\"20%\">Opera</th>\n        <th width=\"20%\">Safari</th>\n    </tr>\n    <tr>\n        <td>10</td>\n        <td>7+</td>\n        <td>4.0</td>\n        <td>12+</td>\n        <td>5+</td>\n    </tr>\n</table>\n---\n\n<p>不过append方法的支持情况就有点不尽人意了，只有Chrome完全支持，Firefox在22以后才支持，其他浏览器均不支持。</p>\n<h3 id=\"上传文件\"><a href=\"#上传文件\" class=\"headerlink\" title=\"上传文件\"></a>上传文件</h3><p>一般来说提交form数据到服务器，上传文件即可交由后端完成。但HTML5需要获取上传进度，就会比较特殊，所以还需要为Ajax请求绑定一些事件来处理不同的情况。</p>\n<h5 id=\"Event\"><a href=\"#Event\" class=\"headerlink\" title=\"Event\"></a>Event</h5><p>一般来说，只需要使用XMLHttpRequest的addEventListener方法来绑定事件，像这样</p>\n<pre><code>xhr.addEventListener(&#39;load&#39;, function (p_event) &#123;\n    // your code...\n&#125;, false);\n</code></pre>\n<p>除了load事件以外，还有一下一些事件，可以满足上传过程中遇到的各种问题。</p>\n<p>1.abort 上传中断时触发。<br>2.error 上传出错时触发。<br>3.load 文件成功读取完成时触发。<br>4.loadend 文件读取结束时无论是否成功触发。<br>5.loadstart 文件读取开始时触发。<br>6.progress 文件读取过程中每秒触发一次。</p>\n<h6 id=\"progress\"><a href=\"#progress\" class=\"headerlink\" title=\"progress\"></a>progress</h6><p>progress方法比较特殊，会在上传过程中一直触发，并获取当前上传的量 <code>loaded</code> 和总量等数据 <code>total</code> 。<br>主要需要用到的有2个数据，loaded已上传的部分和total总量，单位都是b，利用它们算出上传进度就可以显示百分比或设置进度条的宽度，甚至记录进度改变时花费的时间就能算出上传速度。</p>\n<p>另外progress的监听比较特殊，像这样：</p>\n<pre><code>xhr.upload.addEventListener(&#39;progress&#39;, function (p_event) &#123;\n    var _loaded = p_event.loaded;\n    var _total = p_event.total;\n    var _percent = Math.round(_loaded * 100 / _total);\n    // using percent...\n&#125;, false);\n</code></pre>\n<p>需要使用xhr.upload的addEventListener方法来监听事件，而不是直接使用xhr。</p>\n<h3 id=\"INPUT标签\"><a href=\"#INPUT标签\" class=\"headerlink\" title=\"INPUT标签\"></a>INPUT标签</h3><p>最后，是一个文件上传的老问题，无论是HTML5还是4，file类型的input标签样式总是无法统一，也无法美化。所以我们只能以暴制暴，不能化妆那就整容，用其他元素把它彻底覆盖掉。众所周知的做法是把input隐藏，然后问题来了，如何触发上传。</p>\n<h6 id=\"trigger\"><a href=\"#trigger\" class=\"headerlink\" title=\"trigger\"></a>trigger</h6><p>一般首先想到的是模拟触发，比如jQuery中的trigger方法，可以让我们点击甚至其他动作时触发input标签。但是IE由于安全性问题不允许模拟触发file类型的input标签事件，所以如果不支持IE的项目可以使用这个方法轻松搞定。</p>\n<h6 id=\"透明化按钮\"><a href=\"#透明化按钮\" class=\"headerlink\" title=\"透明化按钮\"></a>透明化按钮</h6><p>既然不能模拟，真实用户的点击行为自然是没问题了吧，于是另一个方法诞生了，将input标签变成透明的，覆盖在一个按钮样式的标签上，如此用户看到的是一个美化的按钮，点击的却是Input标签。但是有一个问题，file类型的Input标签在各浏览器中的尺寸和位置都是不太一致的，尤其是改变其尺寸后，有的浏览器甚至无法改变。所以如何按钮较大或者直接是一个区域时则会出现问题。</p>\n<h6 id=\"鼠标跟随\"><a href=\"#鼠标跟随\" class=\"headerlink\" title=\"鼠标跟随\"></a>鼠标跟随</h6><p>方法继续进化，虽然点击区域的尺寸可能会很大，但鼠标的点击永远只是一个点，于是只要让Input标签一直跟随鼠标在区域内移动，将可点击部分随时对准鼠标指针，就可以让鼠标在区域内点击到Input标签了。这个方法解决了所有问题，但它的效率很成问题，甚至不能过分使用函数节流，因为移动过快时可能点击不到。</p>\n<h6 id=\"Label触发\"><a href=\"#Label触发\" class=\"headerlink\" title=\"Label触发\"></a>Label触发</h6><p>后来在StackOverflow上看到了一个很不错的方法，就是利用Labal标签的for属性去触发input标签，只要将for的值写成Input的Id即可。但在我的测试中Firefox好像是不能触发的，不知道是否还有其他的属性需要设置。</p>\n<p>这四种方法各有各的优劣，只能根据具体情况选择使用了。</p>\n<h5 id=\"多文件上传-Multiple\"><a href=\"#多文件上传-Multiple\" class=\"headerlink\" title=\"多文件上传 Multiple\"></a>多文件上传 Multiple</h5><p>在Input标签上也出现了一个很实用的HTML5的新功能，那就是多文件上传，实现也非常简单，只要加上multiple的属性即可</p>\n<pre><code>&lt;input type=&quot;file&quot; name=&quot;files[]&quot; multiple=&quot;multiple&quot; /&gt;\n</code></pre>\n<p>如此在上传的时候就可以选择多个文件，另外在后端接受数据时，每个属性都变成了一个数组，以PHP为例：</p>\n<pre><code>&lt;?php\n    header(&#39;Content-type: text/json&#39;);\n    print_r($_FILES[&quot;upload&quot;][&quot;name&quot;]);\n    $rtn = array(\n        &quot;code&quot; =&gt; 0,\n        &quot;data&quot; =&gt; &#39;&#39;\n    );\n    if ($_FILES[&quot;upload&quot;][&quot;error&quot;] &gt; 0) &#123;\n        $rtn[&quot;code&quot;] = -1;\n    &#125; else &#123;\n        $rtn[&quot;data&quot;] = array(\n            &quot;name&quot; =&gt; $_FILES[&quot;upload&quot;][&quot;name&quot;],\n            &quot;type&quot; =&gt; $_FILES[&quot;upload&quot;][&quot;type&quot;],\n            &quot;size&quot; =&gt; $_FILES[&quot;upload&quot;][&quot;size&quot;],\n            &quot;path&quot; =&gt; &quot;&quot;\n        );\n        if (file_exists(&quot;img/&quot;.$rtn[&quot;data&quot;][&quot;name&quot;])) &#123;\n            $rtn[&quot;code&quot;] = 1;\n        &#125; else &#123;\n            move_uploaded_file($_FILES[&quot;upload&quot;][&quot;tmp_name&quot;],\n                &quot;img/&quot;.$_FILES[&quot;upload&quot;][&quot;name&quot;]);\n            $rtn[&quot;code&quot;] = 0;\n            $rtn[&quot;data&quot;][&quot;path&quot;] = &quot;img/&quot;.$rtn[&quot;data&quot;][&quot;name&quot;];\n        &#125;\n    &#125;\n    echo json_encode($rtn);\n?&gt;\n</code></pre>\n<h3 id=\"参考文档：\"><a href=\"#参考文档：\" class=\"headerlink\" title=\"参考文档：\"></a>参考文档：</h3><ul>\n<li><a href=\"http://www.w3.org/TR/FileAPI/\">W3C FileReader Interface</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/FileReader?redirectlocale=en-US&redirectslug=DOM/FileReader\">MDN FileReader</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/File\">MDN DOM Files</a></li>\n<li><a href=\"http://robertnyman.com/2013/02/11/using-formdata-to-send-forms-with-xhr-as-keyvalue-pairs/\">Using FormData to send forms with xhr as key/value pairs</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/FormData\">MDN FormData</a></li>\n<li><a href=\"http://xhr.spec.whatwg.org/#interface-formdata\">Whatwg Interface FormData</a></li>\n<li><a href=\"http://www.w3.org/html/wg/drafts/html/master/forms.html#multipart-form-data\">W3C Forms multiple</a></li>\n<li><a href=\"http://www.sagarganatra.com/2011/04/file-upload-and-progress-events-with.html\">File upload and Progress events with HTML5</a></li>\n</ul>"},{"layout":"post","title":"改进我的Workflow","_content":"\n有人说过程序员和码农的本质区别就是程序员会不断探索提高生产力的方法。思维模式的转变是提高生产力的最好方式，但打磨我们的工具也是十分有意义的事，本文将从开发环境，自动化开发，开发工具等几个方面针对前端开发效率的提升和代码质量的提高来展开讨论。\n\n每件事都是一个程序，开发也像程序一样，每个步骤都是一段代码，当开发规模随着文档、代码、需求而增加时，重复的步骤变得越来越多。此时，如果可以像抽象代码一样抽象出一些相同操作就可以大大提升开发效率。因此，出现了更多更优质的工具来代替人工做一些不断重复的开发以减少程序员的工作量。\n<!-- more -->\n### 开发环境 ###\n\n##### Nodejs #####\n\n首先，需要搭建一个自动化高效率的开发环境。以前我们有shell、java、ruby来进行一些自动化脚本的执行。但自从Nodejs将Javascript带入了服务器，Front End开发环境也发生了翻天覆地的变化。Nodejs不仅仅可以让Jser开发服务端，还让Javascript成为了服务器脚本语言之一，可以用于文件的操作。\n\n安装Nodejs的方法目前来说很简单，[点这里下载安装包](http://nodejs.org/download/)，选择对应的平台的安装包即可。不过不得不说的是Source Code包，这是源码需要编译，虽然由C++写成，但gyp进行管理，所以编译时需要Python2.6+和C++编译器一起工作。通过命令 `node -v` 来检验是否安装成功，成功则返回当前版本号。\n\n另外Nodejs还有一样必备的工具npm，就像ruby中的gem一样，是一个Nodejs的包管理器，可以为Nodejs添加一些包。npm的安装非常简单[1]，可以说不用安装，在Linux下只有一行命令： `make install` \n, 而Windows和Mac都默认带有npm。当然如果想专门安装npm也是可以的，Linux下仍然是一行代码：\n\n    curl https://npmjs.org/install.sh | sudo sh\n\n而Windows会稍微麻烦一点，在[https://npmjs.org/dist/](https://npmjs.org/dist/)下载源码，然后放到和node.exe一个文件夹下即可。\n\n使用npm来安装一些包很简单，使用这样的命令 `npm install <package_name>` ，一般来说会默认安装在当前目录中。但如果使用参数 `-g` 就可以安装在全局。另外通过在项目中添加一个 `package.json` 文件，就可以定义项目依赖的Nodejs包，然后直接在该目录中执行 `npm install` 指令就会将package文件指定的包全部安装在当前目录。\n\n##### Shell #####\n\n不管是Linux还是Mac都天然的拥有Shell环境，但是Windows中的CMD是无法和Shell相提并论的，而且很多开发工具也需要Shell环境。\n\n还好Windows中有MSYS[2]，全称是Minimal GNU（POSIX）system on Windows，它是一个GNU工具集，包括了bash，make，gawk和grep。可以直接下载 \n\n[http://www.mingw.org/wiki/MSYS](http://www.mingw.org/wiki/MSYS)\n\n如果需要整个Unix环境和C的库的话，还需要minGW。也可以直接安装Git Bash工具，会附带有这个，这样环境和Git就会一起装好。\n\n[http://git-scm.com/downloads](http://git-scm.com/downloads)\n\n另外在Windows中使用Shell时，有几点需要注意。文件路径的根目录为Git Bash的文件根路径，但是可以使用斜杠和盘符代表Windows的磁盘，比如进入D盘下的workspace文件夹就这样：\n\n    $ cd /d/workspace/\n\n而Windows特有的文件夹名称中带有空格的问题可以通过两个方法解决。\n\n    $ mkdir /c/\"work space\"\n    $ rmdir /c/work\\ space\n\n用引号括起来带有空格的文件名或者使用反斜杠来转义空格。\n\n##### Git #####\n\nGit的安装很分散[12]，每种平台都不一样，Linux中也分为两种使用yum或者apt-get来安装：\n\n    // as Fedora\n    $ yum install git-core\n    // as Ubuntu\n    $ apt-get install git\n\nMac上是最简单的，在这里安装[http://code.google.com/p/git-osx-installer](http://code.google.com/p/git-osx-installer)\n\nWindows也很方便，因为有了[Msysgit](http://msysgit.github.com/)，也一样直接安装。\n\n##### 编辑器 #####\n\n编辑器是每个程序员最常用的工具，它在很大程度上决定了单纯Coding的效率。原来有人将Vim和Emacs奉为上古神器，不过我喜欢新的东西，SublimeText是目前编辑器中的新贵，拥有海量插件，使用Python编写，配置和操作都非常方便。可以到这里下载：\n\n* [SublimeText2](http://www.sublimetext.com/)\n\n现在第3版正在进行beta测试，但是由于升级为Python3，原来的插件都因为API更新的问题而无法使用了，相信在正式版发布后插件将会陆续升级。这是第三版的下载地址，不会覆盖第二版。\n\n* [SublimeText3](http://www.sublimetext.com/3)\n\n此外，虽然它是付费软件，不过作者好像从来不怕没有人付费，如果没有注册仅仅会偶尔在保存时弹出Lisence声明，但确认会弹出官方页面，点取消即可。好像还有破解版本的出现，不过作者已经这么大度了，用破解版好像有点说不过去。国内曾经还有人组织过团购，但是作者表示不存在团购一说，只有公司批量购买，最终只有不了了之，售价$70。\n\n##### 浏览器 #####\n\n作为前端最基本的环境，浏览器是必不可少的。Chrome是我最喜欢的浏览器，因为它的快速高效以及很棒的开发者工具。虽然Firefox也是一款出色的浏览器，但Firebug作为一款插件，效率总是差那么一点，当然Firefox现在也推出了自己的调试工具。用于测试的IE浏览器也是常备工具之一，此外还有Opera和Safari。\n\nChrome和Firefox很强大的一个原因就是，它们对W3C的标准都很快速的支持，许多最新的特性都可以体现在最新版的Chrome以及Firefox中。特别需要一说的是，它们都有一个每日更新的版本，用户可以体验到最新的功能，而浏览器厂商可以获取崩溃信息等反馈来提高品质。Chrome的每日更新版叫[Chrome Canary](https://www.google.com/intl/zh-CN/chrome/browser/canary.html),Firefox的比较直接，[Firefox Nightly](http://nightly.mozilla.org/)。\n\n还有一款很神奇的浏览器，它不会渲染，也没有界面，基于Webkit内核，它叫[PlantomJS](http://phantomjs.org/index.html)，图标的幽灵和名字都突出了这一特点。也许看起来没什么用，但在测试或者做研究时，浏览器不厌其烦的弹出来时，它就有大用处了。\n\n### 自动化开发 ###\n\n##### Yeoman #####\n\nYeoman按照官方说法[3]，它不只是一个工具，还是一个工作流。它其实包括了三个部分yo、grunt、bower，分别用于项目的启动、文件操作、包管理。但我并不太认同这是一个工作流的说法，至少目前来看还不够成熟，在真实的生产环境中会遇到许多问题。而未来的可能性大致应该有两条路可走，也许会产生某些工作流的标准来定义前端开发的软件质量，不过我更认为Yeoman应该走向高可定制的工作流工具的方向，而不是自身作为一个工作流来存在。\n\n###### Yo ######\n\nYo是一个项目初始化工具，可以生成一套启动某类项目必须的项目文件。可以通过npm安装它到全局：\n\n    npm install -g yo\n\n然后还需要安装一些generator，这是一个用于创建某个指定类型项目的生成器。比如安装一个最常用的webapp的生成器，然后就可以在项目路径下生成项目启动需要的所有文件，像这样：\n\n    npm install -g generator-webapp\n    cd /project_folder/\n    yo webapp\n\n但是这种机制有一个很严重的问题，generator产生的文件结构是谁制定的？没有一个官方的相应的标准或者说Guide，generator的形式参差不齐，甚至我发现Firefox OS的generator生成的是一个API接口的Demo而不是一个种子，如果要进行开发需要进行很多删减。\n\n不过产生这些generator的generator[4]却是一个很好的工具，它应该是一个创造性的工具。首先需要安装generator-generator，然后使用它，接着会看到字符拼接的yeoman，像这样：\n\n    npm install -g yo generator-generator\n    $ mkdir ~/dev/generator-blog && cd $_\n    $ yo generator\n\n        _-----_\n       |       |\n       |--(o)--|   .--------------------------.\n      `---------´  |    Welcome to Yeoman,    |\n       ( _´U`_ )   |   ladies and gentlemen!  |\n       /___A___\\   '__________________________'\n        |  ~  |\n      __'.___.'__\n    ´   `  |° ´ Y `\n\n当然使用它之前应该将写好的项目文件放入 `app/templates` 文件夹中，并在 `templates` 同级的路径中加入 `index.js` 进行配置就可以了。这里的index.js是运行在Nodejs中的，也就是说由它将templates中的项目文件放入该放的地方并且填入一些变量去构建整个项目。这里才是体现一个generator是否是一个好的generator的地方，如果仅仅是将一堆写好的项目文件下载下来那什么意义也没有，不存在万用种子。只有在使用generator生成项目时高度定制才是其意义所在，而相关标准才是最难的部分。\n\n##### Bower #####\n\nBower是一个类似于npm的包管理器，但不同的是Bower主要针对前端，并且直接从Github查找需要的库下载到本地缓存。使用很简单，用npm安装bower后可以安装Github的项目并指定版本号，还可以重命名。默认会下载到项目中的 `bower_components` 文件夹中。[5]\n\n    npm install -g bower\n    bower install jQuery\n    bower install jQuery#1.10.3\n    bower install jQueryOld=jQuery#1.6.4\n\n还可以通过bower.json文件来配置需要安装的包，使用 `bower init` 命令就可以生成bower.json文件，然后在其中写入需要的包及其版本即可\n\n    {\n      \"name\": \"my_project\",\n      \"version\": \"0.1.0\",\n      \"main\": [js/js.js, css/css.css],\n      \"ignore\": [\n        \".jshintrc\",\n        \"**/*.txt\"\n      ],\n      \"dependencies\": {\n        \"<name>\": \"<version>\",\n        \"<name>\": \"<folder>\",\n        \"<name>\": \"<package>\"\n      },\n      \"devDependencies\": {\n        \"<test-framework-name>\": \"<version>\"\n      }\n    }\n\n当然它也可以搜索包，像这样搜索一下jquery。\n\n    bower search jquery\n\n如果觉得bower_components的文件夹名太长不好，可以在 `.bowerrc` 中以json的形式修改它的路径\n\n    {\n      \"directory\": \"lib\"\n    }\n\n还有许多其他的配置，可以在Bower存放在Google Doc的文档[7]中查看。\n\n但是Bower还有一个Bug[6]，jQuery在Github上的项目文件是分模块的，必须使用项目中的Grunt才能打包成jquery.js文件，而官方的说法是使用小写q的 `jquery` 来获取components项目中的jquery文件，但是目前Bower是大小写不分的，所以无法获取独立的jQuery文件。如果bower可以指定获取某个项目中的某个或某些指定的文件将会更加犀利。\n\n甚至Bower可以在Nodejs中运行一个 `bower.commands` 文件来让你编写安装各种包的node程序，并且可以监听 `end` 事件在安装结束后进行操作，这是异步的，这样就可以随心所欲的安装包和控制顺序了。\n\n    var bower = require('bower');\n    bower.commands\n        .install(['jquery'], { save: true }, { /* custom config */ })\n        .on('end', function (installed) {\n            console.log(installed);\n    });\n\n##### Grunt #####\n\nGrunt目前来说是这三个Yeoman中最成熟最强大的，最关键的是Grunt有各种各样的插件，可以集成大部分能想得到的开发工具来进行自动化开发。另外Grunt的作者还开发了一整套的插件来适应常规的开发，这套插件以 `grunt-contrib-` 为前缀（下文中如无特殊说明，均指带有该前缀的插件名），除了文件的基本操作，还包括有测试、编译、压缩、代码检查等各种功能的插件，而且不止一个选择。\n\n安装Grunt和Bower不太一样[8]，需要先在全局安装一个Grunt的客户端，然后在每个项目中安装Grunt。\n\n    npm install -g grunt-cli\n    cd /project/\n    npm install grunt\n\n不过和Bower相似的是，可以通过编写配置json文件来使用 `npm install` 来安装Grunt和所有需要的插件，另外Grunt的插件也都是npm管理的，所以可以直接在 `package.json` 中直接编写。\n\n    {\n        \"name\": \"myProject\",\n        \"version\": \"0.1.0\",\n        \"devDependencies\": {\n            \"grunt\": \"*\",\n            // other plugin...\n            \"grunt-contrib-watch\": \"*\"\n        }\n    }\n\n安装完成后在项目根目录中建立 `Gruntfile.js` 文件来配置Grunt的工作流程。下面以 `copy` 插件为例使用Grunt进行开发。在 `exports` 中Grunt会以参数形式被传入函数，它有3个方法， `initConfig` 、 `loadNpmTasks` 、 `registerTask`，分别用来定义插件操作，载入插件，注册任务。\n\n    module.exports = function (grunt) {\n        grunt.initConfig({\n            copy: {\n                main: {\n                    files: {\n                        src: ['path/**'], \n                        dest: 'dest/'\n                    }\n                }\n            }\n        });\n        grunt.loadNpmTasks('grunt-contrib-copy');\n        grunt.registerTask('default', ['copy']);\n    };\n\n在配置中以插件名为键定义一个Object作为该插件的配置，其中还可以再定义一层以任务名为键，比如 `main` ，然后是插件的部分，copy插件使用 `files` 来定义对文件的具体操作， `src` 是要复制的文件， `dest` 则是要复制到的路径。\n\n然后使用 `loadNpmTasks` 加载插件，需要写全名，包括grunt-contrib前缀。\n\n最后是注册一个任务，这里的任务即是执行操作时需要调用的东西。比如代码中注册了 `default` 任务，包括一个数组中的所有任务，这样在执行default任务时就会执行相应的所有任务。另外default是一个特殊的任务名，如果在执行任务时没有指定名称，则执行该任务。当然直接运行copy任务也是可以的，甚至可以指定一个子任务，比如main。所以下面4行代码是相同的效果。\n    \n    grunt\n    grunt default\n    grunt copy\n    grunt copy:main\n\n不过需要特别注意的是，注册的任务名不能和原有的任务相同，这样会报错，比如这样：\n\n    grunt.registerTask('copy', ['copy']);\n\n和copy类似的文件基本操作还有 `clean` 清除, `concat` 连接, `rename` 重命名, `compress` 打包, `crypt` 编码等等，相关的配置可以在npmjs.org上的对应项目介绍中找到。\n\n还有四个用于压缩的插件 `htmlmin` , `cssmin` , `uglify` , `imagemin` 分别对应HTML文件、CSS文件、JS文件和图片文件；以及两个用于检查代码的插件 `csslint` , `jshint` 分别检查CSS代码和JS代码。\n\n当然，最重要的是，Grunt可以编译一些CSS和JS的其他形式代码。`coffee` 用于编译CoffeeScript，而CSS就更多了，比如[SASS](http://sass-lang.com/)可以使用 `compass` 或者 `sass`, 还有 `less` 和 `stylus`，我最喜欢的是[Stylus](http://learnboost.github.io/stylus/)，因为它使用的是Javascript来编译，而不像SASS是Ruby编译的，还需要准备Ruby的环境，非常麻烦。而且在Stylus中还可以写类似JS的条件语句和循环语句。这个国旗icon的项目很好的使用了Stylus以很短的代码完成了上百个国家的图标的CSS Sprite - [National Flag on Github](https://github.com/tychio/national_flag/blob/master/country.styl)。还有许多种Javascript模板的预编译插件，`haml` , `jst` , `jade` , `hogan` 等等。\n\n除了用于编码的插件，还有许多用于测试的插件，在grunt-contrib中提供了三个测试框架的插件， `nodeunit` 用于Nodejs，`qunit` 用于Qunit，是来自jQuery团队的测试框架，还有Junit的后继者 `jasmine`。另外Mocha也有自己的Grunt插件 `grunt-mocha` 。用于捕获多个浏览器测试框架karma也有相应的插件 `grunt-karma` 。\n\n此外，contrib中还有一些其他插件，比如 `connect` 用于http等协议的请求，支持https， `commands` 用于执行shell命令， `manifest`\n 用于生成离线应用所需的 `manifest.appcache` 文件，还有用于插件YUI文档的 `yuidoc` 。\n\n最最重要的一个插件就是 `watch` ，它可以随时监听某些指定的文件，当它们发生改变时执行相应的任务。再次使用copy做例子，添加watch任务后可以在原有文件发生改变时，将复制过去的副本也同步改变。\n\n    module.exports = function (grunt) {\n        grunt.initConfig({\n            watch: {\n                copy: {\n                    files: 'path/**',\n                    tasks: 'copy'\n                }\n            },\n            copy: {\n                main: {\n                    files: {\n                        src: ['path/**'], \n                        dest: 'dest/'\n                    }\n                }\n            }\n        });\n        grunt.loadNpmTasks('grunt-contrib-copy');\n        grunt.loadNpmTasks('grunt-contrib-watch');\n        grunt.registerTask('default', ['copy', 'watch']);\n    };\n\n由此，项目开发中的大部分工作都交由程序代替了人工，Yo和Bower可以快速的启动一个项目，Grunt在开发中可以自动化的持续完成编码中重复性的工作以及自动化检查和测试代码以提高质量。\n\n### 开发工具 ###\n\n##### SublimeText #####\n\n在自动化开发的前提下，仍然有很多编码工作是需要亲手完成的，此时编辑器的效率决定了剩下的开发效率。SublimeText一款很棒的编辑器，通过配置和插件的选择可以达到几乎所有需求。\n\n首先从GUI来说，ST的侧边栏可以随意的拖入文件夹并对其进行操作，而文本区则可以选择多种组合方式，包括网格、最多四栏、最多四列的布局。其滚动条也已经不是一个条了，而是一个代码的缩略图，拖动起来非常方便和清晰。每个文件的标签就像Chrome一样可以随意的拖出拖入。此外，代码的颜色样式可以有几十种方案供选择，还可以下载针对每种语言的颜色方案，目前我知道的仅有最新的Stylus的styl文件没有对应的颜色方案。\n\n在功能方面，ST最大的特色之一就是会自动生成一份正在打开的文件的拷贝，而且会自动保存，也就是说即使是断电关机，重新打开后原本打开的文件也还是存在不会丢失任何代码。其次，多处编辑也是非常的强大，在代码中选择多处后会出现多个光标，可以同时编辑，而选中一个词后，按 `Ctrl+D` 就可以多选下一个相同的代码。另外通过 'Ctrl+P' 可以搜索文件，配合 `@` 或者直接按 `Ctrl+R` 就可以前往指定的方法和函数，配合 `:` 或者直接按 `Ctrl+G` 就可以前往指定的行数。按住 `Shift+Ctrl+Up/Down` 就可以移动选中行的代码上下移动。其他编辑都有的一般的快捷键自然也都有。\n\n不过最强大的是，这些功能都可以利用插件实现，比如Emmet也就是大名鼎鼎的Zencoding的继任者就可以通过插件指定一个命令并分配一个快捷键来实现。我还喜欢使用Markdown preview，比如现在我就可以通过它预览一下博客的大致效果。还有刚刚提到的针对每种语言的颜色高亮方案也是插件的形式。还有一款老牌版本控制的工具Tortoise，因为公司还在用SVN这种老古董，Tortoise自然成了不二选择。还有很多插件，可以从官方网站搜索。\n[https://sublime.wbond.net/search/](https://sublime.wbond.net/search/)\n\n说到插件，自然少不了管理它的工具，SublimeText的管理工具是Package Control，原来的安装十分麻烦，不过现在官方给出了方法。使用 `Ctrl+~` 打开控制台，然后复制[这里官方给出的代码](https://sublime.wbond.net/installation)到控制台并执行，Package Control就安装好了。之后使用 `Ctrl+Shift+P` 调出命令面板后就会有一组Package Control的命令，主要会用到 `install` 和 `remove`\n两个用于安装和卸载插件。\n\n关于用户配置，有很多内容，可以参考 `Settings - Default` 。比如这样：\n\n    {\n        \"caret_style\": \"phase\",\n        \"font_size\": 16.0,\n        \"overlay_scroll_bars\": \"enabled\",\n        \"save_on_focus_lost\": true,\n        \"scroll_past_end\": false,\n        \"tab_size\": 4,\n        \"translate_tabs_to_spaces\": true,\n        \"word_wrap\": true,\n        \"wrap_width\": 80\n    }\n\n这些配置看到名字就基本可以猜出意思了，主要是wrap_width就是每行的字符数，设置到80，这样可以保持代码的简短，避免长语句。而translate_tabs_to_spaces就是用空格代替制表符。\n\n##### Chrome #####\n\n我始终喜欢Chrome多过Firefox，因为Chrome的启动速度比Firefox快上许多，Firefox原先有点过于臃肿了，不按标准的地方也不少，虽然后来在Google注资之后，不但版本号追了上来，功能也提升很多。不过Chrome仍是我开发的主要环境，Firefox一般仅作为研究和测试之用。\n\nChrome的开发者工具界面非常清爽，无论是在Elements中的HTML还是Sources中的Js，代码阅读和编辑都非常方便，而且在Element中可以修改和添加对应元素的CSS代码，而在Sources中可以直接修改CSS文件。Resources中列出了所有加载的文件，还有session、cookie和本地存储之类的缓存信息，可以方便的对其进行操作。而Network则列出了所有请求，以及相关的信息，甚至可以点击下面的圆点按钮 `preserve log upon Navigation` 进行请求响应时间的监视。在Timeline中还有更详细的时间监视，包括事件、加载以及内存的使用状况，可以方便的对程序的性能进行调试。在Profiles中可以对Js、CSS、DOM进行统计。还有Audits可以对网站性能和网络性能进行统计。\n\n最重要的是Console[11]，在这里可以直接写入Javascript代码进行调试，还可以收集到程序中输出的各种信息和报错。不过最特别的是它是有API的可编程。一般常用到 `log` 方法，像下面的代码这样来输出一些变量，当然还有不同的类型，比如 `error` 方法、 `warn` 方法。它们的参数也很自由，多个参数将会被空格连接输出，还可以在第一个参数中使用占位符来按类型加入后面的参数。\n\n    console.log('hello ' + world);\n    console.error('Error:', 'nothing...');\n    console.warn('Warn: %s < %d', 'age', 18);\n\n除了上面三个方法以及类似log的 `info` 和 `debug` 方法还有一个特别的方法，那就是断言 `assert` 方法，它可以判断条件，在false时报错，一般用于测试。\n\n另外还有三个关于时间的方法， `time` ， `timeEnd` 和 `timeStamp` 。time和timeEnd配合使用可以记录程序运行的时间并输出，而timeStamp可以在Timeline的统计中标出一个时间点。\n\nChrome的插件也非常的多，这里介绍三款和页面密切相关的工具。\n\n[Visual Event](https://chrome.google.com/webstore/detail/visual-event/pbmmieigblcbldgdokdjpioljjninaim) 是一个捕获页面事件的插件，它会将页面所有绑定的事件全部以可视化的方式呈现出来，并且可以点击查看某个元素的事件详细信息。我经常用来检查事件是否正确的绑定到了目标元素上。\n\n[Edit This Cookie](https://chrome.google.com/webstore/detail/edit-this-cookie/fngmhnnpilhplaeedifhccceomclgfbg) 顾名思义，用来编辑Cookie的，虽然DevTools也带有这样的功能，但是它更加便利，还可以导出导入，随意修改每个Cookie中的任意条目。虽然它很强大，不过好像利用率最高的功能是一键清空Cookie。\n\n[Code Cola](https://chrome.google.com/webstore/detail/code-cola/lomkpheldlbkkfiifcbfifipaofnmnkn) 可以用来修改CSS，与DevTools不同的是，它的操作是左右滑动滑块，而且主要针对CSS3的空间样式，可以快速将元素变成各种角度各种尺寸。\n\n不过Chrome还是有弱点的，当tab开的太多时会非常卡，因为Chrome每个tab都是一个单独的进程。所以还有一个插件也是很有用的，虽然和开发没有太大关系，[One Tab](https://chrome.google.com/webstore/detail/onetab/chphlpgkkbolifaimnlloiipkdnihall) 可以把当前的所有tab都集合起来变成一个页面，当需要打开时在点击链接即可，这样有效防止了过多tab造成的内存不足问题。\n\n### 代码管理 ###\n\n##### Git #####\n\n关于Git Workflow的讨论很多，最著名的当属[Vincent Driessen](http://nvie.com/)的那篇博客[13]。Vincent的工作流的结构很棒，首先有2个主要分支，`master` 和 `develop`，分别是主分支和开发分支。然后还有3类次分支，它们可能数量很多，并且不会长时间存在，分别是开发新功能用的feature，发布用的release和修复bug用的hotfix。大致的Git操作可以理解为这样：\n\n    # create branch\n    git checkout -b develop master\n    git checkout -b feature develop\n    # commit something\n    git add widget.js\n    git commit -m \"add a function\"\n    # merge to develop\n    git checkout develop\n    git merge --no-ff feature\n    # delete branch\n    git branch -d feature\n\n首先创建开发分支 `develop` ，然后再从开发分支创建一个次分支，接着提交代码并注释提交，合并会开发分支 `develop` ，最后删除这个临时的次分支。--no-ff的意思是不使用快速合并。其他开发过程中也是大同小异，release分支还有hotfix分支可能需要在确认没问题时合并到develop和master两个分支中然后删除。\n\n不过这个工作流是考虑到团队开发而设计的，很标准简约，但细节不足。而[Benjamin Sandofsky](https://sandofsky.com)的文章[14]则更加趋向于对commit的管理，也许不能算做工作流，至少算是一种理念。他强调一定要保留有一个私人的分支只存在于本地，然后在合并到主分支时清除原本的commit log。这里会用到一个 `merge` 命令的参数 `--squash` 这样合并后不会带来任何commit log。\n\n    # create brach\n    git checkout -b private master\n    # commit something\n    git add widget.js\n    git commit -m \"add a function\"\n    # merge brach but don't commit\n    git checkout master\n    git merge --squash private\n    # commit once\n    git commit -m \"only this commit\"\n\n但我认为Git工作流和其他一切工程过程一样，不存在银弹。不过这种合并的方式可以成为一种很好的操作流来完成属于每个人自己的工作流。另外从这两种不同风格的Git工作流中也许能找出一些有趣的点。以下是我的看法：\n\n* 主分支数由开发流程复杂度决定，而开发流程复杂度应该由项目主管根据项目规模确定，所以项目规模决定了主分支数，除了develop也许还需要test、build等等。\n\n* 次分支数由人员和实际情况决定，bug数会决定hotfix的数量，也许产品经理会决定feature的数量，多个不同版本的同类产品也可能会增加release的数量。如果项目规模足够大时，几个小组解决一个问题时也会产生多个临时分支。\n\n* 多人协作以及长时间开发都可能导致日志混乱无法管理，使用squash参数配合临时分支可以清理对别人不必要的commit信息。\n\n* 应使用--no-ff可以避免快速合并，使每次合并等于一次提交，记录在log中，保持分支健康。\n\n因此，在实际开发的工作流中应该按照实际情况创建分支，但应按照以上规范合并分支。\n\n##### Github #####\n\nGithub不止是每个Coder的FaceBook，还是一个非常棒的远程Git仓库，甚至有很多小组将生产项目托管在上面。其实Github上和Git没有太多差别，只是多了一个远程仓库Remote的操作，另外相信每个初入Github的新手都为私钥公钥头疼了好久，下文将会讨论Github的仓库创建和日常操作两部分。\n\n首先需要在本地建立与Github帐户的联系，在shell中安装SSH，然后像这样使用SSH安装SSH密钥：\n\n    ssh-keygen -t rsa -C \"your_email@example.com\"\n    # Creates a new ssh key, using the provided email as a label\n    # Generating public/private rsa key pair.\n    # Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): [Press enter]\n    ssh-add id_rsa\n\n然后会让你输入一个密码，随意输入就可以了，接着就会生成一个公钥一个私钥。在用户文件夹下的 `.ssh` 文件夹中找到id_rsa.pub，这个文件里就是公钥，复制里面的内容，然后在Github的Account Settings中的SSH Key页面，点击Add SSH Key按钮，输入一个用于说明的title，接着粘贴公钥到Key中就可以了。\n\n然后必须在Github上点击 `Create a new repo` 按钮来创建一个空项目。当然如果选择适当的选项就可以自动生成README文件、Git忽略文件和版权分享声明文件。之后该项目会有一个仓库的地址，可以使用HTTPS和SSH，甚至还有SVN地址：\n\n    https://github.com/<username>/<reponame>.git\n    git@github.com:<username>/<reponame>.git\n    https://github.com/<username>/<reponame>\n\n以我的一个对话框jQ插件为例，首先在项目中初始化git，然后添加一个远程仓库，然后就可以往上面提交代码了。\n\n    git remote add myGithub https://github.com/tychio/dialog.git\n    git push myGithub master\n\n因为我使用的HTTPS方式提交，之后会需要输入用户名和密码，如果使用SSH方式则用使用公钥而无需额外操作。使用HTTPS纯属为了记住Github的密码，每天都在敲就不会忘记了。\n\n### 总结 ###\n\n工作流应该是一个人最习惯和熟悉的流程，而不应该是照猫画虎，邯郸学步。还是那句话，不存在银弹，所以不会有万用的工作流，只能从中汲取有用的实践，完善改进自己的工作流，达到提高工作效率的目的。\n\n和学习其他技术一样，应用于工作流之中的工具有无数种，但真正需要和适合的只有自己知道，发现问题，带着问题寻找工具才能真的改进工作流。如果仅仅为了使用前沿的工具而使用，只会使自己的工作效率大打折扣。记得两年前我还在疯狂的复制代码，每当我意识到不能再这样下去的时候，工作流就会自己进化，合适的工具近在眼前，工作效率逐渐提升。我发现问题实在是很好的老师，可以让一个人快速的成长，解决它就可以获得一次提升。\n\n永远有人有跟你相同的问题，永远有能解决你当前问题的工具，善于使用问题来选择它们就能打造更完善的工作流。如果遇到没有工具能解决的问题，那说明造轮子的时机到了。\n\n### 参考文档 ###\n\n1. [NPM Readme](https://npmjs.org/doc/README.html)\n\n2. [MSYS Wiki](http://www.mingw.org/wiki/MSYS)\n\n3. [Yeoman home](http://yeoman.io/)\n\n4. [Yeoman generators](http://yeoman.io/generators.html)\n\n5. [Bower home](http://bower.io/)\n\n6. [Bower jquery bug](https://github.com/bower/bower/issues/859)\n\n7. [Bower configuration](https://docs.google.com/document/d/1APq7oA9tNao1UYWyOm8dKqlRP2blVkROYLZ2fLIjtWc/edit#heading=h.4pzytc1f9j8k)\n\n8. [Grunt getting started](http://gruntjs.com/getting-started)\n\n9. [Top 10 SublimeText2 plugins](http://www.henriquebarroso.com/my-top-10sublime-2-plugins/)\n\n10. [Install package control](https://sublime.wbond.net/installation)\n\n11. [Using the console API](https://developers.google.com/chrome-developer-tools/docs/console#using_the_console_api)\n\n12. [Getting Started Installing Git](http://git-scm.com/book/en/Getting-Started-Installing-Git)\n\n13. [A successful Git branching model](http://nvie.com/posts/a-successful-git-branching-model/)\n\n14. [Understanding the Git Workflow](https://sandofsky.com/blog/git-workflow.html)\n\n15. [Generating SSH Keys](https://help.github.com/articles/generating-ssh-keys)","source":"_posts/2013-09-25-improve-workflow.md","raw":"---\nlayout: post\ntitle: 改进我的Workflow\ntags: [workflow,grunt,bower,sublime text,chrome,github,git,node]\ncategory: Tech\n---\n\n有人说过程序员和码农的本质区别就是程序员会不断探索提高生产力的方法。思维模式的转变是提高生产力的最好方式，但打磨我们的工具也是十分有意义的事，本文将从开发环境，自动化开发，开发工具等几个方面针对前端开发效率的提升和代码质量的提高来展开讨论。\n\n每件事都是一个程序，开发也像程序一样，每个步骤都是一段代码，当开发规模随着文档、代码、需求而增加时，重复的步骤变得越来越多。此时，如果可以像抽象代码一样抽象出一些相同操作就可以大大提升开发效率。因此，出现了更多更优质的工具来代替人工做一些不断重复的开发以减少程序员的工作量。\n<!-- more -->\n### 开发环境 ###\n\n##### Nodejs #####\n\n首先，需要搭建一个自动化高效率的开发环境。以前我们有shell、java、ruby来进行一些自动化脚本的执行。但自从Nodejs将Javascript带入了服务器，Front End开发环境也发生了翻天覆地的变化。Nodejs不仅仅可以让Jser开发服务端，还让Javascript成为了服务器脚本语言之一，可以用于文件的操作。\n\n安装Nodejs的方法目前来说很简单，[点这里下载安装包](http://nodejs.org/download/)，选择对应的平台的安装包即可。不过不得不说的是Source Code包，这是源码需要编译，虽然由C++写成，但gyp进行管理，所以编译时需要Python2.6+和C++编译器一起工作。通过命令 `node -v` 来检验是否安装成功，成功则返回当前版本号。\n\n另外Nodejs还有一样必备的工具npm，就像ruby中的gem一样，是一个Nodejs的包管理器，可以为Nodejs添加一些包。npm的安装非常简单[1]，可以说不用安装，在Linux下只有一行命令： `make install` \n, 而Windows和Mac都默认带有npm。当然如果想专门安装npm也是可以的，Linux下仍然是一行代码：\n\n    curl https://npmjs.org/install.sh | sudo sh\n\n而Windows会稍微麻烦一点，在[https://npmjs.org/dist/](https://npmjs.org/dist/)下载源码，然后放到和node.exe一个文件夹下即可。\n\n使用npm来安装一些包很简单，使用这样的命令 `npm install <package_name>` ，一般来说会默认安装在当前目录中。但如果使用参数 `-g` 就可以安装在全局。另外通过在项目中添加一个 `package.json` 文件，就可以定义项目依赖的Nodejs包，然后直接在该目录中执行 `npm install` 指令就会将package文件指定的包全部安装在当前目录。\n\n##### Shell #####\n\n不管是Linux还是Mac都天然的拥有Shell环境，但是Windows中的CMD是无法和Shell相提并论的，而且很多开发工具也需要Shell环境。\n\n还好Windows中有MSYS[2]，全称是Minimal GNU（POSIX）system on Windows，它是一个GNU工具集，包括了bash，make，gawk和grep。可以直接下载 \n\n[http://www.mingw.org/wiki/MSYS](http://www.mingw.org/wiki/MSYS)\n\n如果需要整个Unix环境和C的库的话，还需要minGW。也可以直接安装Git Bash工具，会附带有这个，这样环境和Git就会一起装好。\n\n[http://git-scm.com/downloads](http://git-scm.com/downloads)\n\n另外在Windows中使用Shell时，有几点需要注意。文件路径的根目录为Git Bash的文件根路径，但是可以使用斜杠和盘符代表Windows的磁盘，比如进入D盘下的workspace文件夹就这样：\n\n    $ cd /d/workspace/\n\n而Windows特有的文件夹名称中带有空格的问题可以通过两个方法解决。\n\n    $ mkdir /c/\"work space\"\n    $ rmdir /c/work\\ space\n\n用引号括起来带有空格的文件名或者使用反斜杠来转义空格。\n\n##### Git #####\n\nGit的安装很分散[12]，每种平台都不一样，Linux中也分为两种使用yum或者apt-get来安装：\n\n    // as Fedora\n    $ yum install git-core\n    // as Ubuntu\n    $ apt-get install git\n\nMac上是最简单的，在这里安装[http://code.google.com/p/git-osx-installer](http://code.google.com/p/git-osx-installer)\n\nWindows也很方便，因为有了[Msysgit](http://msysgit.github.com/)，也一样直接安装。\n\n##### 编辑器 #####\n\n编辑器是每个程序员最常用的工具，它在很大程度上决定了单纯Coding的效率。原来有人将Vim和Emacs奉为上古神器，不过我喜欢新的东西，SublimeText是目前编辑器中的新贵，拥有海量插件，使用Python编写，配置和操作都非常方便。可以到这里下载：\n\n* [SublimeText2](http://www.sublimetext.com/)\n\n现在第3版正在进行beta测试，但是由于升级为Python3，原来的插件都因为API更新的问题而无法使用了，相信在正式版发布后插件将会陆续升级。这是第三版的下载地址，不会覆盖第二版。\n\n* [SublimeText3](http://www.sublimetext.com/3)\n\n此外，虽然它是付费软件，不过作者好像从来不怕没有人付费，如果没有注册仅仅会偶尔在保存时弹出Lisence声明，但确认会弹出官方页面，点取消即可。好像还有破解版本的出现，不过作者已经这么大度了，用破解版好像有点说不过去。国内曾经还有人组织过团购，但是作者表示不存在团购一说，只有公司批量购买，最终只有不了了之，售价$70。\n\n##### 浏览器 #####\n\n作为前端最基本的环境，浏览器是必不可少的。Chrome是我最喜欢的浏览器，因为它的快速高效以及很棒的开发者工具。虽然Firefox也是一款出色的浏览器，但Firebug作为一款插件，效率总是差那么一点，当然Firefox现在也推出了自己的调试工具。用于测试的IE浏览器也是常备工具之一，此外还有Opera和Safari。\n\nChrome和Firefox很强大的一个原因就是，它们对W3C的标准都很快速的支持，许多最新的特性都可以体现在最新版的Chrome以及Firefox中。特别需要一说的是，它们都有一个每日更新的版本，用户可以体验到最新的功能，而浏览器厂商可以获取崩溃信息等反馈来提高品质。Chrome的每日更新版叫[Chrome Canary](https://www.google.com/intl/zh-CN/chrome/browser/canary.html),Firefox的比较直接，[Firefox Nightly](http://nightly.mozilla.org/)。\n\n还有一款很神奇的浏览器，它不会渲染，也没有界面，基于Webkit内核，它叫[PlantomJS](http://phantomjs.org/index.html)，图标的幽灵和名字都突出了这一特点。也许看起来没什么用，但在测试或者做研究时，浏览器不厌其烦的弹出来时，它就有大用处了。\n\n### 自动化开发 ###\n\n##### Yeoman #####\n\nYeoman按照官方说法[3]，它不只是一个工具，还是一个工作流。它其实包括了三个部分yo、grunt、bower，分别用于项目的启动、文件操作、包管理。但我并不太认同这是一个工作流的说法，至少目前来看还不够成熟，在真实的生产环境中会遇到许多问题。而未来的可能性大致应该有两条路可走，也许会产生某些工作流的标准来定义前端开发的软件质量，不过我更认为Yeoman应该走向高可定制的工作流工具的方向，而不是自身作为一个工作流来存在。\n\n###### Yo ######\n\nYo是一个项目初始化工具，可以生成一套启动某类项目必须的项目文件。可以通过npm安装它到全局：\n\n    npm install -g yo\n\n然后还需要安装一些generator，这是一个用于创建某个指定类型项目的生成器。比如安装一个最常用的webapp的生成器，然后就可以在项目路径下生成项目启动需要的所有文件，像这样：\n\n    npm install -g generator-webapp\n    cd /project_folder/\n    yo webapp\n\n但是这种机制有一个很严重的问题，generator产生的文件结构是谁制定的？没有一个官方的相应的标准或者说Guide，generator的形式参差不齐，甚至我发现Firefox OS的generator生成的是一个API接口的Demo而不是一个种子，如果要进行开发需要进行很多删减。\n\n不过产生这些generator的generator[4]却是一个很好的工具，它应该是一个创造性的工具。首先需要安装generator-generator，然后使用它，接着会看到字符拼接的yeoman，像这样：\n\n    npm install -g yo generator-generator\n    $ mkdir ~/dev/generator-blog && cd $_\n    $ yo generator\n\n        _-----_\n       |       |\n       |--(o)--|   .--------------------------.\n      `---------´  |    Welcome to Yeoman,    |\n       ( _´U`_ )   |   ladies and gentlemen!  |\n       /___A___\\   '__________________________'\n        |  ~  |\n      __'.___.'__\n    ´   `  |° ´ Y `\n\n当然使用它之前应该将写好的项目文件放入 `app/templates` 文件夹中，并在 `templates` 同级的路径中加入 `index.js` 进行配置就可以了。这里的index.js是运行在Nodejs中的，也就是说由它将templates中的项目文件放入该放的地方并且填入一些变量去构建整个项目。这里才是体现一个generator是否是一个好的generator的地方，如果仅仅是将一堆写好的项目文件下载下来那什么意义也没有，不存在万用种子。只有在使用generator生成项目时高度定制才是其意义所在，而相关标准才是最难的部分。\n\n##### Bower #####\n\nBower是一个类似于npm的包管理器，但不同的是Bower主要针对前端，并且直接从Github查找需要的库下载到本地缓存。使用很简单，用npm安装bower后可以安装Github的项目并指定版本号，还可以重命名。默认会下载到项目中的 `bower_components` 文件夹中。[5]\n\n    npm install -g bower\n    bower install jQuery\n    bower install jQuery#1.10.3\n    bower install jQueryOld=jQuery#1.6.4\n\n还可以通过bower.json文件来配置需要安装的包，使用 `bower init` 命令就可以生成bower.json文件，然后在其中写入需要的包及其版本即可\n\n    {\n      \"name\": \"my_project\",\n      \"version\": \"0.1.0\",\n      \"main\": [js/js.js, css/css.css],\n      \"ignore\": [\n        \".jshintrc\",\n        \"**/*.txt\"\n      ],\n      \"dependencies\": {\n        \"<name>\": \"<version>\",\n        \"<name>\": \"<folder>\",\n        \"<name>\": \"<package>\"\n      },\n      \"devDependencies\": {\n        \"<test-framework-name>\": \"<version>\"\n      }\n    }\n\n当然它也可以搜索包，像这样搜索一下jquery。\n\n    bower search jquery\n\n如果觉得bower_components的文件夹名太长不好，可以在 `.bowerrc` 中以json的形式修改它的路径\n\n    {\n      \"directory\": \"lib\"\n    }\n\n还有许多其他的配置，可以在Bower存放在Google Doc的文档[7]中查看。\n\n但是Bower还有一个Bug[6]，jQuery在Github上的项目文件是分模块的，必须使用项目中的Grunt才能打包成jquery.js文件，而官方的说法是使用小写q的 `jquery` 来获取components项目中的jquery文件，但是目前Bower是大小写不分的，所以无法获取独立的jQuery文件。如果bower可以指定获取某个项目中的某个或某些指定的文件将会更加犀利。\n\n甚至Bower可以在Nodejs中运行一个 `bower.commands` 文件来让你编写安装各种包的node程序，并且可以监听 `end` 事件在安装结束后进行操作，这是异步的，这样就可以随心所欲的安装包和控制顺序了。\n\n    var bower = require('bower');\n    bower.commands\n        .install(['jquery'], { save: true }, { /* custom config */ })\n        .on('end', function (installed) {\n            console.log(installed);\n    });\n\n##### Grunt #####\n\nGrunt目前来说是这三个Yeoman中最成熟最强大的，最关键的是Grunt有各种各样的插件，可以集成大部分能想得到的开发工具来进行自动化开发。另外Grunt的作者还开发了一整套的插件来适应常规的开发，这套插件以 `grunt-contrib-` 为前缀（下文中如无特殊说明，均指带有该前缀的插件名），除了文件的基本操作，还包括有测试、编译、压缩、代码检查等各种功能的插件，而且不止一个选择。\n\n安装Grunt和Bower不太一样[8]，需要先在全局安装一个Grunt的客户端，然后在每个项目中安装Grunt。\n\n    npm install -g grunt-cli\n    cd /project/\n    npm install grunt\n\n不过和Bower相似的是，可以通过编写配置json文件来使用 `npm install` 来安装Grunt和所有需要的插件，另外Grunt的插件也都是npm管理的，所以可以直接在 `package.json` 中直接编写。\n\n    {\n        \"name\": \"myProject\",\n        \"version\": \"0.1.0\",\n        \"devDependencies\": {\n            \"grunt\": \"*\",\n            // other plugin...\n            \"grunt-contrib-watch\": \"*\"\n        }\n    }\n\n安装完成后在项目根目录中建立 `Gruntfile.js` 文件来配置Grunt的工作流程。下面以 `copy` 插件为例使用Grunt进行开发。在 `exports` 中Grunt会以参数形式被传入函数，它有3个方法， `initConfig` 、 `loadNpmTasks` 、 `registerTask`，分别用来定义插件操作，载入插件，注册任务。\n\n    module.exports = function (grunt) {\n        grunt.initConfig({\n            copy: {\n                main: {\n                    files: {\n                        src: ['path/**'], \n                        dest: 'dest/'\n                    }\n                }\n            }\n        });\n        grunt.loadNpmTasks('grunt-contrib-copy');\n        grunt.registerTask('default', ['copy']);\n    };\n\n在配置中以插件名为键定义一个Object作为该插件的配置，其中还可以再定义一层以任务名为键，比如 `main` ，然后是插件的部分，copy插件使用 `files` 来定义对文件的具体操作， `src` 是要复制的文件， `dest` 则是要复制到的路径。\n\n然后使用 `loadNpmTasks` 加载插件，需要写全名，包括grunt-contrib前缀。\n\n最后是注册一个任务，这里的任务即是执行操作时需要调用的东西。比如代码中注册了 `default` 任务，包括一个数组中的所有任务，这样在执行default任务时就会执行相应的所有任务。另外default是一个特殊的任务名，如果在执行任务时没有指定名称，则执行该任务。当然直接运行copy任务也是可以的，甚至可以指定一个子任务，比如main。所以下面4行代码是相同的效果。\n    \n    grunt\n    grunt default\n    grunt copy\n    grunt copy:main\n\n不过需要特别注意的是，注册的任务名不能和原有的任务相同，这样会报错，比如这样：\n\n    grunt.registerTask('copy', ['copy']);\n\n和copy类似的文件基本操作还有 `clean` 清除, `concat` 连接, `rename` 重命名, `compress` 打包, `crypt` 编码等等，相关的配置可以在npmjs.org上的对应项目介绍中找到。\n\n还有四个用于压缩的插件 `htmlmin` , `cssmin` , `uglify` , `imagemin` 分别对应HTML文件、CSS文件、JS文件和图片文件；以及两个用于检查代码的插件 `csslint` , `jshint` 分别检查CSS代码和JS代码。\n\n当然，最重要的是，Grunt可以编译一些CSS和JS的其他形式代码。`coffee` 用于编译CoffeeScript，而CSS就更多了，比如[SASS](http://sass-lang.com/)可以使用 `compass` 或者 `sass`, 还有 `less` 和 `stylus`，我最喜欢的是[Stylus](http://learnboost.github.io/stylus/)，因为它使用的是Javascript来编译，而不像SASS是Ruby编译的，还需要准备Ruby的环境，非常麻烦。而且在Stylus中还可以写类似JS的条件语句和循环语句。这个国旗icon的项目很好的使用了Stylus以很短的代码完成了上百个国家的图标的CSS Sprite - [National Flag on Github](https://github.com/tychio/national_flag/blob/master/country.styl)。还有许多种Javascript模板的预编译插件，`haml` , `jst` , `jade` , `hogan` 等等。\n\n除了用于编码的插件，还有许多用于测试的插件，在grunt-contrib中提供了三个测试框架的插件， `nodeunit` 用于Nodejs，`qunit` 用于Qunit，是来自jQuery团队的测试框架，还有Junit的后继者 `jasmine`。另外Mocha也有自己的Grunt插件 `grunt-mocha` 。用于捕获多个浏览器测试框架karma也有相应的插件 `grunt-karma` 。\n\n此外，contrib中还有一些其他插件，比如 `connect` 用于http等协议的请求，支持https， `commands` 用于执行shell命令， `manifest`\n 用于生成离线应用所需的 `manifest.appcache` 文件，还有用于插件YUI文档的 `yuidoc` 。\n\n最最重要的一个插件就是 `watch` ，它可以随时监听某些指定的文件，当它们发生改变时执行相应的任务。再次使用copy做例子，添加watch任务后可以在原有文件发生改变时，将复制过去的副本也同步改变。\n\n    module.exports = function (grunt) {\n        grunt.initConfig({\n            watch: {\n                copy: {\n                    files: 'path/**',\n                    tasks: 'copy'\n                }\n            },\n            copy: {\n                main: {\n                    files: {\n                        src: ['path/**'], \n                        dest: 'dest/'\n                    }\n                }\n            }\n        });\n        grunt.loadNpmTasks('grunt-contrib-copy');\n        grunt.loadNpmTasks('grunt-contrib-watch');\n        grunt.registerTask('default', ['copy', 'watch']);\n    };\n\n由此，项目开发中的大部分工作都交由程序代替了人工，Yo和Bower可以快速的启动一个项目，Grunt在开发中可以自动化的持续完成编码中重复性的工作以及自动化检查和测试代码以提高质量。\n\n### 开发工具 ###\n\n##### SublimeText #####\n\n在自动化开发的前提下，仍然有很多编码工作是需要亲手完成的，此时编辑器的效率决定了剩下的开发效率。SublimeText一款很棒的编辑器，通过配置和插件的选择可以达到几乎所有需求。\n\n首先从GUI来说，ST的侧边栏可以随意的拖入文件夹并对其进行操作，而文本区则可以选择多种组合方式，包括网格、最多四栏、最多四列的布局。其滚动条也已经不是一个条了，而是一个代码的缩略图，拖动起来非常方便和清晰。每个文件的标签就像Chrome一样可以随意的拖出拖入。此外，代码的颜色样式可以有几十种方案供选择，还可以下载针对每种语言的颜色方案，目前我知道的仅有最新的Stylus的styl文件没有对应的颜色方案。\n\n在功能方面，ST最大的特色之一就是会自动生成一份正在打开的文件的拷贝，而且会自动保存，也就是说即使是断电关机，重新打开后原本打开的文件也还是存在不会丢失任何代码。其次，多处编辑也是非常的强大，在代码中选择多处后会出现多个光标，可以同时编辑，而选中一个词后，按 `Ctrl+D` 就可以多选下一个相同的代码。另外通过 'Ctrl+P' 可以搜索文件，配合 `@` 或者直接按 `Ctrl+R` 就可以前往指定的方法和函数，配合 `:` 或者直接按 `Ctrl+G` 就可以前往指定的行数。按住 `Shift+Ctrl+Up/Down` 就可以移动选中行的代码上下移动。其他编辑都有的一般的快捷键自然也都有。\n\n不过最强大的是，这些功能都可以利用插件实现，比如Emmet也就是大名鼎鼎的Zencoding的继任者就可以通过插件指定一个命令并分配一个快捷键来实现。我还喜欢使用Markdown preview，比如现在我就可以通过它预览一下博客的大致效果。还有刚刚提到的针对每种语言的颜色高亮方案也是插件的形式。还有一款老牌版本控制的工具Tortoise，因为公司还在用SVN这种老古董，Tortoise自然成了不二选择。还有很多插件，可以从官方网站搜索。\n[https://sublime.wbond.net/search/](https://sublime.wbond.net/search/)\n\n说到插件，自然少不了管理它的工具，SublimeText的管理工具是Package Control，原来的安装十分麻烦，不过现在官方给出了方法。使用 `Ctrl+~` 打开控制台，然后复制[这里官方给出的代码](https://sublime.wbond.net/installation)到控制台并执行，Package Control就安装好了。之后使用 `Ctrl+Shift+P` 调出命令面板后就会有一组Package Control的命令，主要会用到 `install` 和 `remove`\n两个用于安装和卸载插件。\n\n关于用户配置，有很多内容，可以参考 `Settings - Default` 。比如这样：\n\n    {\n        \"caret_style\": \"phase\",\n        \"font_size\": 16.0,\n        \"overlay_scroll_bars\": \"enabled\",\n        \"save_on_focus_lost\": true,\n        \"scroll_past_end\": false,\n        \"tab_size\": 4,\n        \"translate_tabs_to_spaces\": true,\n        \"word_wrap\": true,\n        \"wrap_width\": 80\n    }\n\n这些配置看到名字就基本可以猜出意思了，主要是wrap_width就是每行的字符数，设置到80，这样可以保持代码的简短，避免长语句。而translate_tabs_to_spaces就是用空格代替制表符。\n\n##### Chrome #####\n\n我始终喜欢Chrome多过Firefox，因为Chrome的启动速度比Firefox快上许多，Firefox原先有点过于臃肿了，不按标准的地方也不少，虽然后来在Google注资之后，不但版本号追了上来，功能也提升很多。不过Chrome仍是我开发的主要环境，Firefox一般仅作为研究和测试之用。\n\nChrome的开发者工具界面非常清爽，无论是在Elements中的HTML还是Sources中的Js，代码阅读和编辑都非常方便，而且在Element中可以修改和添加对应元素的CSS代码，而在Sources中可以直接修改CSS文件。Resources中列出了所有加载的文件，还有session、cookie和本地存储之类的缓存信息，可以方便的对其进行操作。而Network则列出了所有请求，以及相关的信息，甚至可以点击下面的圆点按钮 `preserve log upon Navigation` 进行请求响应时间的监视。在Timeline中还有更详细的时间监视，包括事件、加载以及内存的使用状况，可以方便的对程序的性能进行调试。在Profiles中可以对Js、CSS、DOM进行统计。还有Audits可以对网站性能和网络性能进行统计。\n\n最重要的是Console[11]，在这里可以直接写入Javascript代码进行调试，还可以收集到程序中输出的各种信息和报错。不过最特别的是它是有API的可编程。一般常用到 `log` 方法，像下面的代码这样来输出一些变量，当然还有不同的类型，比如 `error` 方法、 `warn` 方法。它们的参数也很自由，多个参数将会被空格连接输出，还可以在第一个参数中使用占位符来按类型加入后面的参数。\n\n    console.log('hello ' + world);\n    console.error('Error:', 'nothing...');\n    console.warn('Warn: %s < %d', 'age', 18);\n\n除了上面三个方法以及类似log的 `info` 和 `debug` 方法还有一个特别的方法，那就是断言 `assert` 方法，它可以判断条件，在false时报错，一般用于测试。\n\n另外还有三个关于时间的方法， `time` ， `timeEnd` 和 `timeStamp` 。time和timeEnd配合使用可以记录程序运行的时间并输出，而timeStamp可以在Timeline的统计中标出一个时间点。\n\nChrome的插件也非常的多，这里介绍三款和页面密切相关的工具。\n\n[Visual Event](https://chrome.google.com/webstore/detail/visual-event/pbmmieigblcbldgdokdjpioljjninaim) 是一个捕获页面事件的插件，它会将页面所有绑定的事件全部以可视化的方式呈现出来，并且可以点击查看某个元素的事件详细信息。我经常用来检查事件是否正确的绑定到了目标元素上。\n\n[Edit This Cookie](https://chrome.google.com/webstore/detail/edit-this-cookie/fngmhnnpilhplaeedifhccceomclgfbg) 顾名思义，用来编辑Cookie的，虽然DevTools也带有这样的功能，但是它更加便利，还可以导出导入，随意修改每个Cookie中的任意条目。虽然它很强大，不过好像利用率最高的功能是一键清空Cookie。\n\n[Code Cola](https://chrome.google.com/webstore/detail/code-cola/lomkpheldlbkkfiifcbfifipaofnmnkn) 可以用来修改CSS，与DevTools不同的是，它的操作是左右滑动滑块，而且主要针对CSS3的空间样式，可以快速将元素变成各种角度各种尺寸。\n\n不过Chrome还是有弱点的，当tab开的太多时会非常卡，因为Chrome每个tab都是一个单独的进程。所以还有一个插件也是很有用的，虽然和开发没有太大关系，[One Tab](https://chrome.google.com/webstore/detail/onetab/chphlpgkkbolifaimnlloiipkdnihall) 可以把当前的所有tab都集合起来变成一个页面，当需要打开时在点击链接即可，这样有效防止了过多tab造成的内存不足问题。\n\n### 代码管理 ###\n\n##### Git #####\n\n关于Git Workflow的讨论很多，最著名的当属[Vincent Driessen](http://nvie.com/)的那篇博客[13]。Vincent的工作流的结构很棒，首先有2个主要分支，`master` 和 `develop`，分别是主分支和开发分支。然后还有3类次分支，它们可能数量很多，并且不会长时间存在，分别是开发新功能用的feature，发布用的release和修复bug用的hotfix。大致的Git操作可以理解为这样：\n\n    # create branch\n    git checkout -b develop master\n    git checkout -b feature develop\n    # commit something\n    git add widget.js\n    git commit -m \"add a function\"\n    # merge to develop\n    git checkout develop\n    git merge --no-ff feature\n    # delete branch\n    git branch -d feature\n\n首先创建开发分支 `develop` ，然后再从开发分支创建一个次分支，接着提交代码并注释提交，合并会开发分支 `develop` ，最后删除这个临时的次分支。--no-ff的意思是不使用快速合并。其他开发过程中也是大同小异，release分支还有hotfix分支可能需要在确认没问题时合并到develop和master两个分支中然后删除。\n\n不过这个工作流是考虑到团队开发而设计的，很标准简约，但细节不足。而[Benjamin Sandofsky](https://sandofsky.com)的文章[14]则更加趋向于对commit的管理，也许不能算做工作流，至少算是一种理念。他强调一定要保留有一个私人的分支只存在于本地，然后在合并到主分支时清除原本的commit log。这里会用到一个 `merge` 命令的参数 `--squash` 这样合并后不会带来任何commit log。\n\n    # create brach\n    git checkout -b private master\n    # commit something\n    git add widget.js\n    git commit -m \"add a function\"\n    # merge brach but don't commit\n    git checkout master\n    git merge --squash private\n    # commit once\n    git commit -m \"only this commit\"\n\n但我认为Git工作流和其他一切工程过程一样，不存在银弹。不过这种合并的方式可以成为一种很好的操作流来完成属于每个人自己的工作流。另外从这两种不同风格的Git工作流中也许能找出一些有趣的点。以下是我的看法：\n\n* 主分支数由开发流程复杂度决定，而开发流程复杂度应该由项目主管根据项目规模确定，所以项目规模决定了主分支数，除了develop也许还需要test、build等等。\n\n* 次分支数由人员和实际情况决定，bug数会决定hotfix的数量，也许产品经理会决定feature的数量，多个不同版本的同类产品也可能会增加release的数量。如果项目规模足够大时，几个小组解决一个问题时也会产生多个临时分支。\n\n* 多人协作以及长时间开发都可能导致日志混乱无法管理，使用squash参数配合临时分支可以清理对别人不必要的commit信息。\n\n* 应使用--no-ff可以避免快速合并，使每次合并等于一次提交，记录在log中，保持分支健康。\n\n因此，在实际开发的工作流中应该按照实际情况创建分支，但应按照以上规范合并分支。\n\n##### Github #####\n\nGithub不止是每个Coder的FaceBook，还是一个非常棒的远程Git仓库，甚至有很多小组将生产项目托管在上面。其实Github上和Git没有太多差别，只是多了一个远程仓库Remote的操作，另外相信每个初入Github的新手都为私钥公钥头疼了好久，下文将会讨论Github的仓库创建和日常操作两部分。\n\n首先需要在本地建立与Github帐户的联系，在shell中安装SSH，然后像这样使用SSH安装SSH密钥：\n\n    ssh-keygen -t rsa -C \"your_email@example.com\"\n    # Creates a new ssh key, using the provided email as a label\n    # Generating public/private rsa key pair.\n    # Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): [Press enter]\n    ssh-add id_rsa\n\n然后会让你输入一个密码，随意输入就可以了，接着就会生成一个公钥一个私钥。在用户文件夹下的 `.ssh` 文件夹中找到id_rsa.pub，这个文件里就是公钥，复制里面的内容，然后在Github的Account Settings中的SSH Key页面，点击Add SSH Key按钮，输入一个用于说明的title，接着粘贴公钥到Key中就可以了。\n\n然后必须在Github上点击 `Create a new repo` 按钮来创建一个空项目。当然如果选择适当的选项就可以自动生成README文件、Git忽略文件和版权分享声明文件。之后该项目会有一个仓库的地址，可以使用HTTPS和SSH，甚至还有SVN地址：\n\n    https://github.com/<username>/<reponame>.git\n    git@github.com:<username>/<reponame>.git\n    https://github.com/<username>/<reponame>\n\n以我的一个对话框jQ插件为例，首先在项目中初始化git，然后添加一个远程仓库，然后就可以往上面提交代码了。\n\n    git remote add myGithub https://github.com/tychio/dialog.git\n    git push myGithub master\n\n因为我使用的HTTPS方式提交，之后会需要输入用户名和密码，如果使用SSH方式则用使用公钥而无需额外操作。使用HTTPS纯属为了记住Github的密码，每天都在敲就不会忘记了。\n\n### 总结 ###\n\n工作流应该是一个人最习惯和熟悉的流程，而不应该是照猫画虎，邯郸学步。还是那句话，不存在银弹，所以不会有万用的工作流，只能从中汲取有用的实践，完善改进自己的工作流，达到提高工作效率的目的。\n\n和学习其他技术一样，应用于工作流之中的工具有无数种，但真正需要和适合的只有自己知道，发现问题，带着问题寻找工具才能真的改进工作流。如果仅仅为了使用前沿的工具而使用，只会使自己的工作效率大打折扣。记得两年前我还在疯狂的复制代码，每当我意识到不能再这样下去的时候，工作流就会自己进化，合适的工具近在眼前，工作效率逐渐提升。我发现问题实在是很好的老师，可以让一个人快速的成长，解决它就可以获得一次提升。\n\n永远有人有跟你相同的问题，永远有能解决你当前问题的工具，善于使用问题来选择它们就能打造更完善的工作流。如果遇到没有工具能解决的问题，那说明造轮子的时机到了。\n\n### 参考文档 ###\n\n1. [NPM Readme](https://npmjs.org/doc/README.html)\n\n2. [MSYS Wiki](http://www.mingw.org/wiki/MSYS)\n\n3. [Yeoman home](http://yeoman.io/)\n\n4. [Yeoman generators](http://yeoman.io/generators.html)\n\n5. [Bower home](http://bower.io/)\n\n6. [Bower jquery bug](https://github.com/bower/bower/issues/859)\n\n7. [Bower configuration](https://docs.google.com/document/d/1APq7oA9tNao1UYWyOm8dKqlRP2blVkROYLZ2fLIjtWc/edit#heading=h.4pzytc1f9j8k)\n\n8. [Grunt getting started](http://gruntjs.com/getting-started)\n\n9. [Top 10 SublimeText2 plugins](http://www.henriquebarroso.com/my-top-10sublime-2-plugins/)\n\n10. [Install package control](https://sublime.wbond.net/installation)\n\n11. [Using the console API](https://developers.google.com/chrome-developer-tools/docs/console#using_the_console_api)\n\n12. [Getting Started Installing Git](http://git-scm.com/book/en/Getting-Started-Installing-Git)\n\n13. [A successful Git branching model](http://nvie.com/posts/a-successful-git-branching-model/)\n\n14. [Understanding the Git Workflow](https://sandofsky.com/blog/git-workflow.html)\n\n15. [Generating SSH Keys](https://help.github.com/articles/generating-ssh-keys)","slug":"improve-workflow","published":1,"date":"2013-09-24T16:00:00.000Z","updated":"2021-11-28T11:37:27.160Z","comments":1,"photos":[],"link":"","_id":"ckwj65514000mvyjh6tk37pve","content":"<p>有人说过程序员和码农的本质区别就是程序员会不断探索提高生产力的方法。思维模式的转变是提高生产力的最好方式，但打磨我们的工具也是十分有意义的事，本文将从开发环境，自动化开发，开发工具等几个方面针对前端开发效率的提升和代码质量的提高来展开讨论。</p>\n<p>每件事都是一个程序，开发也像程序一样，每个步骤都是一段代码，当开发规模随着文档、代码、需求而增加时，重复的步骤变得越来越多。此时，如果可以像抽象代码一样抽象出一些相同操作就可以大大提升开发效率。因此，出现了更多更优质的工具来代替人工做一些不断重复的开发以减少程序员的工作量。</p>\n<span id=\"more\"></span>\n<h3 id=\"开发环境\"><a href=\"#开发环境\" class=\"headerlink\" title=\"开发环境\"></a>开发环境</h3><h5 id=\"Nodejs\"><a href=\"#Nodejs\" class=\"headerlink\" title=\"Nodejs\"></a>Nodejs</h5><p>首先，需要搭建一个自动化高效率的开发环境。以前我们有shell、java、ruby来进行一些自动化脚本的执行。但自从Nodejs将Javascript带入了服务器，Front End开发环境也发生了翻天覆地的变化。Nodejs不仅仅可以让Jser开发服务端，还让Javascript成为了服务器脚本语言之一，可以用于文件的操作。</p>\n<p>安装Nodejs的方法目前来说很简单，<a href=\"http://nodejs.org/download/\">点这里下载安装包</a>，选择对应的平台的安装包即可。不过不得不说的是Source Code包，这是源码需要编译，虽然由C++写成，但gyp进行管理，所以编译时需要Python2.6+和C++编译器一起工作。通过命令 <code>node -v</code> 来检验是否安装成功，成功则返回当前版本号。</p>\n<p>另外Nodejs还有一样必备的工具npm，就像ruby中的gem一样，是一个Nodejs的包管理器，可以为Nodejs添加一些包。npm的安装非常简单[1]，可以说不用安装，在Linux下只有一行命令： <code>make install</code><br>, 而Windows和Mac都默认带有npm。当然如果想专门安装npm也是可以的，Linux下仍然是一行代码：</p>\n<pre><code>curl https://npmjs.org/install.sh | sudo sh\n</code></pre>\n<p>而Windows会稍微麻烦一点，在<a href=\"https://npmjs.org/dist/\">https://npmjs.org/dist/</a>下载源码，然后放到和node.exe一个文件夹下即可。</p>\n<p>使用npm来安装一些包很简单，使用这样的命令 <code>npm install &lt;package_name&gt;</code> ，一般来说会默认安装在当前目录中。但如果使用参数 <code>-g</code> 就可以安装在全局。另外通过在项目中添加一个 <code>package.json</code> 文件，就可以定义项目依赖的Nodejs包，然后直接在该目录中执行 <code>npm install</code> 指令就会将package文件指定的包全部安装在当前目录。</p>\n<h5 id=\"Shell\"><a href=\"#Shell\" class=\"headerlink\" title=\"Shell\"></a>Shell</h5><p>不管是Linux还是Mac都天然的拥有Shell环境，但是Windows中的CMD是无法和Shell相提并论的，而且很多开发工具也需要Shell环境。</p>\n<p>还好Windows中有MSYS[2]，全称是Minimal GNU（POSIX）system on Windows，它是一个GNU工具集，包括了bash，make，gawk和grep。可以直接下载 </p>\n<p><a href=\"http://www.mingw.org/wiki/MSYS\">http://www.mingw.org/wiki/MSYS</a></p>\n<p>如果需要整个Unix环境和C的库的话，还需要minGW。也可以直接安装Git Bash工具，会附带有这个，这样环境和Git就会一起装好。</p>\n<p><a href=\"http://git-scm.com/downloads\">http://git-scm.com/downloads</a></p>\n<p>另外在Windows中使用Shell时，有几点需要注意。文件路径的根目录为Git Bash的文件根路径，但是可以使用斜杠和盘符代表Windows的磁盘，比如进入D盘下的workspace文件夹就这样：</p>\n<pre><code>$ cd /d/workspace/\n</code></pre>\n<p>而Windows特有的文件夹名称中带有空格的问题可以通过两个方法解决。</p>\n<pre><code>$ mkdir /c/&quot;work space&quot;\n$ rmdir /c/work\\ space\n</code></pre>\n<p>用引号括起来带有空格的文件名或者使用反斜杠来转义空格。</p>\n<h5 id=\"Git\"><a href=\"#Git\" class=\"headerlink\" title=\"Git\"></a>Git</h5><p>Git的安装很分散[12]，每种平台都不一样，Linux中也分为两种使用yum或者apt-get来安装：</p>\n<pre><code>// as Fedora\n$ yum install git-core\n// as Ubuntu\n$ apt-get install git\n</code></pre>\n<p>Mac上是最简单的，在这里安装<a href=\"http://code.google.com/p/git-osx-installer\">http://code.google.com/p/git-osx-installer</a></p>\n<p>Windows也很方便，因为有了<a href=\"http://msysgit.github.com/\">Msysgit</a>，也一样直接安装。</p>\n<h5 id=\"编辑器\"><a href=\"#编辑器\" class=\"headerlink\" title=\"编辑器\"></a>编辑器</h5><p>编辑器是每个程序员最常用的工具，它在很大程度上决定了单纯Coding的效率。原来有人将Vim和Emacs奉为上古神器，不过我喜欢新的东西，SublimeText是目前编辑器中的新贵，拥有海量插件，使用Python编写，配置和操作都非常方便。可以到这里下载：</p>\n<ul>\n<li><a href=\"http://www.sublimetext.com/\">SublimeText2</a></li>\n</ul>\n<p>现在第3版正在进行beta测试，但是由于升级为Python3，原来的插件都因为API更新的问题而无法使用了，相信在正式版发布后插件将会陆续升级。这是第三版的下载地址，不会覆盖第二版。</p>\n<ul>\n<li><a href=\"http://www.sublimetext.com/3\">SublimeText3</a></li>\n</ul>\n<p>此外，虽然它是付费软件，不过作者好像从来不怕没有人付费，如果没有注册仅仅会偶尔在保存时弹出Lisence声明，但确认会弹出官方页面，点取消即可。好像还有破解版本的出现，不过作者已经这么大度了，用破解版好像有点说不过去。国内曾经还有人组织过团购，但是作者表示不存在团购一说，只有公司批量购买，最终只有不了了之，售价$70。</p>\n<h5 id=\"浏览器\"><a href=\"#浏览器\" class=\"headerlink\" title=\"浏览器\"></a>浏览器</h5><p>作为前端最基本的环境，浏览器是必不可少的。Chrome是我最喜欢的浏览器，因为它的快速高效以及很棒的开发者工具。虽然Firefox也是一款出色的浏览器，但Firebug作为一款插件，效率总是差那么一点，当然Firefox现在也推出了自己的调试工具。用于测试的IE浏览器也是常备工具之一，此外还有Opera和Safari。</p>\n<p>Chrome和Firefox很强大的一个原因就是，它们对W3C的标准都很快速的支持，许多最新的特性都可以体现在最新版的Chrome以及Firefox中。特别需要一说的是，它们都有一个每日更新的版本，用户可以体验到最新的功能，而浏览器厂商可以获取崩溃信息等反馈来提高品质。Chrome的每日更新版叫<a href=\"https://www.google.com/intl/zh-CN/chrome/browser/canary.html\">Chrome Canary</a>,Firefox的比较直接，<a href=\"http://nightly.mozilla.org/\">Firefox Nightly</a>。</p>\n<p>还有一款很神奇的浏览器，它不会渲染，也没有界面，基于Webkit内核，它叫<a href=\"http://phantomjs.org/index.html\">PlantomJS</a>，图标的幽灵和名字都突出了这一特点。也许看起来没什么用，但在测试或者做研究时，浏览器不厌其烦的弹出来时，它就有大用处了。</p>\n<h3 id=\"自动化开发\"><a href=\"#自动化开发\" class=\"headerlink\" title=\"自动化开发\"></a>自动化开发</h3><h5 id=\"Yeoman\"><a href=\"#Yeoman\" class=\"headerlink\" title=\"Yeoman\"></a>Yeoman</h5><p>Yeoman按照官方说法[3]，它不只是一个工具，还是一个工作流。它其实包括了三个部分yo、grunt、bower，分别用于项目的启动、文件操作、包管理。但我并不太认同这是一个工作流的说法，至少目前来看还不够成熟，在真实的生产环境中会遇到许多问题。而未来的可能性大致应该有两条路可走，也许会产生某些工作流的标准来定义前端开发的软件质量，不过我更认为Yeoman应该走向高可定制的工作流工具的方向，而不是自身作为一个工作流来存在。</p>\n<h6 id=\"Yo\"><a href=\"#Yo\" class=\"headerlink\" title=\"Yo\"></a>Yo</h6><p>Yo是一个项目初始化工具，可以生成一套启动某类项目必须的项目文件。可以通过npm安装它到全局：</p>\n<pre><code>npm install -g yo\n</code></pre>\n<p>然后还需要安装一些generator，这是一个用于创建某个指定类型项目的生成器。比如安装一个最常用的webapp的生成器，然后就可以在项目路径下生成项目启动需要的所有文件，像这样：</p>\n<pre><code>npm install -g generator-webapp\ncd /project_folder/\nyo webapp\n</code></pre>\n<p>但是这种机制有一个很严重的问题，generator产生的文件结构是谁制定的？没有一个官方的相应的标准或者说Guide，generator的形式参差不齐，甚至我发现Firefox OS的generator生成的是一个API接口的Demo而不是一个种子，如果要进行开发需要进行很多删减。</p>\n<p>不过产生这些generator的generator[4]却是一个很好的工具，它应该是一个创造性的工具。首先需要安装generator-generator，然后使用它，接着会看到字符拼接的yeoman，像这样：</p>\n<pre><code>npm install -g yo generator-generator\n$ mkdir ~/dev/generator-blog &amp;&amp; cd $_\n$ yo generator\n\n    _-----_\n   |       |\n   |--(o)--|   .--------------------------.\n  `---------´  |    Welcome to Yeoman,    |\n   ( _´U`_ )   |   ladies and gentlemen!  |\n   /___A___\\   &#39;__________________________&#39;\n    |  ~  |\n  __&#39;.___.&#39;__\n´   `  |° ´ Y `\n</code></pre>\n<p>当然使用它之前应该将写好的项目文件放入 <code>app/templates</code> 文件夹中，并在 <code>templates</code> 同级的路径中加入 <code>index.js</code> 进行配置就可以了。这里的index.js是运行在Nodejs中的，也就是说由它将templates中的项目文件放入该放的地方并且填入一些变量去构建整个项目。这里才是体现一个generator是否是一个好的generator的地方，如果仅仅是将一堆写好的项目文件下载下来那什么意义也没有，不存在万用种子。只有在使用generator生成项目时高度定制才是其意义所在，而相关标准才是最难的部分。</p>\n<h5 id=\"Bower\"><a href=\"#Bower\" class=\"headerlink\" title=\"Bower\"></a>Bower</h5><p>Bower是一个类似于npm的包管理器，但不同的是Bower主要针对前端，并且直接从Github查找需要的库下载到本地缓存。使用很简单，用npm安装bower后可以安装Github的项目并指定版本号，还可以重命名。默认会下载到项目中的 <code>bower_components</code> 文件夹中。[5]</p>\n<pre><code>npm install -g bower\nbower install jQuery\nbower install jQuery#1.10.3\nbower install jQueryOld=jQuery#1.6.4\n</code></pre>\n<p>还可以通过bower.json文件来配置需要安装的包，使用 <code>bower init</code> 命令就可以生成bower.json文件，然后在其中写入需要的包及其版本即可</p>\n<pre><code>&#123;\n  &quot;name&quot;: &quot;my_project&quot;,\n  &quot;version&quot;: &quot;0.1.0&quot;,\n  &quot;main&quot;: [js/js.js, css/css.css],\n  &quot;ignore&quot;: [\n    &quot;.jshintrc&quot;,\n    &quot;**/*.txt&quot;\n  ],\n  &quot;dependencies&quot;: &#123;\n    &quot;&lt;name&gt;&quot;: &quot;&lt;version&gt;&quot;,\n    &quot;&lt;name&gt;&quot;: &quot;&lt;folder&gt;&quot;,\n    &quot;&lt;name&gt;&quot;: &quot;&lt;package&gt;&quot;\n  &#125;,\n  &quot;devDependencies&quot;: &#123;\n    &quot;&lt;test-framework-name&gt;&quot;: &quot;&lt;version&gt;&quot;\n  &#125;\n&#125;\n</code></pre>\n<p>当然它也可以搜索包，像这样搜索一下jquery。</p>\n<pre><code>bower search jquery\n</code></pre>\n<p>如果觉得bower_components的文件夹名太长不好，可以在 <code>.bowerrc</code> 中以json的形式修改它的路径</p>\n<pre><code>&#123;\n  &quot;directory&quot;: &quot;lib&quot;\n&#125;\n</code></pre>\n<p>还有许多其他的配置，可以在Bower存放在Google Doc的文档[7]中查看。</p>\n<p>但是Bower还有一个Bug[6]，jQuery在Github上的项目文件是分模块的，必须使用项目中的Grunt才能打包成jquery.js文件，而官方的说法是使用小写q的 <code>jquery</code> 来获取components项目中的jquery文件，但是目前Bower是大小写不分的，所以无法获取独立的jQuery文件。如果bower可以指定获取某个项目中的某个或某些指定的文件将会更加犀利。</p>\n<p>甚至Bower可以在Nodejs中运行一个 <code>bower.commands</code> 文件来让你编写安装各种包的node程序，并且可以监听 <code>end</code> 事件在安装结束后进行操作，这是异步的，这样就可以随心所欲的安装包和控制顺序了。</p>\n<pre><code>var bower = require(&#39;bower&#39;);\nbower.commands\n    .install([&#39;jquery&#39;], &#123; save: true &#125;, &#123; /* custom config */ &#125;)\n    .on(&#39;end&#39;, function (installed) &#123;\n        console.log(installed);\n&#125;);\n</code></pre>\n<h5 id=\"Grunt\"><a href=\"#Grunt\" class=\"headerlink\" title=\"Grunt\"></a>Grunt</h5><p>Grunt目前来说是这三个Yeoman中最成熟最强大的，最关键的是Grunt有各种各样的插件，可以集成大部分能想得到的开发工具来进行自动化开发。另外Grunt的作者还开发了一整套的插件来适应常规的开发，这套插件以 <code>grunt-contrib-</code> 为前缀（下文中如无特殊说明，均指带有该前缀的插件名），除了文件的基本操作，还包括有测试、编译、压缩、代码检查等各种功能的插件，而且不止一个选择。</p>\n<p>安装Grunt和Bower不太一样[8]，需要先在全局安装一个Grunt的客户端，然后在每个项目中安装Grunt。</p>\n<pre><code>npm install -g grunt-cli\ncd /project/\nnpm install grunt\n</code></pre>\n<p>不过和Bower相似的是，可以通过编写配置json文件来使用 <code>npm install</code> 来安装Grunt和所有需要的插件，另外Grunt的插件也都是npm管理的，所以可以直接在 <code>package.json</code> 中直接编写。</p>\n<pre><code>&#123;\n    &quot;name&quot;: &quot;myProject&quot;,\n    &quot;version&quot;: &quot;0.1.0&quot;,\n    &quot;devDependencies&quot;: &#123;\n        &quot;grunt&quot;: &quot;*&quot;,\n        // other plugin...\n        &quot;grunt-contrib-watch&quot;: &quot;*&quot;\n    &#125;\n&#125;\n</code></pre>\n<p>安装完成后在项目根目录中建立 <code>Gruntfile.js</code> 文件来配置Grunt的工作流程。下面以 <code>copy</code> 插件为例使用Grunt进行开发。在 <code>exports</code> 中Grunt会以参数形式被传入函数，它有3个方法， <code>initConfig</code> 、 <code>loadNpmTasks</code> 、 <code>registerTask</code>，分别用来定义插件操作，载入插件，注册任务。</p>\n<pre><code>module.exports = function (grunt) &#123;\n    grunt.initConfig(&#123;\n        copy: &#123;\n            main: &#123;\n                files: &#123;\n                    src: [&#39;path/**&#39;], \n                    dest: &#39;dest/&#39;\n                &#125;\n            &#125;\n        &#125;\n    &#125;);\n    grunt.loadNpmTasks(&#39;grunt-contrib-copy&#39;);\n    grunt.registerTask(&#39;default&#39;, [&#39;copy&#39;]);\n&#125;;\n</code></pre>\n<p>在配置中以插件名为键定义一个Object作为该插件的配置，其中还可以再定义一层以任务名为键，比如 <code>main</code> ，然后是插件的部分，copy插件使用 <code>files</code> 来定义对文件的具体操作， <code>src</code> 是要复制的文件， <code>dest</code> 则是要复制到的路径。</p>\n<p>然后使用 <code>loadNpmTasks</code> 加载插件，需要写全名，包括grunt-contrib前缀。</p>\n<p>最后是注册一个任务，这里的任务即是执行操作时需要调用的东西。比如代码中注册了 <code>default</code> 任务，包括一个数组中的所有任务，这样在执行default任务时就会执行相应的所有任务。另外default是一个特殊的任务名，如果在执行任务时没有指定名称，则执行该任务。当然直接运行copy任务也是可以的，甚至可以指定一个子任务，比如main。所以下面4行代码是相同的效果。</p>\n<pre><code>grunt\ngrunt default\ngrunt copy\ngrunt copy:main\n</code></pre>\n<p>不过需要特别注意的是，注册的任务名不能和原有的任务相同，这样会报错，比如这样：</p>\n<pre><code>grunt.registerTask(&#39;copy&#39;, [&#39;copy&#39;]);\n</code></pre>\n<p>和copy类似的文件基本操作还有 <code>clean</code> 清除, <code>concat</code> 连接, <code>rename</code> 重命名, <code>compress</code> 打包, <code>crypt</code> 编码等等，相关的配置可以在npmjs.org上的对应项目介绍中找到。</p>\n<p>还有四个用于压缩的插件 <code>htmlmin</code> , <code>cssmin</code> , <code>uglify</code> , <code>imagemin</code> 分别对应HTML文件、CSS文件、JS文件和图片文件；以及两个用于检查代码的插件 <code>csslint</code> , <code>jshint</code> 分别检查CSS代码和JS代码。</p>\n<p>当然，最重要的是，Grunt可以编译一些CSS和JS的其他形式代码。<code>coffee</code> 用于编译CoffeeScript，而CSS就更多了，比如<a href=\"http://sass-lang.com/\">SASS</a>可以使用 <code>compass</code> 或者 <code>sass</code>, 还有 <code>less</code> 和 <code>stylus</code>，我最喜欢的是<a href=\"http://learnboost.github.io/stylus/\">Stylus</a>，因为它使用的是Javascript来编译，而不像SASS是Ruby编译的，还需要准备Ruby的环境，非常麻烦。而且在Stylus中还可以写类似JS的条件语句和循环语句。这个国旗icon的项目很好的使用了Stylus以很短的代码完成了上百个国家的图标的CSS Sprite - <a href=\"https://github.com/tychio/national_flag/blob/master/country.styl\">National Flag on Github</a>。还有许多种Javascript模板的预编译插件，<code>haml</code> , <code>jst</code> , <code>jade</code> , <code>hogan</code> 等等。</p>\n<p>除了用于编码的插件，还有许多用于测试的插件，在grunt-contrib中提供了三个测试框架的插件， <code>nodeunit</code> 用于Nodejs，<code>qunit</code> 用于Qunit，是来自jQuery团队的测试框架，还有Junit的后继者 <code>jasmine</code>。另外Mocha也有自己的Grunt插件 <code>grunt-mocha</code> 。用于捕获多个浏览器测试框架karma也有相应的插件 <code>grunt-karma</code> 。</p>\n<p>此外，contrib中还有一些其他插件，比如 <code>connect</code> 用于http等协议的请求，支持https， <code>commands</code> 用于执行shell命令， <code>manifest</code><br> 用于生成离线应用所需的 <code>manifest.appcache</code> 文件，还有用于插件YUI文档的 <code>yuidoc</code> 。</p>\n<p>最最重要的一个插件就是 <code>watch</code> ，它可以随时监听某些指定的文件，当它们发生改变时执行相应的任务。再次使用copy做例子，添加watch任务后可以在原有文件发生改变时，将复制过去的副本也同步改变。</p>\n<pre><code>module.exports = function (grunt) &#123;\n    grunt.initConfig(&#123;\n        watch: &#123;\n            copy: &#123;\n                files: &#39;path/**&#39;,\n                tasks: &#39;copy&#39;\n            &#125;\n        &#125;,\n        copy: &#123;\n            main: &#123;\n                files: &#123;\n                    src: [&#39;path/**&#39;], \n                    dest: &#39;dest/&#39;\n                &#125;\n            &#125;\n        &#125;\n    &#125;);\n    grunt.loadNpmTasks(&#39;grunt-contrib-copy&#39;);\n    grunt.loadNpmTasks(&#39;grunt-contrib-watch&#39;);\n    grunt.registerTask(&#39;default&#39;, [&#39;copy&#39;, &#39;watch&#39;]);\n&#125;;\n</code></pre>\n<p>由此，项目开发中的大部分工作都交由程序代替了人工，Yo和Bower可以快速的启动一个项目，Grunt在开发中可以自动化的持续完成编码中重复性的工作以及自动化检查和测试代码以提高质量。</p>\n<h3 id=\"开发工具\"><a href=\"#开发工具\" class=\"headerlink\" title=\"开发工具\"></a>开发工具</h3><h5 id=\"SublimeText\"><a href=\"#SublimeText\" class=\"headerlink\" title=\"SublimeText\"></a>SublimeText</h5><p>在自动化开发的前提下，仍然有很多编码工作是需要亲手完成的，此时编辑器的效率决定了剩下的开发效率。SublimeText一款很棒的编辑器，通过配置和插件的选择可以达到几乎所有需求。</p>\n<p>首先从GUI来说，ST的侧边栏可以随意的拖入文件夹并对其进行操作，而文本区则可以选择多种组合方式，包括网格、最多四栏、最多四列的布局。其滚动条也已经不是一个条了，而是一个代码的缩略图，拖动起来非常方便和清晰。每个文件的标签就像Chrome一样可以随意的拖出拖入。此外，代码的颜色样式可以有几十种方案供选择，还可以下载针对每种语言的颜色方案，目前我知道的仅有最新的Stylus的styl文件没有对应的颜色方案。</p>\n<p>在功能方面，ST最大的特色之一就是会自动生成一份正在打开的文件的拷贝，而且会自动保存，也就是说即使是断电关机，重新打开后原本打开的文件也还是存在不会丢失任何代码。其次，多处编辑也是非常的强大，在代码中选择多处后会出现多个光标，可以同时编辑，而选中一个词后，按 <code>Ctrl+D</code> 就可以多选下一个相同的代码。另外通过 ‘Ctrl+P’ 可以搜索文件，配合 <code>@</code> 或者直接按 <code>Ctrl+R</code> 就可以前往指定的方法和函数，配合 <code>:</code> 或者直接按 <code>Ctrl+G</code> 就可以前往指定的行数。按住 <code>Shift+Ctrl+Up/Down</code> 就可以移动选中行的代码上下移动。其他编辑都有的一般的快捷键自然也都有。</p>\n<p>不过最强大的是，这些功能都可以利用插件实现，比如Emmet也就是大名鼎鼎的Zencoding的继任者就可以通过插件指定一个命令并分配一个快捷键来实现。我还喜欢使用Markdown preview，比如现在我就可以通过它预览一下博客的大致效果。还有刚刚提到的针对每种语言的颜色高亮方案也是插件的形式。还有一款老牌版本控制的工具Tortoise，因为公司还在用SVN这种老古董，Tortoise自然成了不二选择。还有很多插件，可以从官方网站搜索。<br><a href=\"https://sublime.wbond.net/search/\">https://sublime.wbond.net/search/</a></p>\n<p>说到插件，自然少不了管理它的工具，SublimeText的管理工具是Package Control，原来的安装十分麻烦，不过现在官方给出了方法。使用 <code>Ctrl+~</code> 打开控制台，然后复制<a href=\"https://sublime.wbond.net/installation\">这里官方给出的代码</a>到控制台并执行，Package Control就安装好了。之后使用 <code>Ctrl+Shift+P</code> 调出命令面板后就会有一组Package Control的命令，主要会用到 <code>install</code> 和 <code>remove</code><br>两个用于安装和卸载插件。</p>\n<p>关于用户配置，有很多内容，可以参考 <code>Settings - Default</code> 。比如这样：</p>\n<pre><code>&#123;\n    &quot;caret_style&quot;: &quot;phase&quot;,\n    &quot;font_size&quot;: 16.0,\n    &quot;overlay_scroll_bars&quot;: &quot;enabled&quot;,\n    &quot;save_on_focus_lost&quot;: true,\n    &quot;scroll_past_end&quot;: false,\n    &quot;tab_size&quot;: 4,\n    &quot;translate_tabs_to_spaces&quot;: true,\n    &quot;word_wrap&quot;: true,\n    &quot;wrap_width&quot;: 80\n&#125;\n</code></pre>\n<p>这些配置看到名字就基本可以猜出意思了，主要是wrap_width就是每行的字符数，设置到80，这样可以保持代码的简短，避免长语句。而translate_tabs_to_spaces就是用空格代替制表符。</p>\n<h5 id=\"Chrome\"><a href=\"#Chrome\" class=\"headerlink\" title=\"Chrome\"></a>Chrome</h5><p>我始终喜欢Chrome多过Firefox，因为Chrome的启动速度比Firefox快上许多，Firefox原先有点过于臃肿了，不按标准的地方也不少，虽然后来在Google注资之后，不但版本号追了上来，功能也提升很多。不过Chrome仍是我开发的主要环境，Firefox一般仅作为研究和测试之用。</p>\n<p>Chrome的开发者工具界面非常清爽，无论是在Elements中的HTML还是Sources中的Js，代码阅读和编辑都非常方便，而且在Element中可以修改和添加对应元素的CSS代码，而在Sources中可以直接修改CSS文件。Resources中列出了所有加载的文件，还有session、cookie和本地存储之类的缓存信息，可以方便的对其进行操作。而Network则列出了所有请求，以及相关的信息，甚至可以点击下面的圆点按钮 <code>preserve log upon Navigation</code> 进行请求响应时间的监视。在Timeline中还有更详细的时间监视，包括事件、加载以及内存的使用状况，可以方便的对程序的性能进行调试。在Profiles中可以对Js、CSS、DOM进行统计。还有Audits可以对网站性能和网络性能进行统计。</p>\n<p>最重要的是Console[11]，在这里可以直接写入Javascript代码进行调试，还可以收集到程序中输出的各种信息和报错。不过最特别的是它是有API的可编程。一般常用到 <code>log</code> 方法，像下面的代码这样来输出一些变量，当然还有不同的类型，比如 <code>error</code> 方法、 <code>warn</code> 方法。它们的参数也很自由，多个参数将会被空格连接输出，还可以在第一个参数中使用占位符来按类型加入后面的参数。</p>\n<pre><code>console.log(&#39;hello &#39; + world);\nconsole.error(&#39;Error:&#39;, &#39;nothing...&#39;);\nconsole.warn(&#39;Warn: %s &lt; %d&#39;, &#39;age&#39;, 18);\n</code></pre>\n<p>除了上面三个方法以及类似log的 <code>info</code> 和 <code>debug</code> 方法还有一个特别的方法，那就是断言 <code>assert</code> 方法，它可以判断条件，在false时报错，一般用于测试。</p>\n<p>另外还有三个关于时间的方法， <code>time</code> ， <code>timeEnd</code> 和 <code>timeStamp</code> 。time和timeEnd配合使用可以记录程序运行的时间并输出，而timeStamp可以在Timeline的统计中标出一个时间点。</p>\n<p>Chrome的插件也非常的多，这里介绍三款和页面密切相关的工具。</p>\n<p><a href=\"https://chrome.google.com/webstore/detail/visual-event/pbmmieigblcbldgdokdjpioljjninaim\">Visual Event</a> 是一个捕获页面事件的插件，它会将页面所有绑定的事件全部以可视化的方式呈现出来，并且可以点击查看某个元素的事件详细信息。我经常用来检查事件是否正确的绑定到了目标元素上。</p>\n<p><a href=\"https://chrome.google.com/webstore/detail/edit-this-cookie/fngmhnnpilhplaeedifhccceomclgfbg\">Edit This Cookie</a> 顾名思义，用来编辑Cookie的，虽然DevTools也带有这样的功能，但是它更加便利，还可以导出导入，随意修改每个Cookie中的任意条目。虽然它很强大，不过好像利用率最高的功能是一键清空Cookie。</p>\n<p><a href=\"https://chrome.google.com/webstore/detail/code-cola/lomkpheldlbkkfiifcbfifipaofnmnkn\">Code Cola</a> 可以用来修改CSS，与DevTools不同的是，它的操作是左右滑动滑块，而且主要针对CSS3的空间样式，可以快速将元素变成各种角度各种尺寸。</p>\n<p>不过Chrome还是有弱点的，当tab开的太多时会非常卡，因为Chrome每个tab都是一个单独的进程。所以还有一个插件也是很有用的，虽然和开发没有太大关系，<a href=\"https://chrome.google.com/webstore/detail/onetab/chphlpgkkbolifaimnlloiipkdnihall\">One Tab</a> 可以把当前的所有tab都集合起来变成一个页面，当需要打开时在点击链接即可，这样有效防止了过多tab造成的内存不足问题。</p>\n<h3 id=\"代码管理\"><a href=\"#代码管理\" class=\"headerlink\" title=\"代码管理\"></a>代码管理</h3><h5 id=\"Git-1\"><a href=\"#Git-1\" class=\"headerlink\" title=\"Git\"></a>Git</h5><p>关于Git Workflow的讨论很多，最著名的当属<a href=\"http://nvie.com/\">Vincent Driessen</a>的那篇博客[13]。Vincent的工作流的结构很棒，首先有2个主要分支，<code>master</code> 和 <code>develop</code>，分别是主分支和开发分支。然后还有3类次分支，它们可能数量很多，并且不会长时间存在，分别是开发新功能用的feature，发布用的release和修复bug用的hotfix。大致的Git操作可以理解为这样：</p>\n<pre><code># create branch\ngit checkout -b develop master\ngit checkout -b feature develop\n# commit something\ngit add widget.js\ngit commit -m &quot;add a function&quot;\n# merge to develop\ngit checkout develop\ngit merge --no-ff feature\n# delete branch\ngit branch -d feature\n</code></pre>\n<p>首先创建开发分支 <code>develop</code> ，然后再从开发分支创建一个次分支，接着提交代码并注释提交，合并会开发分支 <code>develop</code> ，最后删除这个临时的次分支。–no-ff的意思是不使用快速合并。其他开发过程中也是大同小异，release分支还有hotfix分支可能需要在确认没问题时合并到develop和master两个分支中然后删除。</p>\n<p>不过这个工作流是考虑到团队开发而设计的，很标准简约，但细节不足。而<a href=\"https://sandofsky.com/\">Benjamin Sandofsky</a>的文章[14]则更加趋向于对commit的管理，也许不能算做工作流，至少算是一种理念。他强调一定要保留有一个私人的分支只存在于本地，然后在合并到主分支时清除原本的commit log。这里会用到一个 <code>merge</code> 命令的参数 <code>--squash</code> 这样合并后不会带来任何commit log。</p>\n<pre><code># create brach\ngit checkout -b private master\n# commit something\ngit add widget.js\ngit commit -m &quot;add a function&quot;\n# merge brach but don&#39;t commit\ngit checkout master\ngit merge --squash private\n# commit once\ngit commit -m &quot;only this commit&quot;\n</code></pre>\n<p>但我认为Git工作流和其他一切工程过程一样，不存在银弹。不过这种合并的方式可以成为一种很好的操作流来完成属于每个人自己的工作流。另外从这两种不同风格的Git工作流中也许能找出一些有趣的点。以下是我的看法：</p>\n<ul>\n<li><p>主分支数由开发流程复杂度决定，而开发流程复杂度应该由项目主管根据项目规模确定，所以项目规模决定了主分支数，除了develop也许还需要test、build等等。</p>\n</li>\n<li><p>次分支数由人员和实际情况决定，bug数会决定hotfix的数量，也许产品经理会决定feature的数量，多个不同版本的同类产品也可能会增加release的数量。如果项目规模足够大时，几个小组解决一个问题时也会产生多个临时分支。</p>\n</li>\n<li><p>多人协作以及长时间开发都可能导致日志混乱无法管理，使用squash参数配合临时分支可以清理对别人不必要的commit信息。</p>\n</li>\n<li><p>应使用–no-ff可以避免快速合并，使每次合并等于一次提交，记录在log中，保持分支健康。</p>\n</li>\n</ul>\n<p>因此，在实际开发的工作流中应该按照实际情况创建分支，但应按照以上规范合并分支。</p>\n<h5 id=\"Github\"><a href=\"#Github\" class=\"headerlink\" title=\"Github\"></a>Github</h5><p>Github不止是每个Coder的FaceBook，还是一个非常棒的远程Git仓库，甚至有很多小组将生产项目托管在上面。其实Github上和Git没有太多差别，只是多了一个远程仓库Remote的操作，另外相信每个初入Github的新手都为私钥公钥头疼了好久，下文将会讨论Github的仓库创建和日常操作两部分。</p>\n<p>首先需要在本地建立与Github帐户的联系，在shell中安装SSH，然后像这样使用SSH安装SSH密钥：</p>\n<pre><code>ssh-keygen -t rsa -C &quot;your_email@example.com&quot;\n# Creates a new ssh key, using the provided email as a label\n# Generating public/private rsa key pair.\n# Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): [Press enter]\nssh-add id_rsa\n</code></pre>\n<p>然后会让你输入一个密码，随意输入就可以了，接着就会生成一个公钥一个私钥。在用户文件夹下的 <code>.ssh</code> 文件夹中找到id_rsa.pub，这个文件里就是公钥，复制里面的内容，然后在Github的Account Settings中的SSH Key页面，点击Add SSH Key按钮，输入一个用于说明的title，接着粘贴公钥到Key中就可以了。</p>\n<p>然后必须在Github上点击 <code>Create a new repo</code> 按钮来创建一个空项目。当然如果选择适当的选项就可以自动生成README文件、Git忽略文件和版权分享声明文件。之后该项目会有一个仓库的地址，可以使用HTTPS和SSH，甚至还有SVN地址：</p>\n<pre><code>https://github.com/&lt;username&gt;/&lt;reponame&gt;.git\ngit@github.com:&lt;username&gt;/&lt;reponame&gt;.git\nhttps://github.com/&lt;username&gt;/&lt;reponame&gt;\n</code></pre>\n<p>以我的一个对话框jQ插件为例，首先在项目中初始化git，然后添加一个远程仓库，然后就可以往上面提交代码了。</p>\n<pre><code>git remote add myGithub https://github.com/tychio/dialog.git\ngit push myGithub master\n</code></pre>\n<p>因为我使用的HTTPS方式提交，之后会需要输入用户名和密码，如果使用SSH方式则用使用公钥而无需额外操作。使用HTTPS纯属为了记住Github的密码，每天都在敲就不会忘记了。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>工作流应该是一个人最习惯和熟悉的流程，而不应该是照猫画虎，邯郸学步。还是那句话，不存在银弹，所以不会有万用的工作流，只能从中汲取有用的实践，完善改进自己的工作流，达到提高工作效率的目的。</p>\n<p>和学习其他技术一样，应用于工作流之中的工具有无数种，但真正需要和适合的只有自己知道，发现问题，带着问题寻找工具才能真的改进工作流。如果仅仅为了使用前沿的工具而使用，只会使自己的工作效率大打折扣。记得两年前我还在疯狂的复制代码，每当我意识到不能再这样下去的时候，工作流就会自己进化，合适的工具近在眼前，工作效率逐渐提升。我发现问题实在是很好的老师，可以让一个人快速的成长，解决它就可以获得一次提升。</p>\n<p>永远有人有跟你相同的问题，永远有能解决你当前问题的工具，善于使用问题来选择它们就能打造更完善的工作流。如果遇到没有工具能解决的问题，那说明造轮子的时机到了。</p>\n<h3 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h3><ol>\n<li><p><a href=\"https://npmjs.org/doc/README.html\">NPM Readme</a></p>\n</li>\n<li><p><a href=\"http://www.mingw.org/wiki/MSYS\">MSYS Wiki</a></p>\n</li>\n<li><p><a href=\"http://yeoman.io/\">Yeoman home</a></p>\n</li>\n<li><p><a href=\"http://yeoman.io/generators.html\">Yeoman generators</a></p>\n</li>\n<li><p><a href=\"http://bower.io/\">Bower home</a></p>\n</li>\n<li><p><a href=\"https://github.com/bower/bower/issues/859\">Bower jquery bug</a></p>\n</li>\n<li><p><a href=\"https://docs.google.com/document/d/1APq7oA9tNao1UYWyOm8dKqlRP2blVkROYLZ2fLIjtWc/edit#heading=h.4pzytc1f9j8k\">Bower configuration</a></p>\n</li>\n<li><p><a href=\"http://gruntjs.com/getting-started\">Grunt getting started</a></p>\n</li>\n<li><p><a href=\"http://www.henriquebarroso.com/my-top-10sublime-2-plugins/\">Top 10 SublimeText2 plugins</a></p>\n</li>\n<li><p><a href=\"https://sublime.wbond.net/installation\">Install package control</a></p>\n</li>\n<li><p><a href=\"https://developers.google.com/chrome-developer-tools/docs/console#using_the_console_api\">Using the console API</a></p>\n</li>\n<li><p><a href=\"http://git-scm.com/book/en/Getting-Started-Installing-Git\">Getting Started Installing Git</a></p>\n</li>\n<li><p><a href=\"http://nvie.com/posts/a-successful-git-branching-model/\">A successful Git branching model</a></p>\n</li>\n<li><p><a href=\"https://sandofsky.com/blog/git-workflow.html\">Understanding the Git Workflow</a></p>\n</li>\n<li><p><a href=\"https://help.github.com/articles/generating-ssh-keys\">Generating SSH Keys</a></p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>有人说过程序员和码农的本质区别就是程序员会不断探索提高生产力的方法。思维模式的转变是提高生产力的最好方式，但打磨我们的工具也是十分有意义的事，本文将从开发环境，自动化开发，开发工具等几个方面针对前端开发效率的提升和代码质量的提高来展开讨论。</p>\n<p>每件事都是一个程序，开发也像程序一样，每个步骤都是一段代码，当开发规模随着文档、代码、需求而增加时，重复的步骤变得越来越多。此时，如果可以像抽象代码一样抽象出一些相同操作就可以大大提升开发效率。因此，出现了更多更优质的工具来代替人工做一些不断重复的开发以减少程序员的工作量。</p>","more":"<h3 id=\"开发环境\"><a href=\"#开发环境\" class=\"headerlink\" title=\"开发环境\"></a>开发环境</h3><h5 id=\"Nodejs\"><a href=\"#Nodejs\" class=\"headerlink\" title=\"Nodejs\"></a>Nodejs</h5><p>首先，需要搭建一个自动化高效率的开发环境。以前我们有shell、java、ruby来进行一些自动化脚本的执行。但自从Nodejs将Javascript带入了服务器，Front End开发环境也发生了翻天覆地的变化。Nodejs不仅仅可以让Jser开发服务端，还让Javascript成为了服务器脚本语言之一，可以用于文件的操作。</p>\n<p>安装Nodejs的方法目前来说很简单，<a href=\"http://nodejs.org/download/\">点这里下载安装包</a>，选择对应的平台的安装包即可。不过不得不说的是Source Code包，这是源码需要编译，虽然由C++写成，但gyp进行管理，所以编译时需要Python2.6+和C++编译器一起工作。通过命令 <code>node -v</code> 来检验是否安装成功，成功则返回当前版本号。</p>\n<p>另外Nodejs还有一样必备的工具npm，就像ruby中的gem一样，是一个Nodejs的包管理器，可以为Nodejs添加一些包。npm的安装非常简单[1]，可以说不用安装，在Linux下只有一行命令： <code>make install</code><br>, 而Windows和Mac都默认带有npm。当然如果想专门安装npm也是可以的，Linux下仍然是一行代码：</p>\n<pre><code>curl https://npmjs.org/install.sh | sudo sh\n</code></pre>\n<p>而Windows会稍微麻烦一点，在<a href=\"https://npmjs.org/dist/\">https://npmjs.org/dist/</a>下载源码，然后放到和node.exe一个文件夹下即可。</p>\n<p>使用npm来安装一些包很简单，使用这样的命令 <code>npm install &lt;package_name&gt;</code> ，一般来说会默认安装在当前目录中。但如果使用参数 <code>-g</code> 就可以安装在全局。另外通过在项目中添加一个 <code>package.json</code> 文件，就可以定义项目依赖的Nodejs包，然后直接在该目录中执行 <code>npm install</code> 指令就会将package文件指定的包全部安装在当前目录。</p>\n<h5 id=\"Shell\"><a href=\"#Shell\" class=\"headerlink\" title=\"Shell\"></a>Shell</h5><p>不管是Linux还是Mac都天然的拥有Shell环境，但是Windows中的CMD是无法和Shell相提并论的，而且很多开发工具也需要Shell环境。</p>\n<p>还好Windows中有MSYS[2]，全称是Minimal GNU（POSIX）system on Windows，它是一个GNU工具集，包括了bash，make，gawk和grep。可以直接下载 </p>\n<p><a href=\"http://www.mingw.org/wiki/MSYS\">http://www.mingw.org/wiki/MSYS</a></p>\n<p>如果需要整个Unix环境和C的库的话，还需要minGW。也可以直接安装Git Bash工具，会附带有这个，这样环境和Git就会一起装好。</p>\n<p><a href=\"http://git-scm.com/downloads\">http://git-scm.com/downloads</a></p>\n<p>另外在Windows中使用Shell时，有几点需要注意。文件路径的根目录为Git Bash的文件根路径，但是可以使用斜杠和盘符代表Windows的磁盘，比如进入D盘下的workspace文件夹就这样：</p>\n<pre><code>$ cd /d/workspace/\n</code></pre>\n<p>而Windows特有的文件夹名称中带有空格的问题可以通过两个方法解决。</p>\n<pre><code>$ mkdir /c/&quot;work space&quot;\n$ rmdir /c/work\\ space\n</code></pre>\n<p>用引号括起来带有空格的文件名或者使用反斜杠来转义空格。</p>\n<h5 id=\"Git\"><a href=\"#Git\" class=\"headerlink\" title=\"Git\"></a>Git</h5><p>Git的安装很分散[12]，每种平台都不一样，Linux中也分为两种使用yum或者apt-get来安装：</p>\n<pre><code>// as Fedora\n$ yum install git-core\n// as Ubuntu\n$ apt-get install git\n</code></pre>\n<p>Mac上是最简单的，在这里安装<a href=\"http://code.google.com/p/git-osx-installer\">http://code.google.com/p/git-osx-installer</a></p>\n<p>Windows也很方便，因为有了<a href=\"http://msysgit.github.com/\">Msysgit</a>，也一样直接安装。</p>\n<h5 id=\"编辑器\"><a href=\"#编辑器\" class=\"headerlink\" title=\"编辑器\"></a>编辑器</h5><p>编辑器是每个程序员最常用的工具，它在很大程度上决定了单纯Coding的效率。原来有人将Vim和Emacs奉为上古神器，不过我喜欢新的东西，SublimeText是目前编辑器中的新贵，拥有海量插件，使用Python编写，配置和操作都非常方便。可以到这里下载：</p>\n<ul>\n<li><a href=\"http://www.sublimetext.com/\">SublimeText2</a></li>\n</ul>\n<p>现在第3版正在进行beta测试，但是由于升级为Python3，原来的插件都因为API更新的问题而无法使用了，相信在正式版发布后插件将会陆续升级。这是第三版的下载地址，不会覆盖第二版。</p>\n<ul>\n<li><a href=\"http://www.sublimetext.com/3\">SublimeText3</a></li>\n</ul>\n<p>此外，虽然它是付费软件，不过作者好像从来不怕没有人付费，如果没有注册仅仅会偶尔在保存时弹出Lisence声明，但确认会弹出官方页面，点取消即可。好像还有破解版本的出现，不过作者已经这么大度了，用破解版好像有点说不过去。国内曾经还有人组织过团购，但是作者表示不存在团购一说，只有公司批量购买，最终只有不了了之，售价$70。</p>\n<h5 id=\"浏览器\"><a href=\"#浏览器\" class=\"headerlink\" title=\"浏览器\"></a>浏览器</h5><p>作为前端最基本的环境，浏览器是必不可少的。Chrome是我最喜欢的浏览器，因为它的快速高效以及很棒的开发者工具。虽然Firefox也是一款出色的浏览器，但Firebug作为一款插件，效率总是差那么一点，当然Firefox现在也推出了自己的调试工具。用于测试的IE浏览器也是常备工具之一，此外还有Opera和Safari。</p>\n<p>Chrome和Firefox很强大的一个原因就是，它们对W3C的标准都很快速的支持，许多最新的特性都可以体现在最新版的Chrome以及Firefox中。特别需要一说的是，它们都有一个每日更新的版本，用户可以体验到最新的功能，而浏览器厂商可以获取崩溃信息等反馈来提高品质。Chrome的每日更新版叫<a href=\"https://www.google.com/intl/zh-CN/chrome/browser/canary.html\">Chrome Canary</a>,Firefox的比较直接，<a href=\"http://nightly.mozilla.org/\">Firefox Nightly</a>。</p>\n<p>还有一款很神奇的浏览器，它不会渲染，也没有界面，基于Webkit内核，它叫<a href=\"http://phantomjs.org/index.html\">PlantomJS</a>，图标的幽灵和名字都突出了这一特点。也许看起来没什么用，但在测试或者做研究时，浏览器不厌其烦的弹出来时，它就有大用处了。</p>\n<h3 id=\"自动化开发\"><a href=\"#自动化开发\" class=\"headerlink\" title=\"自动化开发\"></a>自动化开发</h3><h5 id=\"Yeoman\"><a href=\"#Yeoman\" class=\"headerlink\" title=\"Yeoman\"></a>Yeoman</h5><p>Yeoman按照官方说法[3]，它不只是一个工具，还是一个工作流。它其实包括了三个部分yo、grunt、bower，分别用于项目的启动、文件操作、包管理。但我并不太认同这是一个工作流的说法，至少目前来看还不够成熟，在真实的生产环境中会遇到许多问题。而未来的可能性大致应该有两条路可走，也许会产生某些工作流的标准来定义前端开发的软件质量，不过我更认为Yeoman应该走向高可定制的工作流工具的方向，而不是自身作为一个工作流来存在。</p>\n<h6 id=\"Yo\"><a href=\"#Yo\" class=\"headerlink\" title=\"Yo\"></a>Yo</h6><p>Yo是一个项目初始化工具，可以生成一套启动某类项目必须的项目文件。可以通过npm安装它到全局：</p>\n<pre><code>npm install -g yo\n</code></pre>\n<p>然后还需要安装一些generator，这是一个用于创建某个指定类型项目的生成器。比如安装一个最常用的webapp的生成器，然后就可以在项目路径下生成项目启动需要的所有文件，像这样：</p>\n<pre><code>npm install -g generator-webapp\ncd /project_folder/\nyo webapp\n</code></pre>\n<p>但是这种机制有一个很严重的问题，generator产生的文件结构是谁制定的？没有一个官方的相应的标准或者说Guide，generator的形式参差不齐，甚至我发现Firefox OS的generator生成的是一个API接口的Demo而不是一个种子，如果要进行开发需要进行很多删减。</p>\n<p>不过产生这些generator的generator[4]却是一个很好的工具，它应该是一个创造性的工具。首先需要安装generator-generator，然后使用它，接着会看到字符拼接的yeoman，像这样：</p>\n<pre><code>npm install -g yo generator-generator\n$ mkdir ~/dev/generator-blog &amp;&amp; cd $_\n$ yo generator\n\n    _-----_\n   |       |\n   |--(o)--|   .--------------------------.\n  `---------´  |    Welcome to Yeoman,    |\n   ( _´U`_ )   |   ladies and gentlemen!  |\n   /___A___\\   &#39;__________________________&#39;\n    |  ~  |\n  __&#39;.___.&#39;__\n´   `  |° ´ Y `\n</code></pre>\n<p>当然使用它之前应该将写好的项目文件放入 <code>app/templates</code> 文件夹中，并在 <code>templates</code> 同级的路径中加入 <code>index.js</code> 进行配置就可以了。这里的index.js是运行在Nodejs中的，也就是说由它将templates中的项目文件放入该放的地方并且填入一些变量去构建整个项目。这里才是体现一个generator是否是一个好的generator的地方，如果仅仅是将一堆写好的项目文件下载下来那什么意义也没有，不存在万用种子。只有在使用generator生成项目时高度定制才是其意义所在，而相关标准才是最难的部分。</p>\n<h5 id=\"Bower\"><a href=\"#Bower\" class=\"headerlink\" title=\"Bower\"></a>Bower</h5><p>Bower是一个类似于npm的包管理器，但不同的是Bower主要针对前端，并且直接从Github查找需要的库下载到本地缓存。使用很简单，用npm安装bower后可以安装Github的项目并指定版本号，还可以重命名。默认会下载到项目中的 <code>bower_components</code> 文件夹中。[5]</p>\n<pre><code>npm install -g bower\nbower install jQuery\nbower install jQuery#1.10.3\nbower install jQueryOld=jQuery#1.6.4\n</code></pre>\n<p>还可以通过bower.json文件来配置需要安装的包，使用 <code>bower init</code> 命令就可以生成bower.json文件，然后在其中写入需要的包及其版本即可</p>\n<pre><code>&#123;\n  &quot;name&quot;: &quot;my_project&quot;,\n  &quot;version&quot;: &quot;0.1.0&quot;,\n  &quot;main&quot;: [js/js.js, css/css.css],\n  &quot;ignore&quot;: [\n    &quot;.jshintrc&quot;,\n    &quot;**/*.txt&quot;\n  ],\n  &quot;dependencies&quot;: &#123;\n    &quot;&lt;name&gt;&quot;: &quot;&lt;version&gt;&quot;,\n    &quot;&lt;name&gt;&quot;: &quot;&lt;folder&gt;&quot;,\n    &quot;&lt;name&gt;&quot;: &quot;&lt;package&gt;&quot;\n  &#125;,\n  &quot;devDependencies&quot;: &#123;\n    &quot;&lt;test-framework-name&gt;&quot;: &quot;&lt;version&gt;&quot;\n  &#125;\n&#125;\n</code></pre>\n<p>当然它也可以搜索包，像这样搜索一下jquery。</p>\n<pre><code>bower search jquery\n</code></pre>\n<p>如果觉得bower_components的文件夹名太长不好，可以在 <code>.bowerrc</code> 中以json的形式修改它的路径</p>\n<pre><code>&#123;\n  &quot;directory&quot;: &quot;lib&quot;\n&#125;\n</code></pre>\n<p>还有许多其他的配置，可以在Bower存放在Google Doc的文档[7]中查看。</p>\n<p>但是Bower还有一个Bug[6]，jQuery在Github上的项目文件是分模块的，必须使用项目中的Grunt才能打包成jquery.js文件，而官方的说法是使用小写q的 <code>jquery</code> 来获取components项目中的jquery文件，但是目前Bower是大小写不分的，所以无法获取独立的jQuery文件。如果bower可以指定获取某个项目中的某个或某些指定的文件将会更加犀利。</p>\n<p>甚至Bower可以在Nodejs中运行一个 <code>bower.commands</code> 文件来让你编写安装各种包的node程序，并且可以监听 <code>end</code> 事件在安装结束后进行操作，这是异步的，这样就可以随心所欲的安装包和控制顺序了。</p>\n<pre><code>var bower = require(&#39;bower&#39;);\nbower.commands\n    .install([&#39;jquery&#39;], &#123; save: true &#125;, &#123; /* custom config */ &#125;)\n    .on(&#39;end&#39;, function (installed) &#123;\n        console.log(installed);\n&#125;);\n</code></pre>\n<h5 id=\"Grunt\"><a href=\"#Grunt\" class=\"headerlink\" title=\"Grunt\"></a>Grunt</h5><p>Grunt目前来说是这三个Yeoman中最成熟最强大的，最关键的是Grunt有各种各样的插件，可以集成大部分能想得到的开发工具来进行自动化开发。另外Grunt的作者还开发了一整套的插件来适应常规的开发，这套插件以 <code>grunt-contrib-</code> 为前缀（下文中如无特殊说明，均指带有该前缀的插件名），除了文件的基本操作，还包括有测试、编译、压缩、代码检查等各种功能的插件，而且不止一个选择。</p>\n<p>安装Grunt和Bower不太一样[8]，需要先在全局安装一个Grunt的客户端，然后在每个项目中安装Grunt。</p>\n<pre><code>npm install -g grunt-cli\ncd /project/\nnpm install grunt\n</code></pre>\n<p>不过和Bower相似的是，可以通过编写配置json文件来使用 <code>npm install</code> 来安装Grunt和所有需要的插件，另外Grunt的插件也都是npm管理的，所以可以直接在 <code>package.json</code> 中直接编写。</p>\n<pre><code>&#123;\n    &quot;name&quot;: &quot;myProject&quot;,\n    &quot;version&quot;: &quot;0.1.0&quot;,\n    &quot;devDependencies&quot;: &#123;\n        &quot;grunt&quot;: &quot;*&quot;,\n        // other plugin...\n        &quot;grunt-contrib-watch&quot;: &quot;*&quot;\n    &#125;\n&#125;\n</code></pre>\n<p>安装完成后在项目根目录中建立 <code>Gruntfile.js</code> 文件来配置Grunt的工作流程。下面以 <code>copy</code> 插件为例使用Grunt进行开发。在 <code>exports</code> 中Grunt会以参数形式被传入函数，它有3个方法， <code>initConfig</code> 、 <code>loadNpmTasks</code> 、 <code>registerTask</code>，分别用来定义插件操作，载入插件，注册任务。</p>\n<pre><code>module.exports = function (grunt) &#123;\n    grunt.initConfig(&#123;\n        copy: &#123;\n            main: &#123;\n                files: &#123;\n                    src: [&#39;path/**&#39;], \n                    dest: &#39;dest/&#39;\n                &#125;\n            &#125;\n        &#125;\n    &#125;);\n    grunt.loadNpmTasks(&#39;grunt-contrib-copy&#39;);\n    grunt.registerTask(&#39;default&#39;, [&#39;copy&#39;]);\n&#125;;\n</code></pre>\n<p>在配置中以插件名为键定义一个Object作为该插件的配置，其中还可以再定义一层以任务名为键，比如 <code>main</code> ，然后是插件的部分，copy插件使用 <code>files</code> 来定义对文件的具体操作， <code>src</code> 是要复制的文件， <code>dest</code> 则是要复制到的路径。</p>\n<p>然后使用 <code>loadNpmTasks</code> 加载插件，需要写全名，包括grunt-contrib前缀。</p>\n<p>最后是注册一个任务，这里的任务即是执行操作时需要调用的东西。比如代码中注册了 <code>default</code> 任务，包括一个数组中的所有任务，这样在执行default任务时就会执行相应的所有任务。另外default是一个特殊的任务名，如果在执行任务时没有指定名称，则执行该任务。当然直接运行copy任务也是可以的，甚至可以指定一个子任务，比如main。所以下面4行代码是相同的效果。</p>\n<pre><code>grunt\ngrunt default\ngrunt copy\ngrunt copy:main\n</code></pre>\n<p>不过需要特别注意的是，注册的任务名不能和原有的任务相同，这样会报错，比如这样：</p>\n<pre><code>grunt.registerTask(&#39;copy&#39;, [&#39;copy&#39;]);\n</code></pre>\n<p>和copy类似的文件基本操作还有 <code>clean</code> 清除, <code>concat</code> 连接, <code>rename</code> 重命名, <code>compress</code> 打包, <code>crypt</code> 编码等等，相关的配置可以在npmjs.org上的对应项目介绍中找到。</p>\n<p>还有四个用于压缩的插件 <code>htmlmin</code> , <code>cssmin</code> , <code>uglify</code> , <code>imagemin</code> 分别对应HTML文件、CSS文件、JS文件和图片文件；以及两个用于检查代码的插件 <code>csslint</code> , <code>jshint</code> 分别检查CSS代码和JS代码。</p>\n<p>当然，最重要的是，Grunt可以编译一些CSS和JS的其他形式代码。<code>coffee</code> 用于编译CoffeeScript，而CSS就更多了，比如<a href=\"http://sass-lang.com/\">SASS</a>可以使用 <code>compass</code> 或者 <code>sass</code>, 还有 <code>less</code> 和 <code>stylus</code>，我最喜欢的是<a href=\"http://learnboost.github.io/stylus/\">Stylus</a>，因为它使用的是Javascript来编译，而不像SASS是Ruby编译的，还需要准备Ruby的环境，非常麻烦。而且在Stylus中还可以写类似JS的条件语句和循环语句。这个国旗icon的项目很好的使用了Stylus以很短的代码完成了上百个国家的图标的CSS Sprite - <a href=\"https://github.com/tychio/national_flag/blob/master/country.styl\">National Flag on Github</a>。还有许多种Javascript模板的预编译插件，<code>haml</code> , <code>jst</code> , <code>jade</code> , <code>hogan</code> 等等。</p>\n<p>除了用于编码的插件，还有许多用于测试的插件，在grunt-contrib中提供了三个测试框架的插件， <code>nodeunit</code> 用于Nodejs，<code>qunit</code> 用于Qunit，是来自jQuery团队的测试框架，还有Junit的后继者 <code>jasmine</code>。另外Mocha也有自己的Grunt插件 <code>grunt-mocha</code> 。用于捕获多个浏览器测试框架karma也有相应的插件 <code>grunt-karma</code> 。</p>\n<p>此外，contrib中还有一些其他插件，比如 <code>connect</code> 用于http等协议的请求，支持https， <code>commands</code> 用于执行shell命令， <code>manifest</code><br> 用于生成离线应用所需的 <code>manifest.appcache</code> 文件，还有用于插件YUI文档的 <code>yuidoc</code> 。</p>\n<p>最最重要的一个插件就是 <code>watch</code> ，它可以随时监听某些指定的文件，当它们发生改变时执行相应的任务。再次使用copy做例子，添加watch任务后可以在原有文件发生改变时，将复制过去的副本也同步改变。</p>\n<pre><code>module.exports = function (grunt) &#123;\n    grunt.initConfig(&#123;\n        watch: &#123;\n            copy: &#123;\n                files: &#39;path/**&#39;,\n                tasks: &#39;copy&#39;\n            &#125;\n        &#125;,\n        copy: &#123;\n            main: &#123;\n                files: &#123;\n                    src: [&#39;path/**&#39;], \n                    dest: &#39;dest/&#39;\n                &#125;\n            &#125;\n        &#125;\n    &#125;);\n    grunt.loadNpmTasks(&#39;grunt-contrib-copy&#39;);\n    grunt.loadNpmTasks(&#39;grunt-contrib-watch&#39;);\n    grunt.registerTask(&#39;default&#39;, [&#39;copy&#39;, &#39;watch&#39;]);\n&#125;;\n</code></pre>\n<p>由此，项目开发中的大部分工作都交由程序代替了人工，Yo和Bower可以快速的启动一个项目，Grunt在开发中可以自动化的持续完成编码中重复性的工作以及自动化检查和测试代码以提高质量。</p>\n<h3 id=\"开发工具\"><a href=\"#开发工具\" class=\"headerlink\" title=\"开发工具\"></a>开发工具</h3><h5 id=\"SublimeText\"><a href=\"#SublimeText\" class=\"headerlink\" title=\"SublimeText\"></a>SublimeText</h5><p>在自动化开发的前提下，仍然有很多编码工作是需要亲手完成的，此时编辑器的效率决定了剩下的开发效率。SublimeText一款很棒的编辑器，通过配置和插件的选择可以达到几乎所有需求。</p>\n<p>首先从GUI来说，ST的侧边栏可以随意的拖入文件夹并对其进行操作，而文本区则可以选择多种组合方式，包括网格、最多四栏、最多四列的布局。其滚动条也已经不是一个条了，而是一个代码的缩略图，拖动起来非常方便和清晰。每个文件的标签就像Chrome一样可以随意的拖出拖入。此外，代码的颜色样式可以有几十种方案供选择，还可以下载针对每种语言的颜色方案，目前我知道的仅有最新的Stylus的styl文件没有对应的颜色方案。</p>\n<p>在功能方面，ST最大的特色之一就是会自动生成一份正在打开的文件的拷贝，而且会自动保存，也就是说即使是断电关机，重新打开后原本打开的文件也还是存在不会丢失任何代码。其次，多处编辑也是非常的强大，在代码中选择多处后会出现多个光标，可以同时编辑，而选中一个词后，按 <code>Ctrl+D</code> 就可以多选下一个相同的代码。另外通过 ‘Ctrl+P’ 可以搜索文件，配合 <code>@</code> 或者直接按 <code>Ctrl+R</code> 就可以前往指定的方法和函数，配合 <code>:</code> 或者直接按 <code>Ctrl+G</code> 就可以前往指定的行数。按住 <code>Shift+Ctrl+Up/Down</code> 就可以移动选中行的代码上下移动。其他编辑都有的一般的快捷键自然也都有。</p>\n<p>不过最强大的是，这些功能都可以利用插件实现，比如Emmet也就是大名鼎鼎的Zencoding的继任者就可以通过插件指定一个命令并分配一个快捷键来实现。我还喜欢使用Markdown preview，比如现在我就可以通过它预览一下博客的大致效果。还有刚刚提到的针对每种语言的颜色高亮方案也是插件的形式。还有一款老牌版本控制的工具Tortoise，因为公司还在用SVN这种老古董，Tortoise自然成了不二选择。还有很多插件，可以从官方网站搜索。<br><a href=\"https://sublime.wbond.net/search/\">https://sublime.wbond.net/search/</a></p>\n<p>说到插件，自然少不了管理它的工具，SublimeText的管理工具是Package Control，原来的安装十分麻烦，不过现在官方给出了方法。使用 <code>Ctrl+~</code> 打开控制台，然后复制<a href=\"https://sublime.wbond.net/installation\">这里官方给出的代码</a>到控制台并执行，Package Control就安装好了。之后使用 <code>Ctrl+Shift+P</code> 调出命令面板后就会有一组Package Control的命令，主要会用到 <code>install</code> 和 <code>remove</code><br>两个用于安装和卸载插件。</p>\n<p>关于用户配置，有很多内容，可以参考 <code>Settings - Default</code> 。比如这样：</p>\n<pre><code>&#123;\n    &quot;caret_style&quot;: &quot;phase&quot;,\n    &quot;font_size&quot;: 16.0,\n    &quot;overlay_scroll_bars&quot;: &quot;enabled&quot;,\n    &quot;save_on_focus_lost&quot;: true,\n    &quot;scroll_past_end&quot;: false,\n    &quot;tab_size&quot;: 4,\n    &quot;translate_tabs_to_spaces&quot;: true,\n    &quot;word_wrap&quot;: true,\n    &quot;wrap_width&quot;: 80\n&#125;\n</code></pre>\n<p>这些配置看到名字就基本可以猜出意思了，主要是wrap_width就是每行的字符数，设置到80，这样可以保持代码的简短，避免长语句。而translate_tabs_to_spaces就是用空格代替制表符。</p>\n<h5 id=\"Chrome\"><a href=\"#Chrome\" class=\"headerlink\" title=\"Chrome\"></a>Chrome</h5><p>我始终喜欢Chrome多过Firefox，因为Chrome的启动速度比Firefox快上许多，Firefox原先有点过于臃肿了，不按标准的地方也不少，虽然后来在Google注资之后，不但版本号追了上来，功能也提升很多。不过Chrome仍是我开发的主要环境，Firefox一般仅作为研究和测试之用。</p>\n<p>Chrome的开发者工具界面非常清爽，无论是在Elements中的HTML还是Sources中的Js，代码阅读和编辑都非常方便，而且在Element中可以修改和添加对应元素的CSS代码，而在Sources中可以直接修改CSS文件。Resources中列出了所有加载的文件，还有session、cookie和本地存储之类的缓存信息，可以方便的对其进行操作。而Network则列出了所有请求，以及相关的信息，甚至可以点击下面的圆点按钮 <code>preserve log upon Navigation</code> 进行请求响应时间的监视。在Timeline中还有更详细的时间监视，包括事件、加载以及内存的使用状况，可以方便的对程序的性能进行调试。在Profiles中可以对Js、CSS、DOM进行统计。还有Audits可以对网站性能和网络性能进行统计。</p>\n<p>最重要的是Console[11]，在这里可以直接写入Javascript代码进行调试，还可以收集到程序中输出的各种信息和报错。不过最特别的是它是有API的可编程。一般常用到 <code>log</code> 方法，像下面的代码这样来输出一些变量，当然还有不同的类型，比如 <code>error</code> 方法、 <code>warn</code> 方法。它们的参数也很自由，多个参数将会被空格连接输出，还可以在第一个参数中使用占位符来按类型加入后面的参数。</p>\n<pre><code>console.log(&#39;hello &#39; + world);\nconsole.error(&#39;Error:&#39;, &#39;nothing...&#39;);\nconsole.warn(&#39;Warn: %s &lt; %d&#39;, &#39;age&#39;, 18);\n</code></pre>\n<p>除了上面三个方法以及类似log的 <code>info</code> 和 <code>debug</code> 方法还有一个特别的方法，那就是断言 <code>assert</code> 方法，它可以判断条件，在false时报错，一般用于测试。</p>\n<p>另外还有三个关于时间的方法， <code>time</code> ， <code>timeEnd</code> 和 <code>timeStamp</code> 。time和timeEnd配合使用可以记录程序运行的时间并输出，而timeStamp可以在Timeline的统计中标出一个时间点。</p>\n<p>Chrome的插件也非常的多，这里介绍三款和页面密切相关的工具。</p>\n<p><a href=\"https://chrome.google.com/webstore/detail/visual-event/pbmmieigblcbldgdokdjpioljjninaim\">Visual Event</a> 是一个捕获页面事件的插件，它会将页面所有绑定的事件全部以可视化的方式呈现出来，并且可以点击查看某个元素的事件详细信息。我经常用来检查事件是否正确的绑定到了目标元素上。</p>\n<p><a href=\"https://chrome.google.com/webstore/detail/edit-this-cookie/fngmhnnpilhplaeedifhccceomclgfbg\">Edit This Cookie</a> 顾名思义，用来编辑Cookie的，虽然DevTools也带有这样的功能，但是它更加便利，还可以导出导入，随意修改每个Cookie中的任意条目。虽然它很强大，不过好像利用率最高的功能是一键清空Cookie。</p>\n<p><a href=\"https://chrome.google.com/webstore/detail/code-cola/lomkpheldlbkkfiifcbfifipaofnmnkn\">Code Cola</a> 可以用来修改CSS，与DevTools不同的是，它的操作是左右滑动滑块，而且主要针对CSS3的空间样式，可以快速将元素变成各种角度各种尺寸。</p>\n<p>不过Chrome还是有弱点的，当tab开的太多时会非常卡，因为Chrome每个tab都是一个单独的进程。所以还有一个插件也是很有用的，虽然和开发没有太大关系，<a href=\"https://chrome.google.com/webstore/detail/onetab/chphlpgkkbolifaimnlloiipkdnihall\">One Tab</a> 可以把当前的所有tab都集合起来变成一个页面，当需要打开时在点击链接即可，这样有效防止了过多tab造成的内存不足问题。</p>\n<h3 id=\"代码管理\"><a href=\"#代码管理\" class=\"headerlink\" title=\"代码管理\"></a>代码管理</h3><h5 id=\"Git-1\"><a href=\"#Git-1\" class=\"headerlink\" title=\"Git\"></a>Git</h5><p>关于Git Workflow的讨论很多，最著名的当属<a href=\"http://nvie.com/\">Vincent Driessen</a>的那篇博客[13]。Vincent的工作流的结构很棒，首先有2个主要分支，<code>master</code> 和 <code>develop</code>，分别是主分支和开发分支。然后还有3类次分支，它们可能数量很多，并且不会长时间存在，分别是开发新功能用的feature，发布用的release和修复bug用的hotfix。大致的Git操作可以理解为这样：</p>\n<pre><code># create branch\ngit checkout -b develop master\ngit checkout -b feature develop\n# commit something\ngit add widget.js\ngit commit -m &quot;add a function&quot;\n# merge to develop\ngit checkout develop\ngit merge --no-ff feature\n# delete branch\ngit branch -d feature\n</code></pre>\n<p>首先创建开发分支 <code>develop</code> ，然后再从开发分支创建一个次分支，接着提交代码并注释提交，合并会开发分支 <code>develop</code> ，最后删除这个临时的次分支。–no-ff的意思是不使用快速合并。其他开发过程中也是大同小异，release分支还有hotfix分支可能需要在确认没问题时合并到develop和master两个分支中然后删除。</p>\n<p>不过这个工作流是考虑到团队开发而设计的，很标准简约，但细节不足。而<a href=\"https://sandofsky.com/\">Benjamin Sandofsky</a>的文章[14]则更加趋向于对commit的管理，也许不能算做工作流，至少算是一种理念。他强调一定要保留有一个私人的分支只存在于本地，然后在合并到主分支时清除原本的commit log。这里会用到一个 <code>merge</code> 命令的参数 <code>--squash</code> 这样合并后不会带来任何commit log。</p>\n<pre><code># create brach\ngit checkout -b private master\n# commit something\ngit add widget.js\ngit commit -m &quot;add a function&quot;\n# merge brach but don&#39;t commit\ngit checkout master\ngit merge --squash private\n# commit once\ngit commit -m &quot;only this commit&quot;\n</code></pre>\n<p>但我认为Git工作流和其他一切工程过程一样，不存在银弹。不过这种合并的方式可以成为一种很好的操作流来完成属于每个人自己的工作流。另外从这两种不同风格的Git工作流中也许能找出一些有趣的点。以下是我的看法：</p>\n<ul>\n<li><p>主分支数由开发流程复杂度决定，而开发流程复杂度应该由项目主管根据项目规模确定，所以项目规模决定了主分支数，除了develop也许还需要test、build等等。</p>\n</li>\n<li><p>次分支数由人员和实际情况决定，bug数会决定hotfix的数量，也许产品经理会决定feature的数量，多个不同版本的同类产品也可能会增加release的数量。如果项目规模足够大时，几个小组解决一个问题时也会产生多个临时分支。</p>\n</li>\n<li><p>多人协作以及长时间开发都可能导致日志混乱无法管理，使用squash参数配合临时分支可以清理对别人不必要的commit信息。</p>\n</li>\n<li><p>应使用–no-ff可以避免快速合并，使每次合并等于一次提交，记录在log中，保持分支健康。</p>\n</li>\n</ul>\n<p>因此，在实际开发的工作流中应该按照实际情况创建分支，但应按照以上规范合并分支。</p>\n<h5 id=\"Github\"><a href=\"#Github\" class=\"headerlink\" title=\"Github\"></a>Github</h5><p>Github不止是每个Coder的FaceBook，还是一个非常棒的远程Git仓库，甚至有很多小组将生产项目托管在上面。其实Github上和Git没有太多差别，只是多了一个远程仓库Remote的操作，另外相信每个初入Github的新手都为私钥公钥头疼了好久，下文将会讨论Github的仓库创建和日常操作两部分。</p>\n<p>首先需要在本地建立与Github帐户的联系，在shell中安装SSH，然后像这样使用SSH安装SSH密钥：</p>\n<pre><code>ssh-keygen -t rsa -C &quot;your_email@example.com&quot;\n# Creates a new ssh key, using the provided email as a label\n# Generating public/private rsa key pair.\n# Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): [Press enter]\nssh-add id_rsa\n</code></pre>\n<p>然后会让你输入一个密码，随意输入就可以了，接着就会生成一个公钥一个私钥。在用户文件夹下的 <code>.ssh</code> 文件夹中找到id_rsa.pub，这个文件里就是公钥，复制里面的内容，然后在Github的Account Settings中的SSH Key页面，点击Add SSH Key按钮，输入一个用于说明的title，接着粘贴公钥到Key中就可以了。</p>\n<p>然后必须在Github上点击 <code>Create a new repo</code> 按钮来创建一个空项目。当然如果选择适当的选项就可以自动生成README文件、Git忽略文件和版权分享声明文件。之后该项目会有一个仓库的地址，可以使用HTTPS和SSH，甚至还有SVN地址：</p>\n<pre><code>https://github.com/&lt;username&gt;/&lt;reponame&gt;.git\ngit@github.com:&lt;username&gt;/&lt;reponame&gt;.git\nhttps://github.com/&lt;username&gt;/&lt;reponame&gt;\n</code></pre>\n<p>以我的一个对话框jQ插件为例，首先在项目中初始化git，然后添加一个远程仓库，然后就可以往上面提交代码了。</p>\n<pre><code>git remote add myGithub https://github.com/tychio/dialog.git\ngit push myGithub master\n</code></pre>\n<p>因为我使用的HTTPS方式提交，之后会需要输入用户名和密码，如果使用SSH方式则用使用公钥而无需额外操作。使用HTTPS纯属为了记住Github的密码，每天都在敲就不会忘记了。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>工作流应该是一个人最习惯和熟悉的流程，而不应该是照猫画虎，邯郸学步。还是那句话，不存在银弹，所以不会有万用的工作流，只能从中汲取有用的实践，完善改进自己的工作流，达到提高工作效率的目的。</p>\n<p>和学习其他技术一样，应用于工作流之中的工具有无数种，但真正需要和适合的只有自己知道，发现问题，带着问题寻找工具才能真的改进工作流。如果仅仅为了使用前沿的工具而使用，只会使自己的工作效率大打折扣。记得两年前我还在疯狂的复制代码，每当我意识到不能再这样下去的时候，工作流就会自己进化，合适的工具近在眼前，工作效率逐渐提升。我发现问题实在是很好的老师，可以让一个人快速的成长，解决它就可以获得一次提升。</p>\n<p>永远有人有跟你相同的问题，永远有能解决你当前问题的工具，善于使用问题来选择它们就能打造更完善的工作流。如果遇到没有工具能解决的问题，那说明造轮子的时机到了。</p>\n<h3 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h3><ol>\n<li><p><a href=\"https://npmjs.org/doc/README.html\">NPM Readme</a></p>\n</li>\n<li><p><a href=\"http://www.mingw.org/wiki/MSYS\">MSYS Wiki</a></p>\n</li>\n<li><p><a href=\"http://yeoman.io/\">Yeoman home</a></p>\n</li>\n<li><p><a href=\"http://yeoman.io/generators.html\">Yeoman generators</a></p>\n</li>\n<li><p><a href=\"http://bower.io/\">Bower home</a></p>\n</li>\n<li><p><a href=\"https://github.com/bower/bower/issues/859\">Bower jquery bug</a></p>\n</li>\n<li><p><a href=\"https://docs.google.com/document/d/1APq7oA9tNao1UYWyOm8dKqlRP2blVkROYLZ2fLIjtWc/edit#heading=h.4pzytc1f9j8k\">Bower configuration</a></p>\n</li>\n<li><p><a href=\"http://gruntjs.com/getting-started\">Grunt getting started</a></p>\n</li>\n<li><p><a href=\"http://www.henriquebarroso.com/my-top-10sublime-2-plugins/\">Top 10 SublimeText2 plugins</a></p>\n</li>\n<li><p><a href=\"https://sublime.wbond.net/installation\">Install package control</a></p>\n</li>\n<li><p><a href=\"https://developers.google.com/chrome-developer-tools/docs/console#using_the_console_api\">Using the console API</a></p>\n</li>\n<li><p><a href=\"http://git-scm.com/book/en/Getting-Started-Installing-Git\">Getting Started Installing Git</a></p>\n</li>\n<li><p><a href=\"http://nvie.com/posts/a-successful-git-branching-model/\">A successful Git branching model</a></p>\n</li>\n<li><p><a href=\"https://sandofsky.com/blog/git-workflow.html\">Understanding the Git Workflow</a></p>\n</li>\n<li><p><a href=\"https://help.github.com/articles/generating-ssh-keys\">Generating SSH Keys</a></p>\n</li>\n</ol>"},{"layout":"post","title":"Stylus使用指南","_content":"\n![Stylus Logo](/images/stylus.jpg)\nStylus似乎并不是很有名，以至于很多人不知道它是做什么的，但提到SASS相信有不少人听说过甚至使用过很长时间。其实无论是LESS、SASS还是Stylus甚至是Absurd这些预处理工具，都是对CSS的一种延伸和强化。出现这些工具的原因很简单，CSS本身只是一种描述性质的东西，甚至它不能算是语言而是样式表，所以我们需要一个有条件语句和变量甚至是函数的东西去动态生成CSS代码来达到提高效率和增强可维护性的目的。\n\n本文主要以Stylus语法本身和简单的使用为主要内容，它的目的是介绍和简单指南。将不会过多涉及Javascript的API调用等问题。\n\n### 介绍 ###\n\n官方的介绍非常简短而精炼：\n\n>Expressive, dynamic, robust CSS\n\n<!-- more -->\n富有表现力的动态的强壮的CSS，它反应了一些主要特点。\n\n首先Stylus相较于SASS更加简洁，甚至冒号也都可以省略，初学Stylus时感到它太神奇了，仅仅以空格分隔属性名和多个属性值就可以生成想要的CSS，而且还可以拼接字符串等等。与此同时，类似Ruby或Python完善的缩进语法，Stylus在简约自由中有效的防止了语法歧义。\n\n```\nbody\n  border 10px*.1 soli+'d' darken(red,10%)\n\n// =>\nbody {\n    border: 1px solid #e60000;\n}\n```\n\n其次是动态，这正是其精髓所在，Stylus由Javascript编译，其结构语句也和Javascript相差不多，前端人员可以很轻松的上手。虽然这方面Absurd是一个极端，但Stylus较之LESS则要优越不少，不仅仅是可定义变量，如Javascript般的条件语句和循环语句也为Stylus带来各种可能，加上丰富的内置函数，可以轻松判断和操作各种变量。而利用这样的动态性，就可以写出非常强壮的CSS以满足不同环境和条件下的需要。\n\n```\npos(type, args)\n  i = 0\n  position unquote(type)\n  {args[i]} args[i + 1] is a 'unit' ? args[i += 1] : 0\n  {args[i += 1]} args[i + 1] is a 'unit' ? args[i += 1] : 0\n\nabsolute()\n  pos('absolute', arguments)\nfixed()\n  pos('fixed', arguments)\n\n#prompt\n  absolute top 150px left 5px\n  width 200px\n  margin-left -(@width / 2)\n#logo\n  fixed top left\n\n// =>\n#prompt {\n  position: absolute;\n  top: 150px;\n  left: 5px;\n  width: 200px;\n  margin-left: -100px;\n}\n#logo {\n  position: fixed;\n  top: 0;\n  left: 0;\n}\n```\n\n### 简单指南 ###\n\n可以看到上面的代码中使用了Mixin（混合）还有三目运算符等手段构建了一个针对position的方法，用来快速生成一个定位代码片段。有底向上来看这段代码，#prompt和#logo是2个ID选择器，在其中调用了一些Mixin，其实Mixin与Function的区别在于，Mixin的内容是一段CSS代码，而Function应该是一个值并自动返回，所以调用它们的时候，前者将会替换为一段CSS，而后者将返回一个Boolean或者像素或者颜色之类的东西，也许用于判断也许直接放入CSS。然后其中的absolute和fixed分别调用了pos这个Mixin。\n\n##### 前缀 ######\n\n而且在调用时，也不一定要使用括号的形式，可以使用CSS的形式，直接Mixin名加空格然后写参数。所以有时候可以直接写一个Mixin来修改CSS属性的功能，比如看看下面这个兼容所有标准浏览器阴影的写法，可以很方便的为标准调用加上各标准浏览器的前缀：\n\n```\nbox-shadow()\n  -webkit-box-shadow arguments\n  -moz-box-shadow arguments\n  -ms-box-shadow arguments\n  -o-box-shadow arguments\n  box-shadow arguments\nbox-shadow 2px 1px 10px red\n\n// =>\n-webkit-box-shadow: 2px 1px 10px #f00;\n-moz-box-shadow: 2px 1px 10px #f00;\n-ms-box-shadow: 2px 1px 10px #f00;\n-o-box-shadow: 2px 1px 10px #f00;\nbox-shadow: 2px 1px 10px #f00;\n```\n可以看到调用时的写法与一般的写法一样，但是因为Mixin的存在，box-shadow不再是一个属性，可以变成5行带有各浏览器前缀的CSS。不仅仅是box-shadow，CSS3的许多属性都需要添加前缀，那是不是可以更近一步呢，来写一个前缀Mixin吧：\n\n```\n// add prefix for attribute\nprefix(p_attr, argu...)\n  $pfs = webkit moz ms o\n  for $pf in $pfs\n    -{$pf}-{p_attr} argu\n  {p_attr} argu\n// box shadow mixin\nbox-shadow()\n  prefix(box-shadow, arguments)\n// run\nbox-shadow 2px 1px 10px red\n```\n\n##### 颜色 #####\n\n如同其他CSS预处理工具一样，Stylus在颜色方面也拥有许多内置函数，无论是判断，提取还是修改都十分强大。函数 `red` , `blue` , `green` , `alpha` 将分别返回颜色对应的rgba值，`dark` 和 `light` 用于判断颜色属于亮色还是暗色，`hue` , `saturation` , `lightness` 则分别返回颜色的色相、饱和度以及亮度，其中色相是在色环上的角度，单位是deg。我经常用的是`lighten` 和 `darken` 这两个函数，其作用是增加或减少一个颜色的亮度，另外还有饱和度的操作函数 `desaturate` 和 `satucate`。\n\n似乎没有用于修改色相的函数，不过这个需求很容易通过其他办法搞定。首先使用hue等函数将原始色的色相、饱和度、亮度以及透明度取出，然后对色相的角度进行修改，比如加90deg，最后再使用hsla函数，把去除的对应值当作参数传入即可。下面用一组三态按钮来举个栗子：\n\n<p data-height=\"300\" data-theme-id=\"1870\" data-slug-hash=\"CKrwL\" data-user=\"tychio\" data-default-tab=\"result\" class='codepen'>See the Pen <a href='http://codepen.io/tychio/pen/CKrwL'>Single Button</a> by Zhang zhengzheng (<a href='http://codepen.io/tychio'>@tychio</a>) on <a href='http://codepen.io'>CodePen</a></p>\n<script async src=\"//codepen.io/assets/embed/ei.js\"></script>\n\n可以看到Stylus中的第一行代码 `$clr = #99ff22` 只要修改这个颜色值就可以改变按钮的整体风格，并无需考虑hover和active状态时对应的颜色。比如边框使用 `darken` 来加深，阴影泛光可以使用 `lighten` 来加亮，在触碰时整体使用了 `saturate` 来改变饱和度，按下的Active状态我使用了 `invert` 函数，可以翻转颜色，在视觉设计中这个颜色叫做对位色，即色相处于色环的对面的两种颜色，比如绿对红，黄对蓝，例子中使用了黄绿，所以对位色就是紫色。当然也可以使用上面提到的复杂一些的方法来修改色相，达到使用间隔色之类的效果。\n\n##### 响应式 #####\n\n对于响应式的支持，Stylus的media也可以省略花括号，但和Sass有一些区别。Stylus在@media的括号中会原样输出，也就是说，我们不能使用变量或混合还有计算等手段来直接写media query。比如一般情况下需要写一个min-width，如果这样写\n\n```\n$mobiWidth = 768px\n@media screen and (min-width $mobiWidth - 1px)\n  body\n    margin 0\n```\n\n产生的CSS代码则仍然是\n\n```\n@media screen and (min-width $mobiWidth - 1px) {\n  body {\n    margin: 0;\n  }\n}\n```\n\n这不是一个bug，尽管在Github上有无数的人提出issue或者在其后+1，作者仍然不为所动，原因不明，不过幸运地是有很多人都提出解决办法，下面是一个比较好的方法：\n\n```\nmedia()\n  join(' and ', arguments)\n$mobiWidth = 768px\n$media = media('screen', '(min-width: ' + ($mobiWidth - 1px) + ')')\n@media $media\n  body\n    margin 0\n\n/// =>\n\n@media screen and (min-width: 767px) {\n  body {\n    margin: 0;\n  }\n}\n```\n这样就可以使用变量来作为media的参数了，只是写起来会比sass麻烦一些，但我觉得这样也许更自由，你可以改进这个方法，比如传一个object来作为query条件，而不是拼接一个字符串。另外这个方法还用到了 `join` 内置函数，和Javascript中的Array方法join一样，很容易使用，除了它还有 `push` , `unshift` 函数。\n\n关于数组的定义，对于响应式来说有非常好的帮助，因为响应式往往是一系列的尺寸或设备，无论如何，使用数组可以轻松的定义多组对应与索引的配套值。比如我的blog，对于不同宽度的设备中有不同的内容宽度以及边距，来看看简化的代码：\n\n```\n$screen = 1920px 1280px 1024px 768px 640px 320px\n$width = 1600px 1080px 840px 600px 480px 300px\n$margin = 180px 100px 80px 40px 20px 0\nmedia()\n  join(' and ', arguments)\nresponsive(p_index)\n  body\n    width $width[p_index]\n    margin-left $margin[p_index]\nresponsive(0)\nfor $i in 0 1 2 3 4 5\n  $media = media('screen', '(max-width: ' + $screen[$i] + ')')\n  @media $media\n      responsive($i)\n\n// =>\nbody {\n  width: 1600px;\n  margin-left: 180px;\n}\n@media screen and (max-width: 1920px) {\n  body {\n    width: 1600px;\n    margin-left: 180px;\n  }\n}\n// ...\n@media screen and (max-width: 320px) {\n  body {\n    width: 300px;\n    margin-left: 0;\n  }\n}\n\n```\n\n当然响应式不是简单的改变尺寸，如果你需要控制某些内容的显示则可以使用一个Boolean的数组来判断是否显示，控制结构或样式则可以字符串的数组来放置一些预先写好的Mixin名称。\n\n##### CSS Sprite #####\n\n对于CSS Sprite相信是所有切图者的主要工作产出，以前我也推荐过一些在线的制作Sprite的工具，不过现在有了Stylus，也许我们可能更快的完成这一切。之前公司有需要国旗icon，所以做了这个小项目[national_flag](https://github.com/tychio/national_flag)用来创建和维护国旗icon的CSS Sprite。由于国家数目众多，每个国家对应一个国家代码，所以我定义了一个二维数组用来表现图片中国旗的位置，然后在数组中填入代码，用来拼接图标的class名称，然后按照数组中的序号和尺寸就可以生成对应的background-position了。主要代码如下：\n\n```\niconBuild(id, col, row)\n    .country-{id}\n        background-position (0px - (row * $size)) (0px - (col * $size))\n/*r /c-> 00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16*/\n$row00 = CN AF AZ BH BD BN KH TL IN ID IR IQ IL JP JO KZ KW\n$row01 = KG LA LB MY MV MN MM NP KP OM PK PS PH QA SA SG KR\n$row02 = LK SY TJ TH TM AE UZ VN YE DZ AO BJ BW BF BI CM CV\n$row03 = CF RO KM CG CI CD DJ EG GQ ER ET GA GH GN GW KE LS\n$row04 = LR __ MG MW ML MR MU MA MZ NA NE NG RW ST SN SC SL\n$row05 = SO ZA SD __ TZ __ TG TN UG ZM ZW __ __ __ __ __ __\n$row06 = JM PR DO KN VC LC TT CR __ SV GT HN NI PA __ DE __\n$row07 = MK AT __ __ __ BG CY __ __ DK SK SI ES EE FI FR __\n$row08 = GR HU IE IS IT LV LI LT LU MT MD MC ME NO NL PL PT\n$row09 = UK CZ __ RU SM __ SE CH TR UA EU __ CA __ MX __ US\n$row10 = AR BO BR CL CO EC GY __ __ PE __ UY VE HK LY NZ RS\n$row11 = PY AU SR TJ FM AI __ __ __ __ __ __ __ __ __ __ __\n$pos = $row00 $row01 $row02 $row03 $row04 $row05 $row06 $row07 $row08 $row09 $row10 $row11\nfor $rowList, $row in $pos\n    for $country, $col in $rowList\n        if $country != __\n            iconBuild($country, $row, $col)\n```\n其中for不同于Javascript，rowList为数组遍历出的一个元素，而$row为索引，可以这样理解 `for [value], [index] in [array]` 。所以可以在两个嵌套的for中获取纵横的位置以及国家代码，来生成CSS。\n\n### Stylue应用 ###\n\n作为预处理工具，Stylus自然也需要预处理器，不过它不像Sass需要Ruby环境，Stylus由Javascript实现，所以有Javascript就可以处理Stylus。\n\n##### 编译工具 #####\n\n* [SublimeText2-Stylus2CSS](https://github.com/edmundask/SublimeText2-Stylus2CSS)是一款SublimeText2的Stylus插件。另外我使用[这个项目](https://github.com/billymoon/Stylus)的SublimeText2插件来高亮styl文件的代码。\n* 另外今年8月WebStorm7也才刚刚支持 - [Stylus Support](http://blog.jetbrains.com/webstorm/2013/08/webstorm-7-eap-130-1630-stylus-support/)。\n* [CodePen](http://codepen.io/)支持各种CSS预处理，自然包括Stylus，上面的按钮例子就是嵌入的CodePen。\n* [Stylus官方在线](http://learnboost.github.io/stylus/try.html)其实是一些示例，不过它是可编辑的，所以你也可以随便写些什么，即时可以看到结果。不过好像还在使用低版本的Stylus，比如一些内置函数就不可用。\n\n##### Grunt插件 #####\n\n不过说到处理文件，Grunt还是我的最爱，尤其Stylus是由Javascript实现，在Nodejs中自然是得天独厚。npmjs上有许多用来处理Stylus的插件，下面简单介绍一下Grunt的官方Stylus插件[grunt-contrib-stylus](https://npmjs.org/package/grunt-contrib-stylus)。先来看看最简单的配置方法：\n\n```\nstylus: {\n  compile: {\n    files: {\n      'path/to/result.css': 'path/to/source.styl'\n    }\n  }\n}\n```\n如此就可以利用Grunt将source.styl文件中的Stylus代码编译为result.css的CSS代码。当然还可以使用数组来进行多个Stylus文件的打包编译。当然不仅于此，先来看看主要的几个配置项：\n\n`paths` 将自动使用@import来引入一些Stylus文件，比如一些Mixin集合，放在一个Stylus文件中进行维护，写在paths中后，就可以在每个Stylus文件中调用它们。`define` 可以定义一些全局变量，然后在Stylus中使用，但我不喜欢使用这个配置，而是更喜欢把全局变量放在一个单独的Stylus文件中，然后将这个文件加入paths的数组中。一句话，把所有不会直接产出CSS的Stylus代码分成若干个Stylus文件，然后全部添加到paths中，这样在所有Stylus文件中都可以随时调用了，但要注意这些Stylus文件的调用关系和使用先后顺序。\n\n`compress` 及 `linenos` 是两个Boolean值，用来控制是否压缩处理后的CSS代码以及是否在CSS代码中保留注释。\n\n`banner` 是一个字符串，会被放置在CSS文件的最前面，一般我用来写注释，比如\n\n```\nbanner: '\\/** \\n * <%= pkg.name %> - <%= pkg.description %>\\n * version <%= pkg.version %> \\n * author <%= pkg.author %> \\n * date <%= grunt.template.today() %> \\n**/\\n'\n```\n\n`firebug` 将控制是否使用一个Firebug的Stylus插件[FireStylus for Firebug](https://addons.mozilla.org/en-US/firefox/addon/firestylus-for-firebug/)，可以在Firefox中调试Stylus。\n\n`use` 可以引入一些Stylus的其他grunt插件。\n\n配合watch等Grunt插件就可以达到自动化的Stylus开发，写样式将会非常有效率。\n\n### 总结 ###\n\nStylus是一个由Javascript实现的CSS预处理工具，文件后缀为styl，其拥有变量、函数、混合、条件及循环语句等功能，还有丰富的内置函数用于处理颜色、数字、数组等数据。在grunt的辅助下，Stylus将带来极大的开发效率。\n\n我还在[slides](http://slid.es)上制作了一个[Stylus简介的幻灯片](http://slid.es/tychio/stylus)，还没有经过实践，可能内容有些空泛，不过将持续改进。","source":"_posts/2013-11-16-stylus-guide.md","raw":"---\nlayout: post\ntitle: Stylus使用指南\ntags: [css,stylus,sass,less]\ncategory: Tech\n---\n\n![Stylus Logo](/images/stylus.jpg)\nStylus似乎并不是很有名，以至于很多人不知道它是做什么的，但提到SASS相信有不少人听说过甚至使用过很长时间。其实无论是LESS、SASS还是Stylus甚至是Absurd这些预处理工具，都是对CSS的一种延伸和强化。出现这些工具的原因很简单，CSS本身只是一种描述性质的东西，甚至它不能算是语言而是样式表，所以我们需要一个有条件语句和变量甚至是函数的东西去动态生成CSS代码来达到提高效率和增强可维护性的目的。\n\n本文主要以Stylus语法本身和简单的使用为主要内容，它的目的是介绍和简单指南。将不会过多涉及Javascript的API调用等问题。\n\n### 介绍 ###\n\n官方的介绍非常简短而精炼：\n\n>Expressive, dynamic, robust CSS\n\n<!-- more -->\n富有表现力的动态的强壮的CSS，它反应了一些主要特点。\n\n首先Stylus相较于SASS更加简洁，甚至冒号也都可以省略，初学Stylus时感到它太神奇了，仅仅以空格分隔属性名和多个属性值就可以生成想要的CSS，而且还可以拼接字符串等等。与此同时，类似Ruby或Python完善的缩进语法，Stylus在简约自由中有效的防止了语法歧义。\n\n```\nbody\n  border 10px*.1 soli+'d' darken(red,10%)\n\n// =>\nbody {\n    border: 1px solid #e60000;\n}\n```\n\n其次是动态，这正是其精髓所在，Stylus由Javascript编译，其结构语句也和Javascript相差不多，前端人员可以很轻松的上手。虽然这方面Absurd是一个极端，但Stylus较之LESS则要优越不少，不仅仅是可定义变量，如Javascript般的条件语句和循环语句也为Stylus带来各种可能，加上丰富的内置函数，可以轻松判断和操作各种变量。而利用这样的动态性，就可以写出非常强壮的CSS以满足不同环境和条件下的需要。\n\n```\npos(type, args)\n  i = 0\n  position unquote(type)\n  {args[i]} args[i + 1] is a 'unit' ? args[i += 1] : 0\n  {args[i += 1]} args[i + 1] is a 'unit' ? args[i += 1] : 0\n\nabsolute()\n  pos('absolute', arguments)\nfixed()\n  pos('fixed', arguments)\n\n#prompt\n  absolute top 150px left 5px\n  width 200px\n  margin-left -(@width / 2)\n#logo\n  fixed top left\n\n// =>\n#prompt {\n  position: absolute;\n  top: 150px;\n  left: 5px;\n  width: 200px;\n  margin-left: -100px;\n}\n#logo {\n  position: fixed;\n  top: 0;\n  left: 0;\n}\n```\n\n### 简单指南 ###\n\n可以看到上面的代码中使用了Mixin（混合）还有三目运算符等手段构建了一个针对position的方法，用来快速生成一个定位代码片段。有底向上来看这段代码，#prompt和#logo是2个ID选择器，在其中调用了一些Mixin，其实Mixin与Function的区别在于，Mixin的内容是一段CSS代码，而Function应该是一个值并自动返回，所以调用它们的时候，前者将会替换为一段CSS，而后者将返回一个Boolean或者像素或者颜色之类的东西，也许用于判断也许直接放入CSS。然后其中的absolute和fixed分别调用了pos这个Mixin。\n\n##### 前缀 ######\n\n而且在调用时，也不一定要使用括号的形式，可以使用CSS的形式，直接Mixin名加空格然后写参数。所以有时候可以直接写一个Mixin来修改CSS属性的功能，比如看看下面这个兼容所有标准浏览器阴影的写法，可以很方便的为标准调用加上各标准浏览器的前缀：\n\n```\nbox-shadow()\n  -webkit-box-shadow arguments\n  -moz-box-shadow arguments\n  -ms-box-shadow arguments\n  -o-box-shadow arguments\n  box-shadow arguments\nbox-shadow 2px 1px 10px red\n\n// =>\n-webkit-box-shadow: 2px 1px 10px #f00;\n-moz-box-shadow: 2px 1px 10px #f00;\n-ms-box-shadow: 2px 1px 10px #f00;\n-o-box-shadow: 2px 1px 10px #f00;\nbox-shadow: 2px 1px 10px #f00;\n```\n可以看到调用时的写法与一般的写法一样，但是因为Mixin的存在，box-shadow不再是一个属性，可以变成5行带有各浏览器前缀的CSS。不仅仅是box-shadow，CSS3的许多属性都需要添加前缀，那是不是可以更近一步呢，来写一个前缀Mixin吧：\n\n```\n// add prefix for attribute\nprefix(p_attr, argu...)\n  $pfs = webkit moz ms o\n  for $pf in $pfs\n    -{$pf}-{p_attr} argu\n  {p_attr} argu\n// box shadow mixin\nbox-shadow()\n  prefix(box-shadow, arguments)\n// run\nbox-shadow 2px 1px 10px red\n```\n\n##### 颜色 #####\n\n如同其他CSS预处理工具一样，Stylus在颜色方面也拥有许多内置函数，无论是判断，提取还是修改都十分强大。函数 `red` , `blue` , `green` , `alpha` 将分别返回颜色对应的rgba值，`dark` 和 `light` 用于判断颜色属于亮色还是暗色，`hue` , `saturation` , `lightness` 则分别返回颜色的色相、饱和度以及亮度，其中色相是在色环上的角度，单位是deg。我经常用的是`lighten` 和 `darken` 这两个函数，其作用是增加或减少一个颜色的亮度，另外还有饱和度的操作函数 `desaturate` 和 `satucate`。\n\n似乎没有用于修改色相的函数，不过这个需求很容易通过其他办法搞定。首先使用hue等函数将原始色的色相、饱和度、亮度以及透明度取出，然后对色相的角度进行修改，比如加90deg，最后再使用hsla函数，把去除的对应值当作参数传入即可。下面用一组三态按钮来举个栗子：\n\n<p data-height=\"300\" data-theme-id=\"1870\" data-slug-hash=\"CKrwL\" data-user=\"tychio\" data-default-tab=\"result\" class='codepen'>See the Pen <a href='http://codepen.io/tychio/pen/CKrwL'>Single Button</a> by Zhang zhengzheng (<a href='http://codepen.io/tychio'>@tychio</a>) on <a href='http://codepen.io'>CodePen</a></p>\n<script async src=\"//codepen.io/assets/embed/ei.js\"></script>\n\n可以看到Stylus中的第一行代码 `$clr = #99ff22` 只要修改这个颜色值就可以改变按钮的整体风格，并无需考虑hover和active状态时对应的颜色。比如边框使用 `darken` 来加深，阴影泛光可以使用 `lighten` 来加亮，在触碰时整体使用了 `saturate` 来改变饱和度，按下的Active状态我使用了 `invert` 函数，可以翻转颜色，在视觉设计中这个颜色叫做对位色，即色相处于色环的对面的两种颜色，比如绿对红，黄对蓝，例子中使用了黄绿，所以对位色就是紫色。当然也可以使用上面提到的复杂一些的方法来修改色相，达到使用间隔色之类的效果。\n\n##### 响应式 #####\n\n对于响应式的支持，Stylus的media也可以省略花括号，但和Sass有一些区别。Stylus在@media的括号中会原样输出，也就是说，我们不能使用变量或混合还有计算等手段来直接写media query。比如一般情况下需要写一个min-width，如果这样写\n\n```\n$mobiWidth = 768px\n@media screen and (min-width $mobiWidth - 1px)\n  body\n    margin 0\n```\n\n产生的CSS代码则仍然是\n\n```\n@media screen and (min-width $mobiWidth - 1px) {\n  body {\n    margin: 0;\n  }\n}\n```\n\n这不是一个bug，尽管在Github上有无数的人提出issue或者在其后+1，作者仍然不为所动，原因不明，不过幸运地是有很多人都提出解决办法，下面是一个比较好的方法：\n\n```\nmedia()\n  join(' and ', arguments)\n$mobiWidth = 768px\n$media = media('screen', '(min-width: ' + ($mobiWidth - 1px) + ')')\n@media $media\n  body\n    margin 0\n\n/// =>\n\n@media screen and (min-width: 767px) {\n  body {\n    margin: 0;\n  }\n}\n```\n这样就可以使用变量来作为media的参数了，只是写起来会比sass麻烦一些，但我觉得这样也许更自由，你可以改进这个方法，比如传一个object来作为query条件，而不是拼接一个字符串。另外这个方法还用到了 `join` 内置函数，和Javascript中的Array方法join一样，很容易使用，除了它还有 `push` , `unshift` 函数。\n\n关于数组的定义，对于响应式来说有非常好的帮助，因为响应式往往是一系列的尺寸或设备，无论如何，使用数组可以轻松的定义多组对应与索引的配套值。比如我的blog，对于不同宽度的设备中有不同的内容宽度以及边距，来看看简化的代码：\n\n```\n$screen = 1920px 1280px 1024px 768px 640px 320px\n$width = 1600px 1080px 840px 600px 480px 300px\n$margin = 180px 100px 80px 40px 20px 0\nmedia()\n  join(' and ', arguments)\nresponsive(p_index)\n  body\n    width $width[p_index]\n    margin-left $margin[p_index]\nresponsive(0)\nfor $i in 0 1 2 3 4 5\n  $media = media('screen', '(max-width: ' + $screen[$i] + ')')\n  @media $media\n      responsive($i)\n\n// =>\nbody {\n  width: 1600px;\n  margin-left: 180px;\n}\n@media screen and (max-width: 1920px) {\n  body {\n    width: 1600px;\n    margin-left: 180px;\n  }\n}\n// ...\n@media screen and (max-width: 320px) {\n  body {\n    width: 300px;\n    margin-left: 0;\n  }\n}\n\n```\n\n当然响应式不是简单的改变尺寸，如果你需要控制某些内容的显示则可以使用一个Boolean的数组来判断是否显示，控制结构或样式则可以字符串的数组来放置一些预先写好的Mixin名称。\n\n##### CSS Sprite #####\n\n对于CSS Sprite相信是所有切图者的主要工作产出，以前我也推荐过一些在线的制作Sprite的工具，不过现在有了Stylus，也许我们可能更快的完成这一切。之前公司有需要国旗icon，所以做了这个小项目[national_flag](https://github.com/tychio/national_flag)用来创建和维护国旗icon的CSS Sprite。由于国家数目众多，每个国家对应一个国家代码，所以我定义了一个二维数组用来表现图片中国旗的位置，然后在数组中填入代码，用来拼接图标的class名称，然后按照数组中的序号和尺寸就可以生成对应的background-position了。主要代码如下：\n\n```\niconBuild(id, col, row)\n    .country-{id}\n        background-position (0px - (row * $size)) (0px - (col * $size))\n/*r /c-> 00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16*/\n$row00 = CN AF AZ BH BD BN KH TL IN ID IR IQ IL JP JO KZ KW\n$row01 = KG LA LB MY MV MN MM NP KP OM PK PS PH QA SA SG KR\n$row02 = LK SY TJ TH TM AE UZ VN YE DZ AO BJ BW BF BI CM CV\n$row03 = CF RO KM CG CI CD DJ EG GQ ER ET GA GH GN GW KE LS\n$row04 = LR __ MG MW ML MR MU MA MZ NA NE NG RW ST SN SC SL\n$row05 = SO ZA SD __ TZ __ TG TN UG ZM ZW __ __ __ __ __ __\n$row06 = JM PR DO KN VC LC TT CR __ SV GT HN NI PA __ DE __\n$row07 = MK AT __ __ __ BG CY __ __ DK SK SI ES EE FI FR __\n$row08 = GR HU IE IS IT LV LI LT LU MT MD MC ME NO NL PL PT\n$row09 = UK CZ __ RU SM __ SE CH TR UA EU __ CA __ MX __ US\n$row10 = AR BO BR CL CO EC GY __ __ PE __ UY VE HK LY NZ RS\n$row11 = PY AU SR TJ FM AI __ __ __ __ __ __ __ __ __ __ __\n$pos = $row00 $row01 $row02 $row03 $row04 $row05 $row06 $row07 $row08 $row09 $row10 $row11\nfor $rowList, $row in $pos\n    for $country, $col in $rowList\n        if $country != __\n            iconBuild($country, $row, $col)\n```\n其中for不同于Javascript，rowList为数组遍历出的一个元素，而$row为索引，可以这样理解 `for [value], [index] in [array]` 。所以可以在两个嵌套的for中获取纵横的位置以及国家代码，来生成CSS。\n\n### Stylue应用 ###\n\n作为预处理工具，Stylus自然也需要预处理器，不过它不像Sass需要Ruby环境，Stylus由Javascript实现，所以有Javascript就可以处理Stylus。\n\n##### 编译工具 #####\n\n* [SublimeText2-Stylus2CSS](https://github.com/edmundask/SublimeText2-Stylus2CSS)是一款SublimeText2的Stylus插件。另外我使用[这个项目](https://github.com/billymoon/Stylus)的SublimeText2插件来高亮styl文件的代码。\n* 另外今年8月WebStorm7也才刚刚支持 - [Stylus Support](http://blog.jetbrains.com/webstorm/2013/08/webstorm-7-eap-130-1630-stylus-support/)。\n* [CodePen](http://codepen.io/)支持各种CSS预处理，自然包括Stylus，上面的按钮例子就是嵌入的CodePen。\n* [Stylus官方在线](http://learnboost.github.io/stylus/try.html)其实是一些示例，不过它是可编辑的，所以你也可以随便写些什么，即时可以看到结果。不过好像还在使用低版本的Stylus，比如一些内置函数就不可用。\n\n##### Grunt插件 #####\n\n不过说到处理文件，Grunt还是我的最爱，尤其Stylus是由Javascript实现，在Nodejs中自然是得天独厚。npmjs上有许多用来处理Stylus的插件，下面简单介绍一下Grunt的官方Stylus插件[grunt-contrib-stylus](https://npmjs.org/package/grunt-contrib-stylus)。先来看看最简单的配置方法：\n\n```\nstylus: {\n  compile: {\n    files: {\n      'path/to/result.css': 'path/to/source.styl'\n    }\n  }\n}\n```\n如此就可以利用Grunt将source.styl文件中的Stylus代码编译为result.css的CSS代码。当然还可以使用数组来进行多个Stylus文件的打包编译。当然不仅于此，先来看看主要的几个配置项：\n\n`paths` 将自动使用@import来引入一些Stylus文件，比如一些Mixin集合，放在一个Stylus文件中进行维护，写在paths中后，就可以在每个Stylus文件中调用它们。`define` 可以定义一些全局变量，然后在Stylus中使用，但我不喜欢使用这个配置，而是更喜欢把全局变量放在一个单独的Stylus文件中，然后将这个文件加入paths的数组中。一句话，把所有不会直接产出CSS的Stylus代码分成若干个Stylus文件，然后全部添加到paths中，这样在所有Stylus文件中都可以随时调用了，但要注意这些Stylus文件的调用关系和使用先后顺序。\n\n`compress` 及 `linenos` 是两个Boolean值，用来控制是否压缩处理后的CSS代码以及是否在CSS代码中保留注释。\n\n`banner` 是一个字符串，会被放置在CSS文件的最前面，一般我用来写注释，比如\n\n```\nbanner: '\\/** \\n * <%= pkg.name %> - <%= pkg.description %>\\n * version <%= pkg.version %> \\n * author <%= pkg.author %> \\n * date <%= grunt.template.today() %> \\n**/\\n'\n```\n\n`firebug` 将控制是否使用一个Firebug的Stylus插件[FireStylus for Firebug](https://addons.mozilla.org/en-US/firefox/addon/firestylus-for-firebug/)，可以在Firefox中调试Stylus。\n\n`use` 可以引入一些Stylus的其他grunt插件。\n\n配合watch等Grunt插件就可以达到自动化的Stylus开发，写样式将会非常有效率。\n\n### 总结 ###\n\nStylus是一个由Javascript实现的CSS预处理工具，文件后缀为styl，其拥有变量、函数、混合、条件及循环语句等功能，还有丰富的内置函数用于处理颜色、数字、数组等数据。在grunt的辅助下，Stylus将带来极大的开发效率。\n\n我还在[slides](http://slid.es)上制作了一个[Stylus简介的幻灯片](http://slid.es/tychio/stylus)，还没有经过实践，可能内容有些空泛，不过将持续改进。","slug":"stylus-guide","published":1,"date":"2013-11-15T16:00:00.000Z","updated":"2021-11-28T11:59:29.970Z","_id":"ckwj65516000qvyjhbf6h5t3m","comments":1,"photos":[],"link":"","content":"<p><img src=\"/images/stylus.jpg\" alt=\"Stylus Logo\"><br>Stylus似乎并不是很有名，以至于很多人不知道它是做什么的，但提到SASS相信有不少人听说过甚至使用过很长时间。其实无论是LESS、SASS还是Stylus甚至是Absurd这些预处理工具，都是对CSS的一种延伸和强化。出现这些工具的原因很简单，CSS本身只是一种描述性质的东西，甚至它不能算是语言而是样式表，所以我们需要一个有条件语句和变量甚至是函数的东西去动态生成CSS代码来达到提高效率和增强可维护性的目的。</p>\n<p>本文主要以Stylus语法本身和简单的使用为主要内容，它的目的是介绍和简单指南。将不会过多涉及Javascript的API调用等问题。</p>\n<h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>官方的介绍非常简短而精炼：</p>\n<blockquote>\n<p>Expressive, dynamic, robust CSS</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>富有表现力的动态的强壮的CSS，它反应了一些主要特点。</p>\n<p>首先Stylus相较于SASS更加简洁，甚至冒号也都可以省略，初学Stylus时感到它太神奇了，仅仅以空格分隔属性名和多个属性值就可以生成想要的CSS，而且还可以拼接字符串等等。与此同时，类似Ruby或Python完善的缩进语法，Stylus在简约自由中有效的防止了语法歧义。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">body</span><br><span class=\"line\">  border 10px*.1 soli+&#x27;d&#x27; darken(red,10%)</span><br><span class=\"line\"></span><br><span class=\"line\">// =&gt;</span><br><span class=\"line\">body &#123;</span><br><span class=\"line\">    border: 1px solid #e60000;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其次是动态，这正是其精髓所在，Stylus由Javascript编译，其结构语句也和Javascript相差不多，前端人员可以很轻松的上手。虽然这方面Absurd是一个极端，但Stylus较之LESS则要优越不少，不仅仅是可定义变量，如Javascript般的条件语句和循环语句也为Stylus带来各种可能，加上丰富的内置函数，可以轻松判断和操作各种变量。而利用这样的动态性，就可以写出非常强壮的CSS以满足不同环境和条件下的需要。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pos(type, args)</span><br><span class=\"line\">  i = 0</span><br><span class=\"line\">  position unquote(type)</span><br><span class=\"line\">  &#123;args[i]&#125; args[i + 1] is a &#x27;unit&#x27; ? args[i += 1] : 0</span><br><span class=\"line\">  &#123;args[i += 1]&#125; args[i + 1] is a &#x27;unit&#x27; ? args[i += 1] : 0</span><br><span class=\"line\"></span><br><span class=\"line\">absolute()</span><br><span class=\"line\">  pos(&#x27;absolute&#x27;, arguments)</span><br><span class=\"line\">fixed()</span><br><span class=\"line\">  pos(&#x27;fixed&#x27;, arguments)</span><br><span class=\"line\"></span><br><span class=\"line\">#prompt</span><br><span class=\"line\">  absolute top 150px left 5px</span><br><span class=\"line\">  width 200px</span><br><span class=\"line\">  margin-left -(@width / 2)</span><br><span class=\"line\">#logo</span><br><span class=\"line\">  fixed top left</span><br><span class=\"line\"></span><br><span class=\"line\">// =&gt;</span><br><span class=\"line\">#prompt &#123;</span><br><span class=\"line\">  position: absolute;</span><br><span class=\"line\">  top: 150px;</span><br><span class=\"line\">  left: 5px;</span><br><span class=\"line\">  width: 200px;</span><br><span class=\"line\">  margin-left: -100px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">#logo &#123;</span><br><span class=\"line\">  position: fixed;</span><br><span class=\"line\">  top: 0;</span><br><span class=\"line\">  left: 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"简单指南\"><a href=\"#简单指南\" class=\"headerlink\" title=\"简单指南\"></a>简单指南</h3><p>可以看到上面的代码中使用了Mixin（混合）还有三目运算符等手段构建了一个针对position的方法，用来快速生成一个定位代码片段。有底向上来看这段代码，#prompt和#logo是2个ID选择器，在其中调用了一些Mixin，其实Mixin与Function的区别在于，Mixin的内容是一段CSS代码，而Function应该是一个值并自动返回，所以调用它们的时候，前者将会替换为一段CSS，而后者将返回一个Boolean或者像素或者颜色之类的东西，也许用于判断也许直接放入CSS。然后其中的absolute和fixed分别调用了pos这个Mixin。</p>\n<h5 id=\"前缀\"><a href=\"#前缀\" class=\"headerlink\" title=\"前缀\"></a>前缀</h5><p>而且在调用时，也不一定要使用括号的形式，可以使用CSS的形式，直接Mixin名加空格然后写参数。所以有时候可以直接写一个Mixin来修改CSS属性的功能，比如看看下面这个兼容所有标准浏览器阴影的写法，可以很方便的为标准调用加上各标准浏览器的前缀：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">box-shadow()</span><br><span class=\"line\">  -webkit-box-shadow arguments</span><br><span class=\"line\">  -moz-box-shadow arguments</span><br><span class=\"line\">  -ms-box-shadow arguments</span><br><span class=\"line\">  -o-box-shadow arguments</span><br><span class=\"line\">  box-shadow arguments</span><br><span class=\"line\">box-shadow 2px 1px 10px red</span><br><span class=\"line\"></span><br><span class=\"line\">// =&gt;</span><br><span class=\"line\">-webkit-box-shadow: 2px 1px 10px #f00;</span><br><span class=\"line\">-moz-box-shadow: 2px 1px 10px #f00;</span><br><span class=\"line\">-ms-box-shadow: 2px 1px 10px #f00;</span><br><span class=\"line\">-o-box-shadow: 2px 1px 10px #f00;</span><br><span class=\"line\">box-shadow: 2px 1px 10px #f00;</span><br></pre></td></tr></table></figure>\n<p>可以看到调用时的写法与一般的写法一样，但是因为Mixin的存在，box-shadow不再是一个属性，可以变成5行带有各浏览器前缀的CSS。不仅仅是box-shadow，CSS3的许多属性都需要添加前缀，那是不是可以更近一步呢，来写一个前缀Mixin吧：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// add prefix for attribute</span><br><span class=\"line\">prefix(p_attr, argu...)</span><br><span class=\"line\">  $pfs = webkit moz ms o</span><br><span class=\"line\">  for $pf in $pfs</span><br><span class=\"line\">    -&#123;$pf&#125;-&#123;p_attr&#125; argu</span><br><span class=\"line\">  &#123;p_attr&#125; argu</span><br><span class=\"line\">// box shadow mixin</span><br><span class=\"line\">box-shadow()</span><br><span class=\"line\">  prefix(box-shadow, arguments)</span><br><span class=\"line\">// run</span><br><span class=\"line\">box-shadow 2px 1px 10px red</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"颜色\"><a href=\"#颜色\" class=\"headerlink\" title=\"颜色\"></a>颜色</h5><p>如同其他CSS预处理工具一样，Stylus在颜色方面也拥有许多内置函数，无论是判断，提取还是修改都十分强大。函数 <code>red</code> , <code>blue</code> , <code>green</code> , <code>alpha</code> 将分别返回颜色对应的rgba值，<code>dark</code> 和 <code>light</code> 用于判断颜色属于亮色还是暗色，<code>hue</code> , <code>saturation</code> , <code>lightness</code> 则分别返回颜色的色相、饱和度以及亮度，其中色相是在色环上的角度，单位是deg。我经常用的是<code>lighten</code> 和 <code>darken</code> 这两个函数，其作用是增加或减少一个颜色的亮度，另外还有饱和度的操作函数 <code>desaturate</code> 和 <code>satucate</code>。</p>\n<p>似乎没有用于修改色相的函数，不过这个需求很容易通过其他办法搞定。首先使用hue等函数将原始色的色相、饱和度、亮度以及透明度取出，然后对色相的角度进行修改，比如加90deg，最后再使用hsla函数，把去除的对应值当作参数传入即可。下面用一组三态按钮来举个栗子：</p>\n<p data-height=\"300\" data-theme-id=\"1870\" data-slug-hash=\"CKrwL\" data-user=\"tychio\" data-default-tab=\"result\" class=\"codepen\">See the Pen <a href=\"http://codepen.io/tychio/pen/CKrwL\">Single Button</a> by Zhang zhengzheng (<a href=\"http://codepen.io/tychio\">@tychio</a>) on <a href=\"http://codepen.io\">CodePen</a></p>\n<script async src=\"//codepen.io/assets/embed/ei.js\"></script>\n\n<p>可以看到Stylus中的第一行代码 <code>$clr = #99ff22</code> 只要修改这个颜色值就可以改变按钮的整体风格，并无需考虑hover和active状态时对应的颜色。比如边框使用 <code>darken</code> 来加深，阴影泛光可以使用 <code>lighten</code> 来加亮，在触碰时整体使用了 <code>saturate</code> 来改变饱和度，按下的Active状态我使用了 <code>invert</code> 函数，可以翻转颜色，在视觉设计中这个颜色叫做对位色，即色相处于色环的对面的两种颜色，比如绿对红，黄对蓝，例子中使用了黄绿，所以对位色就是紫色。当然也可以使用上面提到的复杂一些的方法来修改色相，达到使用间隔色之类的效果。</p>\n<h5 id=\"响应式\"><a href=\"#响应式\" class=\"headerlink\" title=\"响应式\"></a>响应式</h5><p>对于响应式的支持，Stylus的media也可以省略花括号，但和Sass有一些区别。Stylus在@media的括号中会原样输出，也就是说，我们不能使用变量或混合还有计算等手段来直接写media query。比如一般情况下需要写一个min-width，如果这样写</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$mobiWidth = 768px</span><br><span class=\"line\">@media screen and (min-width $mobiWidth - 1px)</span><br><span class=\"line\">  body</span><br><span class=\"line\">    margin 0</span><br></pre></td></tr></table></figure>\n\n<p>产生的CSS代码则仍然是</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@media screen and (min-width $mobiWidth - 1px) &#123;</span><br><span class=\"line\">  body &#123;</span><br><span class=\"line\">    margin: 0;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这不是一个bug，尽管在Github上有无数的人提出issue或者在其后+1，作者仍然不为所动，原因不明，不过幸运地是有很多人都提出解决办法，下面是一个比较好的方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">media()</span><br><span class=\"line\">  join(&#x27; and &#x27;, arguments)</span><br><span class=\"line\">$mobiWidth = 768px</span><br><span class=\"line\">$media = media(&#x27;screen&#x27;, &#x27;(min-width: &#x27; + ($mobiWidth - 1px) + &#x27;)&#x27;)</span><br><span class=\"line\">@media $media</span><br><span class=\"line\">  body</span><br><span class=\"line\">    margin 0</span><br><span class=\"line\"></span><br><span class=\"line\">/// =&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@media screen and (min-width: 767px) &#123;</span><br><span class=\"line\">  body &#123;</span><br><span class=\"line\">    margin: 0;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样就可以使用变量来作为media的参数了，只是写起来会比sass麻烦一些，但我觉得这样也许更自由，你可以改进这个方法，比如传一个object来作为query条件，而不是拼接一个字符串。另外这个方法还用到了 <code>join</code> 内置函数，和Javascript中的Array方法join一样，很容易使用，除了它还有 <code>push</code> , <code>unshift</code> 函数。</p>\n<p>关于数组的定义，对于响应式来说有非常好的帮助，因为响应式往往是一系列的尺寸或设备，无论如何，使用数组可以轻松的定义多组对应与索引的配套值。比如我的blog，对于不同宽度的设备中有不同的内容宽度以及边距，来看看简化的代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$screen = 1920px 1280px 1024px 768px 640px 320px</span><br><span class=\"line\">$width = 1600px 1080px 840px 600px 480px 300px</span><br><span class=\"line\">$margin = 180px 100px 80px 40px 20px 0</span><br><span class=\"line\">media()</span><br><span class=\"line\">  join(&#x27; and &#x27;, arguments)</span><br><span class=\"line\">responsive(p_index)</span><br><span class=\"line\">  body</span><br><span class=\"line\">    width $width[p_index]</span><br><span class=\"line\">    margin-left $margin[p_index]</span><br><span class=\"line\">responsive(0)</span><br><span class=\"line\">for $i in 0 1 2 3 4 5</span><br><span class=\"line\">  $media = media(&#x27;screen&#x27;, &#x27;(max-width: &#x27; + $screen[$i] + &#x27;)&#x27;)</span><br><span class=\"line\">  @media $media</span><br><span class=\"line\">      responsive($i)</span><br><span class=\"line\"></span><br><span class=\"line\">// =&gt;</span><br><span class=\"line\">body &#123;</span><br><span class=\"line\">  width: 1600px;</span><br><span class=\"line\">  margin-left: 180px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@media screen and (max-width: 1920px) &#123;</span><br><span class=\"line\">  body &#123;</span><br><span class=\"line\">    width: 1600px;</span><br><span class=\"line\">    margin-left: 180px;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// ...</span><br><span class=\"line\">@media screen and (max-width: 320px) &#123;</span><br><span class=\"line\">  body &#123;</span><br><span class=\"line\">    width: 300px;</span><br><span class=\"line\">    margin-left: 0;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>当然响应式不是简单的改变尺寸，如果你需要控制某些内容的显示则可以使用一个Boolean的数组来判断是否显示，控制结构或样式则可以字符串的数组来放置一些预先写好的Mixin名称。</p>\n<h5 id=\"CSS-Sprite\"><a href=\"#CSS-Sprite\" class=\"headerlink\" title=\"CSS Sprite\"></a>CSS Sprite</h5><p>对于CSS Sprite相信是所有切图者的主要工作产出，以前我也推荐过一些在线的制作Sprite的工具，不过现在有了Stylus，也许我们可能更快的完成这一切。之前公司有需要国旗icon，所以做了这个小项目<a href=\"https://github.com/tychio/national_flag\">national_flag</a>用来创建和维护国旗icon的CSS Sprite。由于国家数目众多，每个国家对应一个国家代码，所以我定义了一个二维数组用来表现图片中国旗的位置，然后在数组中填入代码，用来拼接图标的class名称，然后按照数组中的序号和尺寸就可以生成对应的background-position了。主要代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iconBuild(id, col, row)</span><br><span class=\"line\">    .country-&#123;id&#125;</span><br><span class=\"line\">        background-position (0px - (row * $size)) (0px - (col * $size))</span><br><span class=\"line\">/*r /c-&gt; 00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16*/</span><br><span class=\"line\">$row00 = CN AF AZ BH BD BN KH TL IN ID IR IQ IL JP JO KZ KW</span><br><span class=\"line\">$row01 = KG LA LB MY MV MN MM NP KP OM PK PS PH QA SA SG KR</span><br><span class=\"line\">$row02 = LK SY TJ TH TM AE UZ VN YE DZ AO BJ BW BF BI CM CV</span><br><span class=\"line\">$row03 = CF RO KM CG CI CD DJ EG GQ ER ET GA GH GN GW KE LS</span><br><span class=\"line\">$row04 = LR __ MG MW ML MR MU MA MZ NA NE NG RW ST SN SC SL</span><br><span class=\"line\">$row05 = SO ZA SD __ TZ __ TG TN UG ZM ZW __ __ __ __ __ __</span><br><span class=\"line\">$row06 = JM PR DO KN VC LC TT CR __ SV GT HN NI PA __ DE __</span><br><span class=\"line\">$row07 = MK AT __ __ __ BG CY __ __ DK SK SI ES EE FI FR __</span><br><span class=\"line\">$row08 = GR HU IE IS IT LV LI LT LU MT MD MC ME NO NL PL PT</span><br><span class=\"line\">$row09 = UK CZ __ RU SM __ SE CH TR UA EU __ CA __ MX __ US</span><br><span class=\"line\">$row10 = AR BO BR CL CO EC GY __ __ PE __ UY VE HK LY NZ RS</span><br><span class=\"line\">$row11 = PY AU SR TJ FM AI __ __ __ __ __ __ __ __ __ __ __</span><br><span class=\"line\">$pos = $row00 $row01 $row02 $row03 $row04 $row05 $row06 $row07 $row08 $row09 $row10 $row11</span><br><span class=\"line\">for $rowList, $row in $pos</span><br><span class=\"line\">    for $country, $col in $rowList</span><br><span class=\"line\">        if $country != __</span><br><span class=\"line\">            iconBuild($country, $row, $col)</span><br></pre></td></tr></table></figure>\n<p>其中for不同于Javascript，rowList为数组遍历出的一个元素，而$row为索引，可以这样理解 <code>for [value], [index] in [array]</code> 。所以可以在两个嵌套的for中获取纵横的位置以及国家代码，来生成CSS。</p>\n<h3 id=\"Stylue应用\"><a href=\"#Stylue应用\" class=\"headerlink\" title=\"Stylue应用\"></a>Stylue应用</h3><p>作为预处理工具，Stylus自然也需要预处理器，不过它不像Sass需要Ruby环境，Stylus由Javascript实现，所以有Javascript就可以处理Stylus。</p>\n<h5 id=\"编译工具\"><a href=\"#编译工具\" class=\"headerlink\" title=\"编译工具\"></a>编译工具</h5><ul>\n<li><a href=\"https://github.com/edmundask/SublimeText2-Stylus2CSS\">SublimeText2-Stylus2CSS</a>是一款SublimeText2的Stylus插件。另外我使用<a href=\"https://github.com/billymoon/Stylus\">这个项目</a>的SublimeText2插件来高亮styl文件的代码。</li>\n<li>另外今年8月WebStorm7也才刚刚支持 - <a href=\"http://blog.jetbrains.com/webstorm/2013/08/webstorm-7-eap-130-1630-stylus-support/\">Stylus Support</a>。</li>\n<li><a href=\"http://codepen.io/\">CodePen</a>支持各种CSS预处理，自然包括Stylus，上面的按钮例子就是嵌入的CodePen。</li>\n<li><a href=\"http://learnboost.github.io/stylus/try.html\">Stylus官方在线</a>其实是一些示例，不过它是可编辑的，所以你也可以随便写些什么，即时可以看到结果。不过好像还在使用低版本的Stylus，比如一些内置函数就不可用。</li>\n</ul>\n<h5 id=\"Grunt插件\"><a href=\"#Grunt插件\" class=\"headerlink\" title=\"Grunt插件\"></a>Grunt插件</h5><p>不过说到处理文件，Grunt还是我的最爱，尤其Stylus是由Javascript实现，在Nodejs中自然是得天独厚。npmjs上有许多用来处理Stylus的插件，下面简单介绍一下Grunt的官方Stylus插件<a href=\"https://npmjs.org/package/grunt-contrib-stylus\">grunt-contrib-stylus</a>。先来看看最简单的配置方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stylus: &#123;</span><br><span class=\"line\">  compile: &#123;</span><br><span class=\"line\">    files: &#123;</span><br><span class=\"line\">      &#x27;path/to/result.css&#x27;: &#x27;path/to/source.styl&#x27;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如此就可以利用Grunt将source.styl文件中的Stylus代码编译为result.css的CSS代码。当然还可以使用数组来进行多个Stylus文件的打包编译。当然不仅于此，先来看看主要的几个配置项：</p>\n<p><code>paths</code> 将自动使用@import来引入一些Stylus文件，比如一些Mixin集合，放在一个Stylus文件中进行维护，写在paths中后，就可以在每个Stylus文件中调用它们。<code>define</code> 可以定义一些全局变量，然后在Stylus中使用，但我不喜欢使用这个配置，而是更喜欢把全局变量放在一个单独的Stylus文件中，然后将这个文件加入paths的数组中。一句话，把所有不会直接产出CSS的Stylus代码分成若干个Stylus文件，然后全部添加到paths中，这样在所有Stylus文件中都可以随时调用了，但要注意这些Stylus文件的调用关系和使用先后顺序。</p>\n<p><code>compress</code> 及 <code>linenos</code> 是两个Boolean值，用来控制是否压缩处理后的CSS代码以及是否在CSS代码中保留注释。</p>\n<p><code>banner</code> 是一个字符串，会被放置在CSS文件的最前面，一般我用来写注释，比如</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">banner: &#x27;\\/** \\n * &lt;%= pkg.name %&gt; - &lt;%= pkg.description %&gt;\\n * version &lt;%= pkg.version %&gt; \\n * author &lt;%= pkg.author %&gt; \\n * date &lt;%= grunt.template.today() %&gt; \\n**/\\n&#x27;</span><br></pre></td></tr></table></figure>\n\n<p><code>firebug</code> 将控制是否使用一个Firebug的Stylus插件<a href=\"https://addons.mozilla.org/en-US/firefox/addon/firestylus-for-firebug/\">FireStylus for Firebug</a>，可以在Firefox中调试Stylus。</p>\n<p><code>use</code> 可以引入一些Stylus的其他grunt插件。</p>\n<p>配合watch等Grunt插件就可以达到自动化的Stylus开发，写样式将会非常有效率。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>Stylus是一个由Javascript实现的CSS预处理工具，文件后缀为styl，其拥有变量、函数、混合、条件及循环语句等功能，还有丰富的内置函数用于处理颜色、数字、数组等数据。在grunt的辅助下，Stylus将带来极大的开发效率。</p>\n<p>我还在<a href=\"http://slid.es/\">slides</a>上制作了一个<a href=\"http://slid.es/tychio/stylus\">Stylus简介的幻灯片</a>，还没有经过实践，可能内容有些空泛，不过将持续改进。</p>\n","site":{"data":{}},"excerpt":"<p><img src=\"/images/stylus.jpg\" alt=\"Stylus Logo\"><br>Stylus似乎并不是很有名，以至于很多人不知道它是做什么的，但提到SASS相信有不少人听说过甚至使用过很长时间。其实无论是LESS、SASS还是Stylus甚至是Absurd这些预处理工具，都是对CSS的一种延伸和强化。出现这些工具的原因很简单，CSS本身只是一种描述性质的东西，甚至它不能算是语言而是样式表，所以我们需要一个有条件语句和变量甚至是函数的东西去动态生成CSS代码来达到提高效率和增强可维护性的目的。</p>\n<p>本文主要以Stylus语法本身和简单的使用为主要内容，它的目的是介绍和简单指南。将不会过多涉及Javascript的API调用等问题。</p>\n<h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>官方的介绍非常简短而精炼：</p>\n<blockquote>\n<p>Expressive, dynamic, robust CSS</p>\n</blockquote>","more":"<p>富有表现力的动态的强壮的CSS，它反应了一些主要特点。</p>\n<p>首先Stylus相较于SASS更加简洁，甚至冒号也都可以省略，初学Stylus时感到它太神奇了，仅仅以空格分隔属性名和多个属性值就可以生成想要的CSS，而且还可以拼接字符串等等。与此同时，类似Ruby或Python完善的缩进语法，Stylus在简约自由中有效的防止了语法歧义。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">body</span><br><span class=\"line\">  border 10px*.1 soli+&#x27;d&#x27; darken(red,10%)</span><br><span class=\"line\"></span><br><span class=\"line\">// =&gt;</span><br><span class=\"line\">body &#123;</span><br><span class=\"line\">    border: 1px solid #e60000;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其次是动态，这正是其精髓所在，Stylus由Javascript编译，其结构语句也和Javascript相差不多，前端人员可以很轻松的上手。虽然这方面Absurd是一个极端，但Stylus较之LESS则要优越不少，不仅仅是可定义变量，如Javascript般的条件语句和循环语句也为Stylus带来各种可能，加上丰富的内置函数，可以轻松判断和操作各种变量。而利用这样的动态性，就可以写出非常强壮的CSS以满足不同环境和条件下的需要。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pos(type, args)</span><br><span class=\"line\">  i = 0</span><br><span class=\"line\">  position unquote(type)</span><br><span class=\"line\">  &#123;args[i]&#125; args[i + 1] is a &#x27;unit&#x27; ? args[i += 1] : 0</span><br><span class=\"line\">  &#123;args[i += 1]&#125; args[i + 1] is a &#x27;unit&#x27; ? args[i += 1] : 0</span><br><span class=\"line\"></span><br><span class=\"line\">absolute()</span><br><span class=\"line\">  pos(&#x27;absolute&#x27;, arguments)</span><br><span class=\"line\">fixed()</span><br><span class=\"line\">  pos(&#x27;fixed&#x27;, arguments)</span><br><span class=\"line\"></span><br><span class=\"line\">#prompt</span><br><span class=\"line\">  absolute top 150px left 5px</span><br><span class=\"line\">  width 200px</span><br><span class=\"line\">  margin-left -(@width / 2)</span><br><span class=\"line\">#logo</span><br><span class=\"line\">  fixed top left</span><br><span class=\"line\"></span><br><span class=\"line\">// =&gt;</span><br><span class=\"line\">#prompt &#123;</span><br><span class=\"line\">  position: absolute;</span><br><span class=\"line\">  top: 150px;</span><br><span class=\"line\">  left: 5px;</span><br><span class=\"line\">  width: 200px;</span><br><span class=\"line\">  margin-left: -100px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">#logo &#123;</span><br><span class=\"line\">  position: fixed;</span><br><span class=\"line\">  top: 0;</span><br><span class=\"line\">  left: 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"简单指南\"><a href=\"#简单指南\" class=\"headerlink\" title=\"简单指南\"></a>简单指南</h3><p>可以看到上面的代码中使用了Mixin（混合）还有三目运算符等手段构建了一个针对position的方法，用来快速生成一个定位代码片段。有底向上来看这段代码，#prompt和#logo是2个ID选择器，在其中调用了一些Mixin，其实Mixin与Function的区别在于，Mixin的内容是一段CSS代码，而Function应该是一个值并自动返回，所以调用它们的时候，前者将会替换为一段CSS，而后者将返回一个Boolean或者像素或者颜色之类的东西，也许用于判断也许直接放入CSS。然后其中的absolute和fixed分别调用了pos这个Mixin。</p>\n<h5 id=\"前缀\"><a href=\"#前缀\" class=\"headerlink\" title=\"前缀\"></a>前缀</h5><p>而且在调用时，也不一定要使用括号的形式，可以使用CSS的形式，直接Mixin名加空格然后写参数。所以有时候可以直接写一个Mixin来修改CSS属性的功能，比如看看下面这个兼容所有标准浏览器阴影的写法，可以很方便的为标准调用加上各标准浏览器的前缀：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">box-shadow()</span><br><span class=\"line\">  -webkit-box-shadow arguments</span><br><span class=\"line\">  -moz-box-shadow arguments</span><br><span class=\"line\">  -ms-box-shadow arguments</span><br><span class=\"line\">  -o-box-shadow arguments</span><br><span class=\"line\">  box-shadow arguments</span><br><span class=\"line\">box-shadow 2px 1px 10px red</span><br><span class=\"line\"></span><br><span class=\"line\">// =&gt;</span><br><span class=\"line\">-webkit-box-shadow: 2px 1px 10px #f00;</span><br><span class=\"line\">-moz-box-shadow: 2px 1px 10px #f00;</span><br><span class=\"line\">-ms-box-shadow: 2px 1px 10px #f00;</span><br><span class=\"line\">-o-box-shadow: 2px 1px 10px #f00;</span><br><span class=\"line\">box-shadow: 2px 1px 10px #f00;</span><br></pre></td></tr></table></figure>\n<p>可以看到调用时的写法与一般的写法一样，但是因为Mixin的存在，box-shadow不再是一个属性，可以变成5行带有各浏览器前缀的CSS。不仅仅是box-shadow，CSS3的许多属性都需要添加前缀，那是不是可以更近一步呢，来写一个前缀Mixin吧：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// add prefix for attribute</span><br><span class=\"line\">prefix(p_attr, argu...)</span><br><span class=\"line\">  $pfs = webkit moz ms o</span><br><span class=\"line\">  for $pf in $pfs</span><br><span class=\"line\">    -&#123;$pf&#125;-&#123;p_attr&#125; argu</span><br><span class=\"line\">  &#123;p_attr&#125; argu</span><br><span class=\"line\">// box shadow mixin</span><br><span class=\"line\">box-shadow()</span><br><span class=\"line\">  prefix(box-shadow, arguments)</span><br><span class=\"line\">// run</span><br><span class=\"line\">box-shadow 2px 1px 10px red</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"颜色\"><a href=\"#颜色\" class=\"headerlink\" title=\"颜色\"></a>颜色</h5><p>如同其他CSS预处理工具一样，Stylus在颜色方面也拥有许多内置函数，无论是判断，提取还是修改都十分强大。函数 <code>red</code> , <code>blue</code> , <code>green</code> , <code>alpha</code> 将分别返回颜色对应的rgba值，<code>dark</code> 和 <code>light</code> 用于判断颜色属于亮色还是暗色，<code>hue</code> , <code>saturation</code> , <code>lightness</code> 则分别返回颜色的色相、饱和度以及亮度，其中色相是在色环上的角度，单位是deg。我经常用的是<code>lighten</code> 和 <code>darken</code> 这两个函数，其作用是增加或减少一个颜色的亮度，另外还有饱和度的操作函数 <code>desaturate</code> 和 <code>satucate</code>。</p>\n<p>似乎没有用于修改色相的函数，不过这个需求很容易通过其他办法搞定。首先使用hue等函数将原始色的色相、饱和度、亮度以及透明度取出，然后对色相的角度进行修改，比如加90deg，最后再使用hsla函数，把去除的对应值当作参数传入即可。下面用一组三态按钮来举个栗子：</p>\n<p data-height=\"300\" data-theme-id=\"1870\" data-slug-hash=\"CKrwL\" data-user=\"tychio\" data-default-tab=\"result\" class=\"codepen\">See the Pen <a href=\"http://codepen.io/tychio/pen/CKrwL\">Single Button</a> by Zhang zhengzheng (<a href=\"http://codepen.io/tychio\">@tychio</a>) on <a href=\"http://codepen.io\">CodePen</a></p>\n<script async src=\"//codepen.io/assets/embed/ei.js\"></script>\n\n<p>可以看到Stylus中的第一行代码 <code>$clr = #99ff22</code> 只要修改这个颜色值就可以改变按钮的整体风格，并无需考虑hover和active状态时对应的颜色。比如边框使用 <code>darken</code> 来加深，阴影泛光可以使用 <code>lighten</code> 来加亮，在触碰时整体使用了 <code>saturate</code> 来改变饱和度，按下的Active状态我使用了 <code>invert</code> 函数，可以翻转颜色，在视觉设计中这个颜色叫做对位色，即色相处于色环的对面的两种颜色，比如绿对红，黄对蓝，例子中使用了黄绿，所以对位色就是紫色。当然也可以使用上面提到的复杂一些的方法来修改色相，达到使用间隔色之类的效果。</p>\n<h5 id=\"响应式\"><a href=\"#响应式\" class=\"headerlink\" title=\"响应式\"></a>响应式</h5><p>对于响应式的支持，Stylus的media也可以省略花括号，但和Sass有一些区别。Stylus在@media的括号中会原样输出，也就是说，我们不能使用变量或混合还有计算等手段来直接写media query。比如一般情况下需要写一个min-width，如果这样写</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$mobiWidth = 768px</span><br><span class=\"line\">@media screen and (min-width $mobiWidth - 1px)</span><br><span class=\"line\">  body</span><br><span class=\"line\">    margin 0</span><br></pre></td></tr></table></figure>\n\n<p>产生的CSS代码则仍然是</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@media screen and (min-width $mobiWidth - 1px) &#123;</span><br><span class=\"line\">  body &#123;</span><br><span class=\"line\">    margin: 0;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这不是一个bug，尽管在Github上有无数的人提出issue或者在其后+1，作者仍然不为所动，原因不明，不过幸运地是有很多人都提出解决办法，下面是一个比较好的方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">media()</span><br><span class=\"line\">  join(&#x27; and &#x27;, arguments)</span><br><span class=\"line\">$mobiWidth = 768px</span><br><span class=\"line\">$media = media(&#x27;screen&#x27;, &#x27;(min-width: &#x27; + ($mobiWidth - 1px) + &#x27;)&#x27;)</span><br><span class=\"line\">@media $media</span><br><span class=\"line\">  body</span><br><span class=\"line\">    margin 0</span><br><span class=\"line\"></span><br><span class=\"line\">/// =&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@media screen and (min-width: 767px) &#123;</span><br><span class=\"line\">  body &#123;</span><br><span class=\"line\">    margin: 0;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样就可以使用变量来作为media的参数了，只是写起来会比sass麻烦一些，但我觉得这样也许更自由，你可以改进这个方法，比如传一个object来作为query条件，而不是拼接一个字符串。另外这个方法还用到了 <code>join</code> 内置函数，和Javascript中的Array方法join一样，很容易使用，除了它还有 <code>push</code> , <code>unshift</code> 函数。</p>\n<p>关于数组的定义，对于响应式来说有非常好的帮助，因为响应式往往是一系列的尺寸或设备，无论如何，使用数组可以轻松的定义多组对应与索引的配套值。比如我的blog，对于不同宽度的设备中有不同的内容宽度以及边距，来看看简化的代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$screen = 1920px 1280px 1024px 768px 640px 320px</span><br><span class=\"line\">$width = 1600px 1080px 840px 600px 480px 300px</span><br><span class=\"line\">$margin = 180px 100px 80px 40px 20px 0</span><br><span class=\"line\">media()</span><br><span class=\"line\">  join(&#x27; and &#x27;, arguments)</span><br><span class=\"line\">responsive(p_index)</span><br><span class=\"line\">  body</span><br><span class=\"line\">    width $width[p_index]</span><br><span class=\"line\">    margin-left $margin[p_index]</span><br><span class=\"line\">responsive(0)</span><br><span class=\"line\">for $i in 0 1 2 3 4 5</span><br><span class=\"line\">  $media = media(&#x27;screen&#x27;, &#x27;(max-width: &#x27; + $screen[$i] + &#x27;)&#x27;)</span><br><span class=\"line\">  @media $media</span><br><span class=\"line\">      responsive($i)</span><br><span class=\"line\"></span><br><span class=\"line\">// =&gt;</span><br><span class=\"line\">body &#123;</span><br><span class=\"line\">  width: 1600px;</span><br><span class=\"line\">  margin-left: 180px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@media screen and (max-width: 1920px) &#123;</span><br><span class=\"line\">  body &#123;</span><br><span class=\"line\">    width: 1600px;</span><br><span class=\"line\">    margin-left: 180px;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// ...</span><br><span class=\"line\">@media screen and (max-width: 320px) &#123;</span><br><span class=\"line\">  body &#123;</span><br><span class=\"line\">    width: 300px;</span><br><span class=\"line\">    margin-left: 0;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>当然响应式不是简单的改变尺寸，如果你需要控制某些内容的显示则可以使用一个Boolean的数组来判断是否显示，控制结构或样式则可以字符串的数组来放置一些预先写好的Mixin名称。</p>\n<h5 id=\"CSS-Sprite\"><a href=\"#CSS-Sprite\" class=\"headerlink\" title=\"CSS Sprite\"></a>CSS Sprite</h5><p>对于CSS Sprite相信是所有切图者的主要工作产出，以前我也推荐过一些在线的制作Sprite的工具，不过现在有了Stylus，也许我们可能更快的完成这一切。之前公司有需要国旗icon，所以做了这个小项目<a href=\"https://github.com/tychio/national_flag\">national_flag</a>用来创建和维护国旗icon的CSS Sprite。由于国家数目众多，每个国家对应一个国家代码，所以我定义了一个二维数组用来表现图片中国旗的位置，然后在数组中填入代码，用来拼接图标的class名称，然后按照数组中的序号和尺寸就可以生成对应的background-position了。主要代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iconBuild(id, col, row)</span><br><span class=\"line\">    .country-&#123;id&#125;</span><br><span class=\"line\">        background-position (0px - (row * $size)) (0px - (col * $size))</span><br><span class=\"line\">/*r /c-&gt; 00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16*/</span><br><span class=\"line\">$row00 = CN AF AZ BH BD BN KH TL IN ID IR IQ IL JP JO KZ KW</span><br><span class=\"line\">$row01 = KG LA LB MY MV MN MM NP KP OM PK PS PH QA SA SG KR</span><br><span class=\"line\">$row02 = LK SY TJ TH TM AE UZ VN YE DZ AO BJ BW BF BI CM CV</span><br><span class=\"line\">$row03 = CF RO KM CG CI CD DJ EG GQ ER ET GA GH GN GW KE LS</span><br><span class=\"line\">$row04 = LR __ MG MW ML MR MU MA MZ NA NE NG RW ST SN SC SL</span><br><span class=\"line\">$row05 = SO ZA SD __ TZ __ TG TN UG ZM ZW __ __ __ __ __ __</span><br><span class=\"line\">$row06 = JM PR DO KN VC LC TT CR __ SV GT HN NI PA __ DE __</span><br><span class=\"line\">$row07 = MK AT __ __ __ BG CY __ __ DK SK SI ES EE FI FR __</span><br><span class=\"line\">$row08 = GR HU IE IS IT LV LI LT LU MT MD MC ME NO NL PL PT</span><br><span class=\"line\">$row09 = UK CZ __ RU SM __ SE CH TR UA EU __ CA __ MX __ US</span><br><span class=\"line\">$row10 = AR BO BR CL CO EC GY __ __ PE __ UY VE HK LY NZ RS</span><br><span class=\"line\">$row11 = PY AU SR TJ FM AI __ __ __ __ __ __ __ __ __ __ __</span><br><span class=\"line\">$pos = $row00 $row01 $row02 $row03 $row04 $row05 $row06 $row07 $row08 $row09 $row10 $row11</span><br><span class=\"line\">for $rowList, $row in $pos</span><br><span class=\"line\">    for $country, $col in $rowList</span><br><span class=\"line\">        if $country != __</span><br><span class=\"line\">            iconBuild($country, $row, $col)</span><br></pre></td></tr></table></figure>\n<p>其中for不同于Javascript，rowList为数组遍历出的一个元素，而$row为索引，可以这样理解 <code>for [value], [index] in [array]</code> 。所以可以在两个嵌套的for中获取纵横的位置以及国家代码，来生成CSS。</p>\n<h3 id=\"Stylue应用\"><a href=\"#Stylue应用\" class=\"headerlink\" title=\"Stylue应用\"></a>Stylue应用</h3><p>作为预处理工具，Stylus自然也需要预处理器，不过它不像Sass需要Ruby环境，Stylus由Javascript实现，所以有Javascript就可以处理Stylus。</p>\n<h5 id=\"编译工具\"><a href=\"#编译工具\" class=\"headerlink\" title=\"编译工具\"></a>编译工具</h5><ul>\n<li><a href=\"https://github.com/edmundask/SublimeText2-Stylus2CSS\">SublimeText2-Stylus2CSS</a>是一款SublimeText2的Stylus插件。另外我使用<a href=\"https://github.com/billymoon/Stylus\">这个项目</a>的SublimeText2插件来高亮styl文件的代码。</li>\n<li>另外今年8月WebStorm7也才刚刚支持 - <a href=\"http://blog.jetbrains.com/webstorm/2013/08/webstorm-7-eap-130-1630-stylus-support/\">Stylus Support</a>。</li>\n<li><a href=\"http://codepen.io/\">CodePen</a>支持各种CSS预处理，自然包括Stylus，上面的按钮例子就是嵌入的CodePen。</li>\n<li><a href=\"http://learnboost.github.io/stylus/try.html\">Stylus官方在线</a>其实是一些示例，不过它是可编辑的，所以你也可以随便写些什么，即时可以看到结果。不过好像还在使用低版本的Stylus，比如一些内置函数就不可用。</li>\n</ul>\n<h5 id=\"Grunt插件\"><a href=\"#Grunt插件\" class=\"headerlink\" title=\"Grunt插件\"></a>Grunt插件</h5><p>不过说到处理文件，Grunt还是我的最爱，尤其Stylus是由Javascript实现，在Nodejs中自然是得天独厚。npmjs上有许多用来处理Stylus的插件，下面简单介绍一下Grunt的官方Stylus插件<a href=\"https://npmjs.org/package/grunt-contrib-stylus\">grunt-contrib-stylus</a>。先来看看最简单的配置方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stylus: &#123;</span><br><span class=\"line\">  compile: &#123;</span><br><span class=\"line\">    files: &#123;</span><br><span class=\"line\">      &#x27;path/to/result.css&#x27;: &#x27;path/to/source.styl&#x27;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如此就可以利用Grunt将source.styl文件中的Stylus代码编译为result.css的CSS代码。当然还可以使用数组来进行多个Stylus文件的打包编译。当然不仅于此，先来看看主要的几个配置项：</p>\n<p><code>paths</code> 将自动使用@import来引入一些Stylus文件，比如一些Mixin集合，放在一个Stylus文件中进行维护，写在paths中后，就可以在每个Stylus文件中调用它们。<code>define</code> 可以定义一些全局变量，然后在Stylus中使用，但我不喜欢使用这个配置，而是更喜欢把全局变量放在一个单独的Stylus文件中，然后将这个文件加入paths的数组中。一句话，把所有不会直接产出CSS的Stylus代码分成若干个Stylus文件，然后全部添加到paths中，这样在所有Stylus文件中都可以随时调用了，但要注意这些Stylus文件的调用关系和使用先后顺序。</p>\n<p><code>compress</code> 及 <code>linenos</code> 是两个Boolean值，用来控制是否压缩处理后的CSS代码以及是否在CSS代码中保留注释。</p>\n<p><code>banner</code> 是一个字符串，会被放置在CSS文件的最前面，一般我用来写注释，比如</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">banner: &#x27;\\/** \\n * &lt;%= pkg.name %&gt; - &lt;%= pkg.description %&gt;\\n * version &lt;%= pkg.version %&gt; \\n * author &lt;%= pkg.author %&gt; \\n * date &lt;%= grunt.template.today() %&gt; \\n**/\\n&#x27;</span><br></pre></td></tr></table></figure>\n\n<p><code>firebug</code> 将控制是否使用一个Firebug的Stylus插件<a href=\"https://addons.mozilla.org/en-US/firefox/addon/firestylus-for-firebug/\">FireStylus for Firebug</a>，可以在Firefox中调试Stylus。</p>\n<p><code>use</code> 可以引入一些Stylus的其他grunt插件。</p>\n<p>配合watch等Grunt插件就可以达到自动化的Stylus开发，写样式将会非常有效率。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>Stylus是一个由Javascript实现的CSS预处理工具，文件后缀为styl，其拥有变量、函数、混合、条件及循环语句等功能，还有丰富的内置函数用于处理颜色、数字、数组等数据。在grunt的辅助下，Stylus将带来极大的开发效率。</p>\n<p>我还在<a href=\"http://slid.es/\">slides</a>上制作了一个<a href=\"http://slid.es/tychio/stylus\">Stylus简介的幻灯片</a>，还没有经过实践，可能内容有些空泛，不过将持续改进。</p>"},{"layout":"post","title":"《代码整洁之道》Clean Code","_content":"\n![Clean Code](/images/cleancode.jpg)这本书读了许久才读了一遍，不同于之前读到的一些方法性的书籍，该书有更多的细节，但其中又存在许多理论性的东西，要消化它们可不是很容易。读完一遍后又快速回顾了一遍，马上又会发现很多新的东西并有一些新的理解，甚至让我觉得写这篇文章有点太急了，不过我还是应该尝试收集一些有营养的东西，至少记录现在的想法，相信对之后的第二遍阅读会更有益处。\n\n书名其实有点误导我，或者说它不仅仅是其字面意思那样简单，‘整洁’不是简单的清洁，其主旨在于一种设计上的精巧。书的开篇就引用了几位大牛对代码整洁的解释来描述其意义。从抽象的描述中说，整洁代表着优雅、愉悦、精巧、简单，具体来说我觉得有以下几点：\n\n* 易于维护，依赖简单。\n* 设计精巧，没有改进的余地。\n* 高可读性，意图一目了然。\n* 完善的测试与错误处理。\n* 没有重复，最精简的实体。\n\n最后作者总结为深合已意，其实说起来简单，可做起来却不是这么容易的。代码可不是一块光秃秃的地板，只要使劲擦总能变整洁的。\n<!-- more -->\n\n《代码整洁之道》占了很大篇幅的前半部分其实是在讲编码规范，但又不完全是，似乎是一种指导原则。\n\n先说说命名，在Refactoring中也有`rename method`这个方法，最开始看到它的时候其实还觉得挺好笑，觉得这也能算一个重构方法吗，但慢慢项目经验增加后，感到这是最基础也是最有效的一种重构手段。在我毕业后的第一个项目中我就遭遇了麻烦，大量的逻辑使我本来认为不错的编程习惯彻底崩溃，重复的变量名充斥在各个作用域中，有时甚至互相交替使用导致了各种bug。所以那时我就为公司制定了一系列的命名规范，比如统一使用驼峰命名、常量使用大写、用动词+名词的方式命名函数等等。大部分的规范已经变成了我的习惯而沿用到现在，但我仍能感到在为函数或方法命名时的纠结。\n\n命名需要有意义，好像一句话，但同时又应该避免含糊的词，比如the、a、data之类的词。另外，作者建议不要使用匈牙利命名添加一些编码的前缀，但我觉得在JavaScript这样的弱类型语言中有时还是有点必要的，我还喜欢为jQuery对象添加`$`前缀来标识它。还有一点很重要，统一用词，有时我会怀疑自己的词汇量是否比外国小学生还烂，不过我发现这也是一个优点。因为对应一个意思，我第一个想到的总会是那个词，而看到那个词我也总会明白其意思，绝不会在get与fetch之间犹豫。\n\n可能许多人会遇到一个问题，函数的功能太多了，导致名称很长仍无法完全描述其功能，此时解决问题的不是命名，而是重构，函数不该是如此多功能的东西，它需要被拆分。看到第三章，我突然想到，这是不是某种驱动关系。为函数命名驱使我们要不断的理清函数的功能和意义，并保持其单一功能性。\n\n另外在第八章中讲到的边界也很有意思，说到第三方库，JavaScript中可以说是没有人不用第三方库的，尤其是我现在的公司，依赖于requirejs这样的模块工具使用了许多第三方库。起初每个功能都很快的被开发出来，感觉不错，但慢慢的随着开发的深入，各种插件与库的冲突不断，想替换又发现有很多地方都在调用其方法，代码变成了脏乱差。如果开始可以封装第三方库的方法，此时只需要重写该方法就可以轻松替换。\n\n在十三章中提到了并发编程，这有点像JavaScript中的异步特性。比如使用`jQuery.animation`完成一些复杂动画时，需要一个动画队列，此时动画的标签就是限定资源，这是一个生产者和消费者模型。当然真正的并行要比这复杂多了，但仍然可以从中借鉴到一些思想。\n","source":"_posts/2013-11-26-clean-code.md","raw":"---\nlayout: post\ntitle: 《代码整洁之道》Clean Code\ntags: [software,SE,软件工程,代码整洁]\ncategory: Read\n---\n\n![Clean Code](/images/cleancode.jpg)这本书读了许久才读了一遍，不同于之前读到的一些方法性的书籍，该书有更多的细节，但其中又存在许多理论性的东西，要消化它们可不是很容易。读完一遍后又快速回顾了一遍，马上又会发现很多新的东西并有一些新的理解，甚至让我觉得写这篇文章有点太急了，不过我还是应该尝试收集一些有营养的东西，至少记录现在的想法，相信对之后的第二遍阅读会更有益处。\n\n书名其实有点误导我，或者说它不仅仅是其字面意思那样简单，‘整洁’不是简单的清洁，其主旨在于一种设计上的精巧。书的开篇就引用了几位大牛对代码整洁的解释来描述其意义。从抽象的描述中说，整洁代表着优雅、愉悦、精巧、简单，具体来说我觉得有以下几点：\n\n* 易于维护，依赖简单。\n* 设计精巧，没有改进的余地。\n* 高可读性，意图一目了然。\n* 完善的测试与错误处理。\n* 没有重复，最精简的实体。\n\n最后作者总结为深合已意，其实说起来简单，可做起来却不是这么容易的。代码可不是一块光秃秃的地板，只要使劲擦总能变整洁的。\n<!-- more -->\n\n《代码整洁之道》占了很大篇幅的前半部分其实是在讲编码规范，但又不完全是，似乎是一种指导原则。\n\n先说说命名，在Refactoring中也有`rename method`这个方法，最开始看到它的时候其实还觉得挺好笑，觉得这也能算一个重构方法吗，但慢慢项目经验增加后，感到这是最基础也是最有效的一种重构手段。在我毕业后的第一个项目中我就遭遇了麻烦，大量的逻辑使我本来认为不错的编程习惯彻底崩溃，重复的变量名充斥在各个作用域中，有时甚至互相交替使用导致了各种bug。所以那时我就为公司制定了一系列的命名规范，比如统一使用驼峰命名、常量使用大写、用动词+名词的方式命名函数等等。大部分的规范已经变成了我的习惯而沿用到现在，但我仍能感到在为函数或方法命名时的纠结。\n\n命名需要有意义，好像一句话，但同时又应该避免含糊的词，比如the、a、data之类的词。另外，作者建议不要使用匈牙利命名添加一些编码的前缀，但我觉得在JavaScript这样的弱类型语言中有时还是有点必要的，我还喜欢为jQuery对象添加`$`前缀来标识它。还有一点很重要，统一用词，有时我会怀疑自己的词汇量是否比外国小学生还烂，不过我发现这也是一个优点。因为对应一个意思，我第一个想到的总会是那个词，而看到那个词我也总会明白其意思，绝不会在get与fetch之间犹豫。\n\n可能许多人会遇到一个问题，函数的功能太多了，导致名称很长仍无法完全描述其功能，此时解决问题的不是命名，而是重构，函数不该是如此多功能的东西，它需要被拆分。看到第三章，我突然想到，这是不是某种驱动关系。为函数命名驱使我们要不断的理清函数的功能和意义，并保持其单一功能性。\n\n另外在第八章中讲到的边界也很有意思，说到第三方库，JavaScript中可以说是没有人不用第三方库的，尤其是我现在的公司，依赖于requirejs这样的模块工具使用了许多第三方库。起初每个功能都很快的被开发出来，感觉不错，但慢慢的随着开发的深入，各种插件与库的冲突不断，想替换又发现有很多地方都在调用其方法，代码变成了脏乱差。如果开始可以封装第三方库的方法，此时只需要重写该方法就可以轻松替换。\n\n在十三章中提到了并发编程，这有点像JavaScript中的异步特性。比如使用`jQuery.animation`完成一些复杂动画时，需要一个动画队列，此时动画的标签就是限定资源，这是一个生产者和消费者模型。当然真正的并行要比这复杂多了，但仍然可以从中借鉴到一些思想。\n","slug":"clean-code","published":1,"date":"2013-11-25T16:00:00.000Z","updated":"2021-11-28T11:59:29.970Z","_id":"ckwj65517000tvyjhfc9aa20u","comments":1,"photos":[],"link":"","content":"<p><img src=\"/images/cleancode.jpg\" alt=\"Clean Code\">这本书读了许久才读了一遍，不同于之前读到的一些方法性的书籍，该书有更多的细节，但其中又存在许多理论性的东西，要消化它们可不是很容易。读完一遍后又快速回顾了一遍，马上又会发现很多新的东西并有一些新的理解，甚至让我觉得写这篇文章有点太急了，不过我还是应该尝试收集一些有营养的东西，至少记录现在的想法，相信对之后的第二遍阅读会更有益处。</p>\n<p>书名其实有点误导我，或者说它不仅仅是其字面意思那样简单，‘整洁’不是简单的清洁，其主旨在于一种设计上的精巧。书的开篇就引用了几位大牛对代码整洁的解释来描述其意义。从抽象的描述中说，整洁代表着优雅、愉悦、精巧、简单，具体来说我觉得有以下几点：</p>\n<ul>\n<li>易于维护，依赖简单。</li>\n<li>设计精巧，没有改进的余地。</li>\n<li>高可读性，意图一目了然。</li>\n<li>完善的测试与错误处理。</li>\n<li>没有重复，最精简的实体。</li>\n</ul>\n<p>最后作者总结为深合已意，其实说起来简单，可做起来却不是这么容易的。代码可不是一块光秃秃的地板，只要使劲擦总能变整洁的。</p>\n<span id=\"more\"></span>\n\n<p>《代码整洁之道》占了很大篇幅的前半部分其实是在讲编码规范，但又不完全是，似乎是一种指导原则。</p>\n<p>先说说命名，在Refactoring中也有<code>rename method</code>这个方法，最开始看到它的时候其实还觉得挺好笑，觉得这也能算一个重构方法吗，但慢慢项目经验增加后，感到这是最基础也是最有效的一种重构手段。在我毕业后的第一个项目中我就遭遇了麻烦，大量的逻辑使我本来认为不错的编程习惯彻底崩溃，重复的变量名充斥在各个作用域中，有时甚至互相交替使用导致了各种bug。所以那时我就为公司制定了一系列的命名规范，比如统一使用驼峰命名、常量使用大写、用动词+名词的方式命名函数等等。大部分的规范已经变成了我的习惯而沿用到现在，但我仍能感到在为函数或方法命名时的纠结。</p>\n<p>命名需要有意义，好像一句话，但同时又应该避免含糊的词，比如the、a、data之类的词。另外，作者建议不要使用匈牙利命名添加一些编码的前缀，但我觉得在JavaScript这样的弱类型语言中有时还是有点必要的，我还喜欢为jQuery对象添加<code>$</code>前缀来标识它。还有一点很重要，统一用词，有时我会怀疑自己的词汇量是否比外国小学生还烂，不过我发现这也是一个优点。因为对应一个意思，我第一个想到的总会是那个词，而看到那个词我也总会明白其意思，绝不会在get与fetch之间犹豫。</p>\n<p>可能许多人会遇到一个问题，函数的功能太多了，导致名称很长仍无法完全描述其功能，此时解决问题的不是命名，而是重构，函数不该是如此多功能的东西，它需要被拆分。看到第三章，我突然想到，这是不是某种驱动关系。为函数命名驱使我们要不断的理清函数的功能和意义，并保持其单一功能性。</p>\n<p>另外在第八章中讲到的边界也很有意思，说到第三方库，JavaScript中可以说是没有人不用第三方库的，尤其是我现在的公司，依赖于requirejs这样的模块工具使用了许多第三方库。起初每个功能都很快的被开发出来，感觉不错，但慢慢的随着开发的深入，各种插件与库的冲突不断，想替换又发现有很多地方都在调用其方法，代码变成了脏乱差。如果开始可以封装第三方库的方法，此时只需要重写该方法就可以轻松替换。</p>\n<p>在十三章中提到了并发编程，这有点像JavaScript中的异步特性。比如使用<code>jQuery.animation</code>完成一些复杂动画时，需要一个动画队列，此时动画的标签就是限定资源，这是一个生产者和消费者模型。当然真正的并行要比这复杂多了，但仍然可以从中借鉴到一些思想。</p>\n","site":{"data":{}},"excerpt":"<p><img src=\"/images/cleancode.jpg\" alt=\"Clean Code\">这本书读了许久才读了一遍，不同于之前读到的一些方法性的书籍，该书有更多的细节，但其中又存在许多理论性的东西，要消化它们可不是很容易。读完一遍后又快速回顾了一遍，马上又会发现很多新的东西并有一些新的理解，甚至让我觉得写这篇文章有点太急了，不过我还是应该尝试收集一些有营养的东西，至少记录现在的想法，相信对之后的第二遍阅读会更有益处。</p>\n<p>书名其实有点误导我，或者说它不仅仅是其字面意思那样简单，‘整洁’不是简单的清洁，其主旨在于一种设计上的精巧。书的开篇就引用了几位大牛对代码整洁的解释来描述其意义。从抽象的描述中说，整洁代表着优雅、愉悦、精巧、简单，具体来说我觉得有以下几点：</p>\n<ul>\n<li>易于维护，依赖简单。</li>\n<li>设计精巧，没有改进的余地。</li>\n<li>高可读性，意图一目了然。</li>\n<li>完善的测试与错误处理。</li>\n<li>没有重复，最精简的实体。</li>\n</ul>\n<p>最后作者总结为深合已意，其实说起来简单，可做起来却不是这么容易的。代码可不是一块光秃秃的地板，只要使劲擦总能变整洁的。</p>","more":"<p>《代码整洁之道》占了很大篇幅的前半部分其实是在讲编码规范，但又不完全是，似乎是一种指导原则。</p>\n<p>先说说命名，在Refactoring中也有<code>rename method</code>这个方法，最开始看到它的时候其实还觉得挺好笑，觉得这也能算一个重构方法吗，但慢慢项目经验增加后，感到这是最基础也是最有效的一种重构手段。在我毕业后的第一个项目中我就遭遇了麻烦，大量的逻辑使我本来认为不错的编程习惯彻底崩溃，重复的变量名充斥在各个作用域中，有时甚至互相交替使用导致了各种bug。所以那时我就为公司制定了一系列的命名规范，比如统一使用驼峰命名、常量使用大写、用动词+名词的方式命名函数等等。大部分的规范已经变成了我的习惯而沿用到现在，但我仍能感到在为函数或方法命名时的纠结。</p>\n<p>命名需要有意义，好像一句话，但同时又应该避免含糊的词，比如the、a、data之类的词。另外，作者建议不要使用匈牙利命名添加一些编码的前缀，但我觉得在JavaScript这样的弱类型语言中有时还是有点必要的，我还喜欢为jQuery对象添加<code>$</code>前缀来标识它。还有一点很重要，统一用词，有时我会怀疑自己的词汇量是否比外国小学生还烂，不过我发现这也是一个优点。因为对应一个意思，我第一个想到的总会是那个词，而看到那个词我也总会明白其意思，绝不会在get与fetch之间犹豫。</p>\n<p>可能许多人会遇到一个问题，函数的功能太多了，导致名称很长仍无法完全描述其功能，此时解决问题的不是命名，而是重构，函数不该是如此多功能的东西，它需要被拆分。看到第三章，我突然想到，这是不是某种驱动关系。为函数命名驱使我们要不断的理清函数的功能和意义，并保持其单一功能性。</p>\n<p>另外在第八章中讲到的边界也很有意思，说到第三方库，JavaScript中可以说是没有人不用第三方库的，尤其是我现在的公司，依赖于requirejs这样的模块工具使用了许多第三方库。起初每个功能都很快的被开发出来，感觉不错，但慢慢的随着开发的深入，各种插件与库的冲突不断，想替换又发现有很多地方都在调用其方法，代码变成了脏乱差。如果开始可以封装第三方库的方法，此时只需要重写该方法就可以轻松替换。</p>\n<p>在十三章中提到了并发编程，这有点像JavaScript中的异步特性。比如使用<code>jQuery.animation</code>完成一些复杂动画时，需要一个动画队列，此时动画的标签就是限定资源，这是一个生产者和消费者模型。当然真正的并行要比这复杂多了，但仍然可以从中借鉴到一些思想。</p>"},{"layout":"post","title":"如何写好CSS？（OOCSS\\DRY\\SMACSS）","_content":"\n很久没有写博客了，一是刚入职比较忙，二是因为总有学到新的有趣的东西，停不下脚步来总结一下。最近出差到了帝都，反而能挤出些时间来写点什么了，也正好趁着出差做的这个项目讨论一下CSS理论。\n\n我现在面对的CSS基本上就是一个三头六臂的怪物，一点不夸张，因为真的是三头六臂，同一个样式在同一个element上作用了好几遍，而同一个样式又分散在4，5个class上，优先级有很多层。可以看得出这个怪物不是一个人造就的，早期的开发者选择了SCSS技术，但混乱的import导致了一些基本的样式被多次调用，而后面的开发者又为了摆脱之前的混乱引入了其他共用样式，但无济于事。原因出在HTML上，CSS依托于HTML没有被正确的抽象，而HTML又完全的依赖业务，所有class以业务取名，HTML和CSS基本没有复用，最终抽出的共用样式也仅仅是又一次的重复。CSS重构最难的地方在于没有脚手架，即测试。虽然有一些方法来测试，比如reftest，但还不够成熟。抱着有总比没好的心态，CSS被一层又一层的覆盖了上去。\n<!-- more -->\n\n## 真正的问题是什么？\n\nCSS即层叠样式表，所以一层一层覆盖其实是其本质特征。真正的问题在于维护，许多人认为CSS仅是样式，不是代码，无需维护，所以任意书写，只要将自己需要的样式的优先级设为最高即可，才导致了深层级CSS的出现，因为每次添加一个样式就必须比以前的优先级高才能在页面看到。深层级不仅造成维护性降低，可读性也是一个问题，人不是机器，无法很优雅的按优先级阅读，所以很难确认一个样式用于哪里，其实还存在许多的冗余样式，在任何地方都被覆盖的样式。这样的代码在扩展性上，一开始反而是有优势的，因为添加一个新class，无需担心影响其他地方，但慢慢随着项目规模的增大，页面增多，需要复制样式的地方也越来越多，它们之间又存在微小的差异，设计的更改，需求的变化，这一切都会将这种快餐式的CSS推进柏油坑。因为难以维护，所以无法响应需求，所以无法复用，只能复制，恶性循环。\n\n正如上面所说的，问题在于可读性、维护性、扩展性、复用性这几个方面。所以只要提高它们就能解决问题, 虽然这么说，也不是如此简单的。先来谈谈在CSS中，这些概念都有着怎样的意义。\n\n#### 可读性\n\n有人认为CSS不是程序，不需要可读性，有人认为CSS只要写出来就有可读性，因为很简单。抛开各种预处理器不说，原生CSS结构确实简单，没有需要编程的部分，但仍然可能导致混乱。原因有二，一是CSS可以层叠，其中涉及到了优先级和作用范围，如果写的不好，人很难读出其中的意义，二是CSS属性众多，加上CSS3引入了很多用法独特的属性，一个选择器可能包含几十个属性。比如下面这段我随便写的CSS代码：\n\n```\nspan {\n\t-webkit-box-shadow: 6px 4px 4px red;\n\t-moz-box-shadow: 6px 4px 4px red;\n\tbox-shadow: 6px 4px 4px red;\n}\ndiv span {\n\tborder-width: 4px;\n\tborder-style: dotted;\n\tborder-color: blue;\n}\n#box {\n\tborder-left: 2px solid red;\n\tborder-bottom: 2px solid red; \n}\n\n```\n\n乍一看也没什么，都是border，大致能看出来这段CSS只是为了添加一个红色的阴影让box看起来比较立体。但中间的部分似乎是捣乱的，你可能会说这太傻了，看不到吗。是的，当这3部分散落在上万行的CSS中时，肯定看不到。于是有人很自然的想起了我们可爱的浏览器，没错，在浏览器中可以快速找到作用于目标的CSS样式，但这也是万恶之源。首先我假设你不知道中间那部分东西是为了什么而写的，因为你是靠浏览器找到它的。然后剩下两种可能，不管三七二十一改了再说和看看它为什么存在。前者悲剧的可能性是100%，后者悲剧的可能性是90%，因为你已经掉坑里了，很快我们会发现要修改它还牵扯到了另外的地方，接着在浏览器中探索到另一个莫名其妙的样式，当你弄懂全部的时候，你应该已经把上万行的代码弄了个一清二楚了，也许最幸运的是，浪费了几个小时的时间发现只需要修改一行就能达到目的。\n\n当然，我们可以天真的认为，只要把他们写在一起就可以了，这样找起来很简单。而我将继续顺着这样的思路来尝试曝露问题。\n\n#### 维护性\n\n所谓物以类聚是很有道理的，人们习惯将事物归类，但问题是分类标准，样式并不关心业务，无论是什么文字内容，还是功能有何不同，它在乎的只是样式，比如文字的尺寸，间距和宽高，颜色等等。如果简单的将一个组件的样式放在一起，势必带来的就是小段代码的重复书写。不觉得有多严重？我来举个栗子。\n\n```\naside {\n\tbox-shadow: 6px 4px 4px #AA3343;\n}\nnav {\n\tbox-shadow: 6px 4px 4px #AB3633;\t\n}\n.item {\n\tbox-shadow: 6px 4px 4px #AA3732;\n}\n.item.otherStatus {\n\tbox-shadow: 6px 4px 4px #AA3132;\n}\n```\n\n继续说上面的例子，box需要阴影，但如果这个项目的UI统一风格，包括sidebar，navigator以及item都需要这样的阴影呢？再如果，明天客户或者UX一拍脑袋，这个阴影应该是灰色的不该是红色的呢？不要继续天真的认为全局替换是救命稻草。首先，没有几个网站会用red，blur做色调的，你用的应该是#AA3333，这样的代码，然后你发现sidebar用了#A43433，而navigator是#AB3633，等等，item有两个状态，而两个状态对应的颜色是不一样的。这怎么可能？但当你打开浏览器的时候你会发现本来就相差无几的颜色，在阴影中变得一模一样了，谁看的出来呢，当初使用的时候可能也不过是随意的在mockup中取的一个颜色。\n\n大量的重复带来的不仅仅是代码的冗余，我们必须靠人力去同步它们，而人很难保证它们的修改是完全一致的，尤其是当它们中引入了一些不一致的独特的东西时。不要小看CSS，其后果就是进度和人力的压力，后面就是PM有没有读过《人月神话》的事了。\n\n肯定有人在想，谁让你当初要写成这样呢。我们在读代码的时候最喜欢问，当初为什么要这么写？但慢慢的你会读出它的历史，有时候它是身不由己的。这就涉及到了下一个要讨论的内容。\n\n#### 扩展性\n\n扩展性是一个具有欺骗性的东西，所谓的扩展性其实就是在现有基础上再次开发新东西的性能，但我认为它还必须有前提条件，那就是保持可读性与维护性。\n\n简单的追求可维护性是自取灭亡，原因很简单，将新旧代码完全分离的时候扩展性最高，因为不必担心对以前的部分有影响，新的样式可以随意发挥。是不是很神奇，这样想的我们写下的代码，肯定就是前面我们追问的代码。所以自己回答自己吧，当初没考虑可读性和维护性，只想着快点增加新的样式，就这么写了。\n\n那什么才是一个好的扩展性呢，简单来说，就是多功能产品。比如一个box，也许它的样式就时\n\n#### 复用性\n\n似乎我一直在说的就是重复，那我们就来说说复用性，如何才能复用CSS代码是一个很大的问题，比如粒度，是一两个属性进行复用还是一大组选择器进行复用呢，再比如对象，是为了class复用属性，还是为了html复用class呢。这些选择不算太重要，但是带来的影响却很重大，可以说是整个CSS结构的改变。下面继续用box的阴影来讨论复用。\n\n```\n.shadow {\n\t-webkit-box-shadow: 6px 4px 4px #A93334;\n\t-moz-box-shadow: 6px 4px 4px #A93334;\n\tbox-shadow: 6px 4px 4px #A93334;\n\tborder-left: 2px solid #A93334\\9;\n\tborder-bottom: 2px solid #A93334\\9; \n}\n```\n\n这样看起来我有了一个shadow的class可以给任意的目标加上这个阴影了，但这导致了一个复用的问题，和上面那段捣乱的CSS样式一样，如果item已有另外2个border了，那这个class是无法去除的。所以复用时不仅要考虑需要什么，还要考虑不需要什么。另外一些必须的属性比如display还有overflow等也是要考虑的，因为user agent的原因，很多属性是隐藏在element中的。\n\n## 如何解决问题？\n\n主流的CSS原则有OOCSS，DRY，SMACSS以及BEM，他们皆是为解决CSS的各种问题而生。\n\n#### OOCSS\n\nOOCSS即面向对象的CSS，这里对象指的是页面中的元素对象，与传统编程中的面向对象不太相同，比如不存在方法这种东西，硬要说的话，附加的一些class可以看作是继承或者接口之类的东西来实现对象的差异化。比如电商网站中的商品就是一个典型的对象，它们既有许多相同的部分，又有许多差异，宽高、按钮、图片、标题等基本布局都是相同的，而边距、线框、背景颜色、字号等都是差异化的。由此按照OOCSS的指导原则，我们应该写一个product class，然后为其添加一些border、theme之类的class来差异化它：\n\n```\n.product {\n\tdisplay: block;\n\toverflow: hidden;\n\tfloat: left;\n\twidth: 200px;\n\theight: auto;\n}\n.product-head{...}\n.product-body{...}\n.product-foot{...}\n\n.product-theme-black {\n\tbackground: black;\n\tcolor: white;\n}\n\n.product-border {\n\tborder: 1px solid #333;\n}\n```\n\n这样在以上两种附加class的作用下，我们在html中就可以获得4种不同的product样式，随着附加class增加，product的样式也会呈指数增加，千变万化。这仅仅是一个简单的例子，意在点出OOCSS的理念，但并没有突出它的意义所在。别着急，先来看看OOCSS的两大原则。\n\n\n***1. 分离容器与内容***\n\n所谓的容器即包裹对象的元素，比如一个div，我们经常会命名为wrap、container、body等。那么如何才算是分离容器与内容呢？很简单，一句话，内容在哪都可用。也就是说不应该出现这样的情况：\n\n```\n.container .product {\n\t...\n}\n```\n\n这样干的结果就是复用性大大降低，因为只能在这个容器内使用它了。但这并不代表我们应该将所需的样式全部一股脑的扔进单独的class中，对于差异化应该单独放在一个class中，这才是OOCSS的精髓。\n\n举个例子，当我们既不想牺牲太多性能，又想来个瀑布流显摆显摆的时候，大部分前端都会使用column，类似泳道的设计。你想说哦不，这是伪pinterest，但是谁在乎呢，用户是不会有闲工夫拖拽浏览器的宽度来鉴别它的，在IE下商品多的时候至少不会太卡。哈，别较真，首先分为几个column，然后按照高度往里填放商品，先来看看下面的代码吧，我有省略一些样式避免误导：\n\n```\n.column {\n\theight: auto;\n\twidth: 200px;\n}\n\n.product {\n\twidth: 180px;\n\tmargin-right: 20px;\n\tmargin-bottom: 10px;\n}\n```\n\n看起来不错，每列200px宽，商品放入其中，水平间距要大，垂直间距要小些才像column。但是等等，我们总还是需要整齐摆放的商品列表的对不对。也许margin并不是product的必要属性，至少它应该是可变的。我们抽出它来：\n\n\n```\n.product {\n\twidth: 180px;\n}\n\n.vertical-product {\n\theight: 400px;\n\tmargin-right: 10px;\n\tmargin-bottom: 10px;\n}\n\n.horizontal-product {\n\theight: auto;\n\tmargin-right: 20px;\n\tmargin-bottom: 10px;\n}\n```\n\n这样便将column或list之类的容器与product分开来毫无关系了，即使以后出现了其他组织形式，只要product的基本结构没有变都可以直接复用，无非是添加一些附属样式到新的xxx-product的class中。另外这样做还有一个好处，设计逻辑放在了HTML中，CSS更加强大。\n\n什么是样式逻辑？商品在瀑布流中不定高，在列表中定高，这就是一种样式的逻辑，如果用父子选择器的形式写在CSS中，那它就失去了自由。而放在HTML通过选择添加何种附属class来展现不同形式的product，则非常的自由与灵活。另外值得一说的是，margin-bottom是一样的，但我们应该各自放在各自的class里面，原因很简单，它们仅仅是一不小心恰好一样，在设计逻辑中它们并不是一样的bottom，这里并不是重复，而是看起来一样。如果以后需要改变其中的一个bottom，共用则显得非常别扭。\n\n***2. 分离皮肤与结构***\n\n第二点很容易理解，皮肤（theme）就是视觉效果，即使被剔除网页也没有什么影响的就是皮肤；而结构指地并不是像HTML这样抽象的结构，因为CSS毕竟还是样式，所以结构只是相对的页面结构。\n\n先来看看我们的product吧，添加一些背景色和边框：\n\n```\n.product {\n\twidth: 200px;\n\tbackground: #F6F2F2;\n\tborder: 1px solid #C4A0A0;\n}\n```\n\n看起来还不错，不过设计师都是自大狂，精心的调色，完美的搭配，绝对不会让你仅仅使用这么一次的，页面的其他模块、sidebar甚至是header都可能采用相同的背景颜色与边框，它们甚至可能互相嵌套。好吧，这其实在设计上是为了视觉统一，毕竟没有几个设计大师能hold住3，4种以上的颜色。所以我们能做的并不是在每个class中添加这样的样式，而是把它提出来成为独立的class，原因就像我开篇说的那样，颜色为混沌之源。\n\n```\n.main-bg {\n\tbackground: #F6F2F2;\n}\n\n.main-border {\n\tborder: 1px solid #C4A0A0;\n}\n```\n\n这样就可以在页面中随时使用主要的设计元素了，而且需要修改时也非常的简单，不用担心有什么地方漏掉。另外我将背景与边框分为了两个class，原因还是设计逻辑应该放在HTML，背景与边框并不是一定同时出现的，两者的关系应该由HTML决定，即使设计上逻辑决定了两者的绑定，在实现时也有可能因为HTML结构而放在两个不同的元素上。\n\nOOCSS强调class，将每组样式写成一个class方便HTML中使用，众多class组合起来能千变万化组成一个对象。所以如果是想一劳永逸的写一套UI作为开发时使用的样式，我建议使用OOCSS来进行开发。但它也有缺点，过多的将设计逻辑放在HTML中，极大的自由化了页面开发时的选择，如果写HTML的开发者不能很好的理解整套CSS的结构，较易在HTML中造成class混乱。\n\n#### DRY CSS\n\nDRY就是Donot repeat youself 不要重复。但其实这个名字有点无趣，哪个理论不是消除重复呢，但如何消除才是意义所在。总的来说我认为DRYCSS与OOCSS是两个极端，所以我将会以对比的方式来讲讲DRYCSS的内容。使用DRYCSS很简单，三步。\n\n***1. 分组可复用属性***\n\nDRYCSS跟OOCSS有点像，第一步都是分组样式，消除重复，但就像我说的，关键在于如何。OOCSS将样式集合看作对象，所以分组的逻辑是，某个元素本身应该是什么样的，而DRYCSS则关注重复，无论什么逻辑，只要是一样的就应该只有一个。其中粒度是值得思考的问题，如果太细，那只会成为一行样式一组这样无意义的情况，如果太粗，又会变成毫无复用性的庞然大物。我认为可以将一些有关联的缺了A时B就没作用的样式分为一组，还可以将某些惯用搭配分为一组。下面举个例子：\n\n```\n{\n\tfloat: left;\n\tposition: absolute;\n\tdisplay: inline-block;\n\toverflow: hidden;\n}\n```\n\n这是一组样式，可用来触发[Block formatting Contexts（块级格式化上下文）](http://kayosite.com/block-formatting-contexts-in-detail.html)，如此就完成了一组样式。接着再写2组关于尺寸的样式吧。\n\n```\n{\n\twidth: 960px;\n\theight: auto;\n}\n{\n\twidth: 720px;\n\theight: 600px;\n}\n{\n\twidth: 220px;\n\theight: 600px;\n}\n```\n这是三组样式用来布局，将页面分为左右两部分。\n\n***2. 按逻辑为分组命名***\n\n接着我们来为其命名，其实就是添加一个ID选择器，但是我们并不真的使用它，而是用来标示该组样式。下面就来命名上面所分组的样式。\n\n```\n#BLOCK_FORMATTING_CONTEXTS\n{\n\tfloat: left;\n\tposition: absolute;\n\tdisplay: inline-block;\n\toverflow: hidden;\n}\n\n#LAYOUT_FULL\n{\n\twidth: 960px;\n\theight: auto;\n}\n\n#LAYOUT_CONTENT\n{\n\twidth: 720px;\n\theight: 600px;\n}\n\n#LAYOUT_SIDEBAR\n{\n\twidth: 220px;\n\theight: 600px;\n}\n```\n\n这一步类似OOCSS的class，它决定了每组样式所代表的逻辑或用途，然而DRYCSS多了最关键的下一步，也是与OOCSS本质区别。\n\n***3. 为各个分组添加选择器***\n\nDRYCSS在使用时和OOCSS有着巨大的差异，在CSS文件中写入HTML中的class选择器来使用这些分组后的样式，而不是直接在HTML中使用CSS文件中写好的class。\n\n```\n.header,\n.container,\n.content-right,\n.content-left,\n#BLOCK_FORMATTING_CONTEXTS\n{\n\tfloat: left;\n\tposition: absolute;\n\tdisplay: inline-block;\n\toverflow: hidden;\n}\n\n.header,\n.navigator,\n.container,\n#LAYOUT_FULL\n{\n\twidth: 960px;\n\theight: auto;\n}\n\n\n.content-right,\n.section,\n#LAYOUT_CONTENT\n{\n\twidth: 720px;\n\theight: 600px;\n}\n\n.content-right,\n.sidebar,\n.profile,\n#LAYOUT_SIDEBAR\n{\n\twidth: 220px;\n\theight: 600px;\n}\n```\n\n可以看到，使用DRYCSS时，在HTML中所写的class将会非常表意，元素本身是什么用来做什么，就使用其意义的class命名，而且基本上是一个元素对应一个class，HTML将变的简单明了。另外DRYCSS也是相对于OOCSS的一种逆向思维，这才是最有趣的地方。在开发中，不应该像OOCSS那样思考如何应对未来假象的HTML，而是仅仅思考CSS本身。\n\n总的来说，OOCSS适合开发CSS框架或整套UI模版，是自外向内的UI开发方式；而DRYCSS则适合拯救混沌的HTML，或者加强HTML的结构性和表意性，是自内向外的UI开发方式。这里的内指地是HTML结构，外指地是CSS样式。\n\n#### SMACSS\n\n这是一个相对繁杂的CSS理论，分为Base、Layout、Module、Status和Theme共五个部分。不过它的核心思想仍然和OOCSS类似，鼓励使用class。\n\n***1. Base 基本属性***\n\n基础属性很容易理解，就是最基本的东西，很多样式简单的网站都采用一个简单的二级CSS文件模式，一个base.css通用于所有页面，而每个页面有一个特定的CSS文件，我想这就是Base的雏形。要说具体是什么，比如reset文件，再比如放置clearfix或BFC的一些类似工具集的文件。\n\n其实最终会发现，在Base中的CSS属性将会是几乎全站都要用到的属性，但我不想这么描述Base，因为这会误导人。大多数情况下，在一个网站建立之初也只会有几个简单的页面，于是这几个页面都要用到的属性就变成了通用属性，但并不是这么简单的。随着网站规模的扩大，需求的增加，设计师们灵感的迸发，所谓的通用和统一也在发生着潜移默化。所以在编写Base时，应该遵循的基准是，哪些样式是你做下一个网站时也会想用的，哪些样式即使设计改变了也只需要改变一些数值和颜色，哪些样式是一些基本原则；而不应该将目前大部分页面都在使用的样式放在Base中，还是那个道理，它们也许仅仅是恰好相同，而非逻辑一致。\n\n***2. Layout 布局***\n\n布局是一个网站的基本，无论是左右还是居中，甚至其他什么布局，要实现页面的基本浏览功能，布局必不可少。SMACSS将这一功能单独提出也是非常正确的，另外还约定了一个前缀`l-/layout-`来标识布局的class。举个最普遍的例子。\n\n```\n.l-header {}\n\t.l-brand {}\n\t.l-navigator {}\n.l-container {}\n\t.l-sidebar {}\n\t.l-content {}\n.l-footer {}\n```\n\n这就是一个简单的左右布局，导航和Logo中规中矩在最顶部。\n\n***3. Module 模块***\n\n模块是SMACSS最基本的思想，同时也是大部分CSS理论的基本，将样式模块化就能达到复用和可维护的目的，但是SMACSS提出了更具体的模块化方案。首先表象上来看，SMACSS中的模块应该拥有一个名字，并且为其class名，而模块其他class皆以为前缀。比如：\n\n```\n.product {}\n\t.product-title {}\n\t.product-image {}\n\t.product-border {}\n\t.product-shadow {}\n```\n\n可以看到例子中product是一个模块，title和image是包含在模块内的组件，可用可不用；border和shadow是类似OOCSS的附加class用来改变模块本身。总之，在模块内可以使用其名称做前缀任意组织模块结构，但目前是让其变得更易用，提高可扩展性和灵活度，如果仅仅为了某些功能而特意写一些class就有点有形无实的感觉了。\n\n***4. State 状态***\n\n状态经常和JavaScript放在一起使用，它是一种用来标识页面状态的class，无论是为用户标识还是用程序标识。还是一个常见的例子，马上就明白。active经常用来表示当前的tab，或者当前选中的目标，这就是一种状态，无论是样式还是程序都需要知道它。\n\nSMACSS仍然有一个对应的前缀用于标示状态class，`is-`是一个合适的词，指明某一元素是什么状态。\n\n***5. Theme 主题***\n\n主题就是皮肤，和OOCSS的分离皮肤与结构不谋而合。更重要的是对于可更换皮肤的站点来说，这样的分离是非常必要的，只需要更换加载的theme文件即可将皮肤更换。\n\n总的来说，SMACSS是一个较为注意细节与实现的CSS理论，非常适合初涉CSS的人，它可以让你的CSS跑在轨道上而不至于脱轨。其思想也与OOCSS有很多相通之处，如果没有适合的方案，我建议新手可以适当的融入OOCSS的思想而使用SMACSS的结构，这样写出来的网站样式至少不会马上陷入泥沼。\n\n## 哪一个好用呢？\n\n谈了许多的CSS原理，已经有点眼花缭乱，到底哪个好呢？这个问题又归结到了最佳实践上，虽然我并不认为有这样的实践，但我认为一个项目一定会有适合的实践，比如前面说的，如果你想做一个CSS框架然后再写HTML，那就用OOCSS；如果你想先写HTML或者已经有一个旧的页面，那DRYCSS应该很适合你；如果新手不知如何下手，那SMACSS可以指导你入门。\n\n无论如何，在我过去很长一段时间的独立UI开发“生涯”中，这些情况我都遇到过，也有一些自己的想法，我想我将在下一篇博客中谈谈自己对CSS的理解，并尝试整理出一些类似理论的东西来。\n","source":"_posts/2014-03-16-css-principle.md","raw":"---\nlayout: post\ntitle: 如何写好CSS？（OOCSS\\DRY\\SMACSS）\ntags: [css,oocss,drycss,smacss]\ncategory: Tech\n---\n\n很久没有写博客了，一是刚入职比较忙，二是因为总有学到新的有趣的东西，停不下脚步来总结一下。最近出差到了帝都，反而能挤出些时间来写点什么了，也正好趁着出差做的这个项目讨论一下CSS理论。\n\n我现在面对的CSS基本上就是一个三头六臂的怪物，一点不夸张，因为真的是三头六臂，同一个样式在同一个element上作用了好几遍，而同一个样式又分散在4，5个class上，优先级有很多层。可以看得出这个怪物不是一个人造就的，早期的开发者选择了SCSS技术，但混乱的import导致了一些基本的样式被多次调用，而后面的开发者又为了摆脱之前的混乱引入了其他共用样式，但无济于事。原因出在HTML上，CSS依托于HTML没有被正确的抽象，而HTML又完全的依赖业务，所有class以业务取名，HTML和CSS基本没有复用，最终抽出的共用样式也仅仅是又一次的重复。CSS重构最难的地方在于没有脚手架，即测试。虽然有一些方法来测试，比如reftest，但还不够成熟。抱着有总比没好的心态，CSS被一层又一层的覆盖了上去。\n<!-- more -->\n\n## 真正的问题是什么？\n\nCSS即层叠样式表，所以一层一层覆盖其实是其本质特征。真正的问题在于维护，许多人认为CSS仅是样式，不是代码，无需维护，所以任意书写，只要将自己需要的样式的优先级设为最高即可，才导致了深层级CSS的出现，因为每次添加一个样式就必须比以前的优先级高才能在页面看到。深层级不仅造成维护性降低，可读性也是一个问题，人不是机器，无法很优雅的按优先级阅读，所以很难确认一个样式用于哪里，其实还存在许多的冗余样式，在任何地方都被覆盖的样式。这样的代码在扩展性上，一开始反而是有优势的，因为添加一个新class，无需担心影响其他地方，但慢慢随着项目规模的增大，页面增多，需要复制样式的地方也越来越多，它们之间又存在微小的差异，设计的更改，需求的变化，这一切都会将这种快餐式的CSS推进柏油坑。因为难以维护，所以无法响应需求，所以无法复用，只能复制，恶性循环。\n\n正如上面所说的，问题在于可读性、维护性、扩展性、复用性这几个方面。所以只要提高它们就能解决问题, 虽然这么说，也不是如此简单的。先来谈谈在CSS中，这些概念都有着怎样的意义。\n\n#### 可读性\n\n有人认为CSS不是程序，不需要可读性，有人认为CSS只要写出来就有可读性，因为很简单。抛开各种预处理器不说，原生CSS结构确实简单，没有需要编程的部分，但仍然可能导致混乱。原因有二，一是CSS可以层叠，其中涉及到了优先级和作用范围，如果写的不好，人很难读出其中的意义，二是CSS属性众多，加上CSS3引入了很多用法独特的属性，一个选择器可能包含几十个属性。比如下面这段我随便写的CSS代码：\n\n```\nspan {\n\t-webkit-box-shadow: 6px 4px 4px red;\n\t-moz-box-shadow: 6px 4px 4px red;\n\tbox-shadow: 6px 4px 4px red;\n}\ndiv span {\n\tborder-width: 4px;\n\tborder-style: dotted;\n\tborder-color: blue;\n}\n#box {\n\tborder-left: 2px solid red;\n\tborder-bottom: 2px solid red; \n}\n\n```\n\n乍一看也没什么，都是border，大致能看出来这段CSS只是为了添加一个红色的阴影让box看起来比较立体。但中间的部分似乎是捣乱的，你可能会说这太傻了，看不到吗。是的，当这3部分散落在上万行的CSS中时，肯定看不到。于是有人很自然的想起了我们可爱的浏览器，没错，在浏览器中可以快速找到作用于目标的CSS样式，但这也是万恶之源。首先我假设你不知道中间那部分东西是为了什么而写的，因为你是靠浏览器找到它的。然后剩下两种可能，不管三七二十一改了再说和看看它为什么存在。前者悲剧的可能性是100%，后者悲剧的可能性是90%，因为你已经掉坑里了，很快我们会发现要修改它还牵扯到了另外的地方，接着在浏览器中探索到另一个莫名其妙的样式，当你弄懂全部的时候，你应该已经把上万行的代码弄了个一清二楚了，也许最幸运的是，浪费了几个小时的时间发现只需要修改一行就能达到目的。\n\n当然，我们可以天真的认为，只要把他们写在一起就可以了，这样找起来很简单。而我将继续顺着这样的思路来尝试曝露问题。\n\n#### 维护性\n\n所谓物以类聚是很有道理的，人们习惯将事物归类，但问题是分类标准，样式并不关心业务，无论是什么文字内容，还是功能有何不同，它在乎的只是样式，比如文字的尺寸，间距和宽高，颜色等等。如果简单的将一个组件的样式放在一起，势必带来的就是小段代码的重复书写。不觉得有多严重？我来举个栗子。\n\n```\naside {\n\tbox-shadow: 6px 4px 4px #AA3343;\n}\nnav {\n\tbox-shadow: 6px 4px 4px #AB3633;\t\n}\n.item {\n\tbox-shadow: 6px 4px 4px #AA3732;\n}\n.item.otherStatus {\n\tbox-shadow: 6px 4px 4px #AA3132;\n}\n```\n\n继续说上面的例子，box需要阴影，但如果这个项目的UI统一风格，包括sidebar，navigator以及item都需要这样的阴影呢？再如果，明天客户或者UX一拍脑袋，这个阴影应该是灰色的不该是红色的呢？不要继续天真的认为全局替换是救命稻草。首先，没有几个网站会用red，blur做色调的，你用的应该是#AA3333，这样的代码，然后你发现sidebar用了#A43433，而navigator是#AB3633，等等，item有两个状态，而两个状态对应的颜色是不一样的。这怎么可能？但当你打开浏览器的时候你会发现本来就相差无几的颜色，在阴影中变得一模一样了，谁看的出来呢，当初使用的时候可能也不过是随意的在mockup中取的一个颜色。\n\n大量的重复带来的不仅仅是代码的冗余，我们必须靠人力去同步它们，而人很难保证它们的修改是完全一致的，尤其是当它们中引入了一些不一致的独特的东西时。不要小看CSS，其后果就是进度和人力的压力，后面就是PM有没有读过《人月神话》的事了。\n\n肯定有人在想，谁让你当初要写成这样呢。我们在读代码的时候最喜欢问，当初为什么要这么写？但慢慢的你会读出它的历史，有时候它是身不由己的。这就涉及到了下一个要讨论的内容。\n\n#### 扩展性\n\n扩展性是一个具有欺骗性的东西，所谓的扩展性其实就是在现有基础上再次开发新东西的性能，但我认为它还必须有前提条件，那就是保持可读性与维护性。\n\n简单的追求可维护性是自取灭亡，原因很简单，将新旧代码完全分离的时候扩展性最高，因为不必担心对以前的部分有影响，新的样式可以随意发挥。是不是很神奇，这样想的我们写下的代码，肯定就是前面我们追问的代码。所以自己回答自己吧，当初没考虑可读性和维护性，只想着快点增加新的样式，就这么写了。\n\n那什么才是一个好的扩展性呢，简单来说，就是多功能产品。比如一个box，也许它的样式就时\n\n#### 复用性\n\n似乎我一直在说的就是重复，那我们就来说说复用性，如何才能复用CSS代码是一个很大的问题，比如粒度，是一两个属性进行复用还是一大组选择器进行复用呢，再比如对象，是为了class复用属性，还是为了html复用class呢。这些选择不算太重要，但是带来的影响却很重大，可以说是整个CSS结构的改变。下面继续用box的阴影来讨论复用。\n\n```\n.shadow {\n\t-webkit-box-shadow: 6px 4px 4px #A93334;\n\t-moz-box-shadow: 6px 4px 4px #A93334;\n\tbox-shadow: 6px 4px 4px #A93334;\n\tborder-left: 2px solid #A93334\\9;\n\tborder-bottom: 2px solid #A93334\\9; \n}\n```\n\n这样看起来我有了一个shadow的class可以给任意的目标加上这个阴影了，但这导致了一个复用的问题，和上面那段捣乱的CSS样式一样，如果item已有另外2个border了，那这个class是无法去除的。所以复用时不仅要考虑需要什么，还要考虑不需要什么。另外一些必须的属性比如display还有overflow等也是要考虑的，因为user agent的原因，很多属性是隐藏在element中的。\n\n## 如何解决问题？\n\n主流的CSS原则有OOCSS，DRY，SMACSS以及BEM，他们皆是为解决CSS的各种问题而生。\n\n#### OOCSS\n\nOOCSS即面向对象的CSS，这里对象指的是页面中的元素对象，与传统编程中的面向对象不太相同，比如不存在方法这种东西，硬要说的话，附加的一些class可以看作是继承或者接口之类的东西来实现对象的差异化。比如电商网站中的商品就是一个典型的对象，它们既有许多相同的部分，又有许多差异，宽高、按钮、图片、标题等基本布局都是相同的，而边距、线框、背景颜色、字号等都是差异化的。由此按照OOCSS的指导原则，我们应该写一个product class，然后为其添加一些border、theme之类的class来差异化它：\n\n```\n.product {\n\tdisplay: block;\n\toverflow: hidden;\n\tfloat: left;\n\twidth: 200px;\n\theight: auto;\n}\n.product-head{...}\n.product-body{...}\n.product-foot{...}\n\n.product-theme-black {\n\tbackground: black;\n\tcolor: white;\n}\n\n.product-border {\n\tborder: 1px solid #333;\n}\n```\n\n这样在以上两种附加class的作用下，我们在html中就可以获得4种不同的product样式，随着附加class增加，product的样式也会呈指数增加，千变万化。这仅仅是一个简单的例子，意在点出OOCSS的理念，但并没有突出它的意义所在。别着急，先来看看OOCSS的两大原则。\n\n\n***1. 分离容器与内容***\n\n所谓的容器即包裹对象的元素，比如一个div，我们经常会命名为wrap、container、body等。那么如何才算是分离容器与内容呢？很简单，一句话，内容在哪都可用。也就是说不应该出现这样的情况：\n\n```\n.container .product {\n\t...\n}\n```\n\n这样干的结果就是复用性大大降低，因为只能在这个容器内使用它了。但这并不代表我们应该将所需的样式全部一股脑的扔进单独的class中，对于差异化应该单独放在一个class中，这才是OOCSS的精髓。\n\n举个例子，当我们既不想牺牲太多性能，又想来个瀑布流显摆显摆的时候，大部分前端都会使用column，类似泳道的设计。你想说哦不，这是伪pinterest，但是谁在乎呢，用户是不会有闲工夫拖拽浏览器的宽度来鉴别它的，在IE下商品多的时候至少不会太卡。哈，别较真，首先分为几个column，然后按照高度往里填放商品，先来看看下面的代码吧，我有省略一些样式避免误导：\n\n```\n.column {\n\theight: auto;\n\twidth: 200px;\n}\n\n.product {\n\twidth: 180px;\n\tmargin-right: 20px;\n\tmargin-bottom: 10px;\n}\n```\n\n看起来不错，每列200px宽，商品放入其中，水平间距要大，垂直间距要小些才像column。但是等等，我们总还是需要整齐摆放的商品列表的对不对。也许margin并不是product的必要属性，至少它应该是可变的。我们抽出它来：\n\n\n```\n.product {\n\twidth: 180px;\n}\n\n.vertical-product {\n\theight: 400px;\n\tmargin-right: 10px;\n\tmargin-bottom: 10px;\n}\n\n.horizontal-product {\n\theight: auto;\n\tmargin-right: 20px;\n\tmargin-bottom: 10px;\n}\n```\n\n这样便将column或list之类的容器与product分开来毫无关系了，即使以后出现了其他组织形式，只要product的基本结构没有变都可以直接复用，无非是添加一些附属样式到新的xxx-product的class中。另外这样做还有一个好处，设计逻辑放在了HTML中，CSS更加强大。\n\n什么是样式逻辑？商品在瀑布流中不定高，在列表中定高，这就是一种样式的逻辑，如果用父子选择器的形式写在CSS中，那它就失去了自由。而放在HTML通过选择添加何种附属class来展现不同形式的product，则非常的自由与灵活。另外值得一说的是，margin-bottom是一样的，但我们应该各自放在各自的class里面，原因很简单，它们仅仅是一不小心恰好一样，在设计逻辑中它们并不是一样的bottom，这里并不是重复，而是看起来一样。如果以后需要改变其中的一个bottom，共用则显得非常别扭。\n\n***2. 分离皮肤与结构***\n\n第二点很容易理解，皮肤（theme）就是视觉效果，即使被剔除网页也没有什么影响的就是皮肤；而结构指地并不是像HTML这样抽象的结构，因为CSS毕竟还是样式，所以结构只是相对的页面结构。\n\n先来看看我们的product吧，添加一些背景色和边框：\n\n```\n.product {\n\twidth: 200px;\n\tbackground: #F6F2F2;\n\tborder: 1px solid #C4A0A0;\n}\n```\n\n看起来还不错，不过设计师都是自大狂，精心的调色，完美的搭配，绝对不会让你仅仅使用这么一次的，页面的其他模块、sidebar甚至是header都可能采用相同的背景颜色与边框，它们甚至可能互相嵌套。好吧，这其实在设计上是为了视觉统一，毕竟没有几个设计大师能hold住3，4种以上的颜色。所以我们能做的并不是在每个class中添加这样的样式，而是把它提出来成为独立的class，原因就像我开篇说的那样，颜色为混沌之源。\n\n```\n.main-bg {\n\tbackground: #F6F2F2;\n}\n\n.main-border {\n\tborder: 1px solid #C4A0A0;\n}\n```\n\n这样就可以在页面中随时使用主要的设计元素了，而且需要修改时也非常的简单，不用担心有什么地方漏掉。另外我将背景与边框分为了两个class，原因还是设计逻辑应该放在HTML，背景与边框并不是一定同时出现的，两者的关系应该由HTML决定，即使设计上逻辑决定了两者的绑定，在实现时也有可能因为HTML结构而放在两个不同的元素上。\n\nOOCSS强调class，将每组样式写成一个class方便HTML中使用，众多class组合起来能千变万化组成一个对象。所以如果是想一劳永逸的写一套UI作为开发时使用的样式，我建议使用OOCSS来进行开发。但它也有缺点，过多的将设计逻辑放在HTML中，极大的自由化了页面开发时的选择，如果写HTML的开发者不能很好的理解整套CSS的结构，较易在HTML中造成class混乱。\n\n#### DRY CSS\n\nDRY就是Donot repeat youself 不要重复。但其实这个名字有点无趣，哪个理论不是消除重复呢，但如何消除才是意义所在。总的来说我认为DRYCSS与OOCSS是两个极端，所以我将会以对比的方式来讲讲DRYCSS的内容。使用DRYCSS很简单，三步。\n\n***1. 分组可复用属性***\n\nDRYCSS跟OOCSS有点像，第一步都是分组样式，消除重复，但就像我说的，关键在于如何。OOCSS将样式集合看作对象，所以分组的逻辑是，某个元素本身应该是什么样的，而DRYCSS则关注重复，无论什么逻辑，只要是一样的就应该只有一个。其中粒度是值得思考的问题，如果太细，那只会成为一行样式一组这样无意义的情况，如果太粗，又会变成毫无复用性的庞然大物。我认为可以将一些有关联的缺了A时B就没作用的样式分为一组，还可以将某些惯用搭配分为一组。下面举个例子：\n\n```\n{\n\tfloat: left;\n\tposition: absolute;\n\tdisplay: inline-block;\n\toverflow: hidden;\n}\n```\n\n这是一组样式，可用来触发[Block formatting Contexts（块级格式化上下文）](http://kayosite.com/block-formatting-contexts-in-detail.html)，如此就完成了一组样式。接着再写2组关于尺寸的样式吧。\n\n```\n{\n\twidth: 960px;\n\theight: auto;\n}\n{\n\twidth: 720px;\n\theight: 600px;\n}\n{\n\twidth: 220px;\n\theight: 600px;\n}\n```\n这是三组样式用来布局，将页面分为左右两部分。\n\n***2. 按逻辑为分组命名***\n\n接着我们来为其命名，其实就是添加一个ID选择器，但是我们并不真的使用它，而是用来标示该组样式。下面就来命名上面所分组的样式。\n\n```\n#BLOCK_FORMATTING_CONTEXTS\n{\n\tfloat: left;\n\tposition: absolute;\n\tdisplay: inline-block;\n\toverflow: hidden;\n}\n\n#LAYOUT_FULL\n{\n\twidth: 960px;\n\theight: auto;\n}\n\n#LAYOUT_CONTENT\n{\n\twidth: 720px;\n\theight: 600px;\n}\n\n#LAYOUT_SIDEBAR\n{\n\twidth: 220px;\n\theight: 600px;\n}\n```\n\n这一步类似OOCSS的class，它决定了每组样式所代表的逻辑或用途，然而DRYCSS多了最关键的下一步，也是与OOCSS本质区别。\n\n***3. 为各个分组添加选择器***\n\nDRYCSS在使用时和OOCSS有着巨大的差异，在CSS文件中写入HTML中的class选择器来使用这些分组后的样式，而不是直接在HTML中使用CSS文件中写好的class。\n\n```\n.header,\n.container,\n.content-right,\n.content-left,\n#BLOCK_FORMATTING_CONTEXTS\n{\n\tfloat: left;\n\tposition: absolute;\n\tdisplay: inline-block;\n\toverflow: hidden;\n}\n\n.header,\n.navigator,\n.container,\n#LAYOUT_FULL\n{\n\twidth: 960px;\n\theight: auto;\n}\n\n\n.content-right,\n.section,\n#LAYOUT_CONTENT\n{\n\twidth: 720px;\n\theight: 600px;\n}\n\n.content-right,\n.sidebar,\n.profile,\n#LAYOUT_SIDEBAR\n{\n\twidth: 220px;\n\theight: 600px;\n}\n```\n\n可以看到，使用DRYCSS时，在HTML中所写的class将会非常表意，元素本身是什么用来做什么，就使用其意义的class命名，而且基本上是一个元素对应一个class，HTML将变的简单明了。另外DRYCSS也是相对于OOCSS的一种逆向思维，这才是最有趣的地方。在开发中，不应该像OOCSS那样思考如何应对未来假象的HTML，而是仅仅思考CSS本身。\n\n总的来说，OOCSS适合开发CSS框架或整套UI模版，是自外向内的UI开发方式；而DRYCSS则适合拯救混沌的HTML，或者加强HTML的结构性和表意性，是自内向外的UI开发方式。这里的内指地是HTML结构，外指地是CSS样式。\n\n#### SMACSS\n\n这是一个相对繁杂的CSS理论，分为Base、Layout、Module、Status和Theme共五个部分。不过它的核心思想仍然和OOCSS类似，鼓励使用class。\n\n***1. Base 基本属性***\n\n基础属性很容易理解，就是最基本的东西，很多样式简单的网站都采用一个简单的二级CSS文件模式，一个base.css通用于所有页面，而每个页面有一个特定的CSS文件，我想这就是Base的雏形。要说具体是什么，比如reset文件，再比如放置clearfix或BFC的一些类似工具集的文件。\n\n其实最终会发现，在Base中的CSS属性将会是几乎全站都要用到的属性，但我不想这么描述Base，因为这会误导人。大多数情况下，在一个网站建立之初也只会有几个简单的页面，于是这几个页面都要用到的属性就变成了通用属性，但并不是这么简单的。随着网站规模的扩大，需求的增加，设计师们灵感的迸发，所谓的通用和统一也在发生着潜移默化。所以在编写Base时，应该遵循的基准是，哪些样式是你做下一个网站时也会想用的，哪些样式即使设计改变了也只需要改变一些数值和颜色，哪些样式是一些基本原则；而不应该将目前大部分页面都在使用的样式放在Base中，还是那个道理，它们也许仅仅是恰好相同，而非逻辑一致。\n\n***2. Layout 布局***\n\n布局是一个网站的基本，无论是左右还是居中，甚至其他什么布局，要实现页面的基本浏览功能，布局必不可少。SMACSS将这一功能单独提出也是非常正确的，另外还约定了一个前缀`l-/layout-`来标识布局的class。举个最普遍的例子。\n\n```\n.l-header {}\n\t.l-brand {}\n\t.l-navigator {}\n.l-container {}\n\t.l-sidebar {}\n\t.l-content {}\n.l-footer {}\n```\n\n这就是一个简单的左右布局，导航和Logo中规中矩在最顶部。\n\n***3. Module 模块***\n\n模块是SMACSS最基本的思想，同时也是大部分CSS理论的基本，将样式模块化就能达到复用和可维护的目的，但是SMACSS提出了更具体的模块化方案。首先表象上来看，SMACSS中的模块应该拥有一个名字，并且为其class名，而模块其他class皆以为前缀。比如：\n\n```\n.product {}\n\t.product-title {}\n\t.product-image {}\n\t.product-border {}\n\t.product-shadow {}\n```\n\n可以看到例子中product是一个模块，title和image是包含在模块内的组件，可用可不用；border和shadow是类似OOCSS的附加class用来改变模块本身。总之，在模块内可以使用其名称做前缀任意组织模块结构，但目前是让其变得更易用，提高可扩展性和灵活度，如果仅仅为了某些功能而特意写一些class就有点有形无实的感觉了。\n\n***4. State 状态***\n\n状态经常和JavaScript放在一起使用，它是一种用来标识页面状态的class，无论是为用户标识还是用程序标识。还是一个常见的例子，马上就明白。active经常用来表示当前的tab，或者当前选中的目标，这就是一种状态，无论是样式还是程序都需要知道它。\n\nSMACSS仍然有一个对应的前缀用于标示状态class，`is-`是一个合适的词，指明某一元素是什么状态。\n\n***5. Theme 主题***\n\n主题就是皮肤，和OOCSS的分离皮肤与结构不谋而合。更重要的是对于可更换皮肤的站点来说，这样的分离是非常必要的，只需要更换加载的theme文件即可将皮肤更换。\n\n总的来说，SMACSS是一个较为注意细节与实现的CSS理论，非常适合初涉CSS的人，它可以让你的CSS跑在轨道上而不至于脱轨。其思想也与OOCSS有很多相通之处，如果没有适合的方案，我建议新手可以适当的融入OOCSS的思想而使用SMACSS的结构，这样写出来的网站样式至少不会马上陷入泥沼。\n\n## 哪一个好用呢？\n\n谈了许多的CSS原理，已经有点眼花缭乱，到底哪个好呢？这个问题又归结到了最佳实践上，虽然我并不认为有这样的实践，但我认为一个项目一定会有适合的实践，比如前面说的，如果你想做一个CSS框架然后再写HTML，那就用OOCSS；如果你想先写HTML或者已经有一个旧的页面，那DRYCSS应该很适合你；如果新手不知如何下手，那SMACSS可以指导你入门。\n\n无论如何，在我过去很长一段时间的独立UI开发“生涯”中，这些情况我都遇到过，也有一些自己的想法，我想我将在下一篇博客中谈谈自己对CSS的理解，并尝试整理出一些类似理论的东西来。\n","slug":"css-principle","published":1,"date":"2014-03-15T16:00:00.000Z","updated":"2021-11-28T11:37:27.160Z","comments":1,"photos":[],"link":"","_id":"ckwj65518000wvyjhdrpietit","content":"<p>很久没有写博客了，一是刚入职比较忙，二是因为总有学到新的有趣的东西，停不下脚步来总结一下。最近出差到了帝都，反而能挤出些时间来写点什么了，也正好趁着出差做的这个项目讨论一下CSS理论。</p>\n<p>我现在面对的CSS基本上就是一个三头六臂的怪物，一点不夸张，因为真的是三头六臂，同一个样式在同一个element上作用了好几遍，而同一个样式又分散在4，5个class上，优先级有很多层。可以看得出这个怪物不是一个人造就的，早期的开发者选择了SCSS技术，但混乱的import导致了一些基本的样式被多次调用，而后面的开发者又为了摆脱之前的混乱引入了其他共用样式，但无济于事。原因出在HTML上，CSS依托于HTML没有被正确的抽象，而HTML又完全的依赖业务，所有class以业务取名，HTML和CSS基本没有复用，最终抽出的共用样式也仅仅是又一次的重复。CSS重构最难的地方在于没有脚手架，即测试。虽然有一些方法来测试，比如reftest，但还不够成熟。抱着有总比没好的心态，CSS被一层又一层的覆盖了上去。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"真正的问题是什么？\"><a href=\"#真正的问题是什么？\" class=\"headerlink\" title=\"真正的问题是什么？\"></a>真正的问题是什么？</h2><p>CSS即层叠样式表，所以一层一层覆盖其实是其本质特征。真正的问题在于维护，许多人认为CSS仅是样式，不是代码，无需维护，所以任意书写，只要将自己需要的样式的优先级设为最高即可，才导致了深层级CSS的出现，因为每次添加一个样式就必须比以前的优先级高才能在页面看到。深层级不仅造成维护性降低，可读性也是一个问题，人不是机器，无法很优雅的按优先级阅读，所以很难确认一个样式用于哪里，其实还存在许多的冗余样式，在任何地方都被覆盖的样式。这样的代码在扩展性上，一开始反而是有优势的，因为添加一个新class，无需担心影响其他地方，但慢慢随着项目规模的增大，页面增多，需要复制样式的地方也越来越多，它们之间又存在微小的差异，设计的更改，需求的变化，这一切都会将这种快餐式的CSS推进柏油坑。因为难以维护，所以无法响应需求，所以无法复用，只能复制，恶性循环。</p>\n<p>正如上面所说的，问题在于可读性、维护性、扩展性、复用性这几个方面。所以只要提高它们就能解决问题, 虽然这么说，也不是如此简单的。先来谈谈在CSS中，这些概念都有着怎样的意义。</p>\n<h4 id=\"可读性\"><a href=\"#可读性\" class=\"headerlink\" title=\"可读性\"></a>可读性</h4><p>有人认为CSS不是程序，不需要可读性，有人认为CSS只要写出来就有可读性，因为很简单。抛开各种预处理器不说，原生CSS结构确实简单，没有需要编程的部分，但仍然可能导致混乱。原因有二，一是CSS可以层叠，其中涉及到了优先级和作用范围，如果写的不好，人很难读出其中的意义，二是CSS属性众多，加上CSS3引入了很多用法独特的属性，一个选择器可能包含几十个属性。比如下面这段我随便写的CSS代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">span &#123;</span><br><span class=\"line\">\t-webkit-box-shadow: 6px 4px 4px red;</span><br><span class=\"line\">\t-moz-box-shadow: 6px 4px 4px red;</span><br><span class=\"line\">\tbox-shadow: 6px 4px 4px red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">div span &#123;</span><br><span class=\"line\">\tborder-width: 4px;</span><br><span class=\"line\">\tborder-style: dotted;</span><br><span class=\"line\">\tborder-color: blue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">#box &#123;</span><br><span class=\"line\">\tborder-left: 2px solid red;</span><br><span class=\"line\">\tborder-bottom: 2px solid red; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>乍一看也没什么，都是border，大致能看出来这段CSS只是为了添加一个红色的阴影让box看起来比较立体。但中间的部分似乎是捣乱的，你可能会说这太傻了，看不到吗。是的，当这3部分散落在上万行的CSS中时，肯定看不到。于是有人很自然的想起了我们可爱的浏览器，没错，在浏览器中可以快速找到作用于目标的CSS样式，但这也是万恶之源。首先我假设你不知道中间那部分东西是为了什么而写的，因为你是靠浏览器找到它的。然后剩下两种可能，不管三七二十一改了再说和看看它为什么存在。前者悲剧的可能性是100%，后者悲剧的可能性是90%，因为你已经掉坑里了，很快我们会发现要修改它还牵扯到了另外的地方，接着在浏览器中探索到另一个莫名其妙的样式，当你弄懂全部的时候，你应该已经把上万行的代码弄了个一清二楚了，也许最幸运的是，浪费了几个小时的时间发现只需要修改一行就能达到目的。</p>\n<p>当然，我们可以天真的认为，只要把他们写在一起就可以了，这样找起来很简单。而我将继续顺着这样的思路来尝试曝露问题。</p>\n<h4 id=\"维护性\"><a href=\"#维护性\" class=\"headerlink\" title=\"维护性\"></a>维护性</h4><p>所谓物以类聚是很有道理的，人们习惯将事物归类，但问题是分类标准，样式并不关心业务，无论是什么文字内容，还是功能有何不同，它在乎的只是样式，比如文字的尺寸，间距和宽高，颜色等等。如果简单的将一个组件的样式放在一起，势必带来的就是小段代码的重复书写。不觉得有多严重？我来举个栗子。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">aside &#123;</span><br><span class=\"line\">\tbox-shadow: 6px 4px 4px #AA3343;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">nav &#123;</span><br><span class=\"line\">\tbox-shadow: 6px 4px 4px #AB3633;\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.item &#123;</span><br><span class=\"line\">\tbox-shadow: 6px 4px 4px #AA3732;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.item.otherStatus &#123;</span><br><span class=\"line\">\tbox-shadow: 6px 4px 4px #AA3132;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>继续说上面的例子，box需要阴影，但如果这个项目的UI统一风格，包括sidebar，navigator以及item都需要这样的阴影呢？再如果，明天客户或者UX一拍脑袋，这个阴影应该是灰色的不该是红色的呢？不要继续天真的认为全局替换是救命稻草。首先，没有几个网站会用red，blur做色调的，你用的应该是#AA3333，这样的代码，然后你发现sidebar用了#A43433，而navigator是#AB3633，等等，item有两个状态，而两个状态对应的颜色是不一样的。这怎么可能？但当你打开浏览器的时候你会发现本来就相差无几的颜色，在阴影中变得一模一样了，谁看的出来呢，当初使用的时候可能也不过是随意的在mockup中取的一个颜色。</p>\n<p>大量的重复带来的不仅仅是代码的冗余，我们必须靠人力去同步它们，而人很难保证它们的修改是完全一致的，尤其是当它们中引入了一些不一致的独特的东西时。不要小看CSS，其后果就是进度和人力的压力，后面就是PM有没有读过《人月神话》的事了。</p>\n<p>肯定有人在想，谁让你当初要写成这样呢。我们在读代码的时候最喜欢问，当初为什么要这么写？但慢慢的你会读出它的历史，有时候它是身不由己的。这就涉及到了下一个要讨论的内容。</p>\n<h4 id=\"扩展性\"><a href=\"#扩展性\" class=\"headerlink\" title=\"扩展性\"></a>扩展性</h4><p>扩展性是一个具有欺骗性的东西，所谓的扩展性其实就是在现有基础上再次开发新东西的性能，但我认为它还必须有前提条件，那就是保持可读性与维护性。</p>\n<p>简单的追求可维护性是自取灭亡，原因很简单，将新旧代码完全分离的时候扩展性最高，因为不必担心对以前的部分有影响，新的样式可以随意发挥。是不是很神奇，这样想的我们写下的代码，肯定就是前面我们追问的代码。所以自己回答自己吧，当初没考虑可读性和维护性，只想着快点增加新的样式，就这么写了。</p>\n<p>那什么才是一个好的扩展性呢，简单来说，就是多功能产品。比如一个box，也许它的样式就时</p>\n<h4 id=\"复用性\"><a href=\"#复用性\" class=\"headerlink\" title=\"复用性\"></a>复用性</h4><p>似乎我一直在说的就是重复，那我们就来说说复用性，如何才能复用CSS代码是一个很大的问题，比如粒度，是一两个属性进行复用还是一大组选择器进行复用呢，再比如对象，是为了class复用属性，还是为了html复用class呢。这些选择不算太重要，但是带来的影响却很重大，可以说是整个CSS结构的改变。下面继续用box的阴影来讨论复用。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.shadow &#123;</span><br><span class=\"line\">\t-webkit-box-shadow: 6px 4px 4px #A93334;</span><br><span class=\"line\">\t-moz-box-shadow: 6px 4px 4px #A93334;</span><br><span class=\"line\">\tbox-shadow: 6px 4px 4px #A93334;</span><br><span class=\"line\">\tborder-left: 2px solid #A93334\\9;</span><br><span class=\"line\">\tborder-bottom: 2px solid #A93334\\9; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样看起来我有了一个shadow的class可以给任意的目标加上这个阴影了，但这导致了一个复用的问题，和上面那段捣乱的CSS样式一样，如果item已有另外2个border了，那这个class是无法去除的。所以复用时不仅要考虑需要什么，还要考虑不需要什么。另外一些必须的属性比如display还有overflow等也是要考虑的，因为user agent的原因，很多属性是隐藏在element中的。</p>\n<h2 id=\"如何解决问题？\"><a href=\"#如何解决问题？\" class=\"headerlink\" title=\"如何解决问题？\"></a>如何解决问题？</h2><p>主流的CSS原则有OOCSS，DRY，SMACSS以及BEM，他们皆是为解决CSS的各种问题而生。</p>\n<h4 id=\"OOCSS\"><a href=\"#OOCSS\" class=\"headerlink\" title=\"OOCSS\"></a>OOCSS</h4><p>OOCSS即面向对象的CSS，这里对象指的是页面中的元素对象，与传统编程中的面向对象不太相同，比如不存在方法这种东西，硬要说的话，附加的一些class可以看作是继承或者接口之类的东西来实现对象的差异化。比如电商网站中的商品就是一个典型的对象，它们既有许多相同的部分，又有许多差异，宽高、按钮、图片、标题等基本布局都是相同的，而边距、线框、背景颜色、字号等都是差异化的。由此按照OOCSS的指导原则，我们应该写一个product class，然后为其添加一些border、theme之类的class来差异化它：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.product &#123;</span><br><span class=\"line\">\tdisplay: block;</span><br><span class=\"line\">\toverflow: hidden;</span><br><span class=\"line\">\tfloat: left;</span><br><span class=\"line\">\twidth: 200px;</span><br><span class=\"line\">\theight: auto;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.product-head&#123;...&#125;</span><br><span class=\"line\">.product-body&#123;...&#125;</span><br><span class=\"line\">.product-foot&#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.product-theme-black &#123;</span><br><span class=\"line\">\tbackground: black;</span><br><span class=\"line\">\tcolor: white;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.product-border &#123;</span><br><span class=\"line\">\tborder: 1px solid #333;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样在以上两种附加class的作用下，我们在html中就可以获得4种不同的product样式，随着附加class增加，product的样式也会呈指数增加，千变万化。这仅仅是一个简单的例子，意在点出OOCSS的理念，但并没有突出它的意义所在。别着急，先来看看OOCSS的两大原则。</p>\n<p><em><strong>1. 分离容器与内容</strong></em></p>\n<p>所谓的容器即包裹对象的元素，比如一个div，我们经常会命名为wrap、container、body等。那么如何才算是分离容器与内容呢？很简单，一句话，内容在哪都可用。也就是说不应该出现这样的情况：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.container .product &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样干的结果就是复用性大大降低，因为只能在这个容器内使用它了。但这并不代表我们应该将所需的样式全部一股脑的扔进单独的class中，对于差异化应该单独放在一个class中，这才是OOCSS的精髓。</p>\n<p>举个例子，当我们既不想牺牲太多性能，又想来个瀑布流显摆显摆的时候，大部分前端都会使用column，类似泳道的设计。你想说哦不，这是伪pinterest，但是谁在乎呢，用户是不会有闲工夫拖拽浏览器的宽度来鉴别它的，在IE下商品多的时候至少不会太卡。哈，别较真，首先分为几个column，然后按照高度往里填放商品，先来看看下面的代码吧，我有省略一些样式避免误导：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.column &#123;</span><br><span class=\"line\">\theight: auto;</span><br><span class=\"line\">\twidth: 200px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.product &#123;</span><br><span class=\"line\">\twidth: 180px;</span><br><span class=\"line\">\tmargin-right: 20px;</span><br><span class=\"line\">\tmargin-bottom: 10px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看起来不错，每列200px宽，商品放入其中，水平间距要大，垂直间距要小些才像column。但是等等，我们总还是需要整齐摆放的商品列表的对不对。也许margin并不是product的必要属性，至少它应该是可变的。我们抽出它来：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.product &#123;</span><br><span class=\"line\">\twidth: 180px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.vertical-product &#123;</span><br><span class=\"line\">\theight: 400px;</span><br><span class=\"line\">\tmargin-right: 10px;</span><br><span class=\"line\">\tmargin-bottom: 10px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.horizontal-product &#123;</span><br><span class=\"line\">\theight: auto;</span><br><span class=\"line\">\tmargin-right: 20px;</span><br><span class=\"line\">\tmargin-bottom: 10px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样便将column或list之类的容器与product分开来毫无关系了，即使以后出现了其他组织形式，只要product的基本结构没有变都可以直接复用，无非是添加一些附属样式到新的xxx-product的class中。另外这样做还有一个好处，设计逻辑放在了HTML中，CSS更加强大。</p>\n<p>什么是样式逻辑？商品在瀑布流中不定高，在列表中定高，这就是一种样式的逻辑，如果用父子选择器的形式写在CSS中，那它就失去了自由。而放在HTML通过选择添加何种附属class来展现不同形式的product，则非常的自由与灵活。另外值得一说的是，margin-bottom是一样的，但我们应该各自放在各自的class里面，原因很简单，它们仅仅是一不小心恰好一样，在设计逻辑中它们并不是一样的bottom，这里并不是重复，而是看起来一样。如果以后需要改变其中的一个bottom，共用则显得非常别扭。</p>\n<p><em><strong>2. 分离皮肤与结构</strong></em></p>\n<p>第二点很容易理解，皮肤（theme）就是视觉效果，即使被剔除网页也没有什么影响的就是皮肤；而结构指地并不是像HTML这样抽象的结构，因为CSS毕竟还是样式，所以结构只是相对的页面结构。</p>\n<p>先来看看我们的product吧，添加一些背景色和边框：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.product &#123;</span><br><span class=\"line\">\twidth: 200px;</span><br><span class=\"line\">\tbackground: #F6F2F2;</span><br><span class=\"line\">\tborder: 1px solid #C4A0A0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看起来还不错，不过设计师都是自大狂，精心的调色，完美的搭配，绝对不会让你仅仅使用这么一次的，页面的其他模块、sidebar甚至是header都可能采用相同的背景颜色与边框，它们甚至可能互相嵌套。好吧，这其实在设计上是为了视觉统一，毕竟没有几个设计大师能hold住3，4种以上的颜色。所以我们能做的并不是在每个class中添加这样的样式，而是把它提出来成为独立的class，原因就像我开篇说的那样，颜色为混沌之源。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.main-bg &#123;</span><br><span class=\"line\">\tbackground: #F6F2F2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.main-border &#123;</span><br><span class=\"line\">\tborder: 1px solid #C4A0A0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样就可以在页面中随时使用主要的设计元素了，而且需要修改时也非常的简单，不用担心有什么地方漏掉。另外我将背景与边框分为了两个class，原因还是设计逻辑应该放在HTML，背景与边框并不是一定同时出现的，两者的关系应该由HTML决定，即使设计上逻辑决定了两者的绑定，在实现时也有可能因为HTML结构而放在两个不同的元素上。</p>\n<p>OOCSS强调class，将每组样式写成一个class方便HTML中使用，众多class组合起来能千变万化组成一个对象。所以如果是想一劳永逸的写一套UI作为开发时使用的样式，我建议使用OOCSS来进行开发。但它也有缺点，过多的将设计逻辑放在HTML中，极大的自由化了页面开发时的选择，如果写HTML的开发者不能很好的理解整套CSS的结构，较易在HTML中造成class混乱。</p>\n<h4 id=\"DRY-CSS\"><a href=\"#DRY-CSS\" class=\"headerlink\" title=\"DRY CSS\"></a>DRY CSS</h4><p>DRY就是Donot repeat youself 不要重复。但其实这个名字有点无趣，哪个理论不是消除重复呢，但如何消除才是意义所在。总的来说我认为DRYCSS与OOCSS是两个极端，所以我将会以对比的方式来讲讲DRYCSS的内容。使用DRYCSS很简单，三步。</p>\n<p><em><strong>1. 分组可复用属性</strong></em></p>\n<p>DRYCSS跟OOCSS有点像，第一步都是分组样式，消除重复，但就像我说的，关键在于如何。OOCSS将样式集合看作对象，所以分组的逻辑是，某个元素本身应该是什么样的，而DRYCSS则关注重复，无论什么逻辑，只要是一样的就应该只有一个。其中粒度是值得思考的问题，如果太细，那只会成为一行样式一组这样无意义的情况，如果太粗，又会变成毫无复用性的庞然大物。我认为可以将一些有关联的缺了A时B就没作用的样式分为一组，还可以将某些惯用搭配分为一组。下面举个例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\tfloat: left;</span><br><span class=\"line\">\tposition: absolute;</span><br><span class=\"line\">\tdisplay: inline-block;</span><br><span class=\"line\">\toverflow: hidden;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这是一组样式，可用来触发<a href=\"http://kayosite.com/block-formatting-contexts-in-detail.html\">Block formatting Contexts（块级格式化上下文）</a>，如此就完成了一组样式。接着再写2组关于尺寸的样式吧。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\twidth: 960px;</span><br><span class=\"line\">\theight: auto;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\twidth: 720px;</span><br><span class=\"line\">\theight: 600px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\twidth: 220px;</span><br><span class=\"line\">\theight: 600px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是三组样式用来布局，将页面分为左右两部分。</p>\n<p><em><strong>2. 按逻辑为分组命名</strong></em></p>\n<p>接着我们来为其命名，其实就是添加一个ID选择器，但是我们并不真的使用它，而是用来标示该组样式。下面就来命名上面所分组的样式。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#BLOCK_FORMATTING_CONTEXTS</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tfloat: left;</span><br><span class=\"line\">\tposition: absolute;</span><br><span class=\"line\">\tdisplay: inline-block;</span><br><span class=\"line\">\toverflow: hidden;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">#LAYOUT_FULL</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\twidth: 960px;</span><br><span class=\"line\">\theight: auto;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">#LAYOUT_CONTENT</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\twidth: 720px;</span><br><span class=\"line\">\theight: 600px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">#LAYOUT_SIDEBAR</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\twidth: 220px;</span><br><span class=\"line\">\theight: 600px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这一步类似OOCSS的class，它决定了每组样式所代表的逻辑或用途，然而DRYCSS多了最关键的下一步，也是与OOCSS本质区别。</p>\n<p><em><strong>3. 为各个分组添加选择器</strong></em></p>\n<p>DRYCSS在使用时和OOCSS有着巨大的差异，在CSS文件中写入HTML中的class选择器来使用这些分组后的样式，而不是直接在HTML中使用CSS文件中写好的class。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.header,</span><br><span class=\"line\">.container,</span><br><span class=\"line\">.content-right,</span><br><span class=\"line\">.content-left,</span><br><span class=\"line\">#BLOCK_FORMATTING_CONTEXTS</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tfloat: left;</span><br><span class=\"line\">\tposition: absolute;</span><br><span class=\"line\">\tdisplay: inline-block;</span><br><span class=\"line\">\toverflow: hidden;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.header,</span><br><span class=\"line\">.navigator,</span><br><span class=\"line\">.container,</span><br><span class=\"line\">#LAYOUT_FULL</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\twidth: 960px;</span><br><span class=\"line\">\theight: auto;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">.content-right,</span><br><span class=\"line\">.section,</span><br><span class=\"line\">#LAYOUT_CONTENT</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\twidth: 720px;</span><br><span class=\"line\">\theight: 600px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.content-right,</span><br><span class=\"line\">.sidebar,</span><br><span class=\"line\">.profile,</span><br><span class=\"line\">#LAYOUT_SIDEBAR</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\twidth: 220px;</span><br><span class=\"line\">\theight: 600px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，使用DRYCSS时，在HTML中所写的class将会非常表意，元素本身是什么用来做什么，就使用其意义的class命名，而且基本上是一个元素对应一个class，HTML将变的简单明了。另外DRYCSS也是相对于OOCSS的一种逆向思维，这才是最有趣的地方。在开发中，不应该像OOCSS那样思考如何应对未来假象的HTML，而是仅仅思考CSS本身。</p>\n<p>总的来说，OOCSS适合开发CSS框架或整套UI模版，是自外向内的UI开发方式；而DRYCSS则适合拯救混沌的HTML，或者加强HTML的结构性和表意性，是自内向外的UI开发方式。这里的内指地是HTML结构，外指地是CSS样式。</p>\n<h4 id=\"SMACSS\"><a href=\"#SMACSS\" class=\"headerlink\" title=\"SMACSS\"></a>SMACSS</h4><p>这是一个相对繁杂的CSS理论，分为Base、Layout、Module、Status和Theme共五个部分。不过它的核心思想仍然和OOCSS类似，鼓励使用class。</p>\n<p><em><strong>1. Base 基本属性</strong></em></p>\n<p>基础属性很容易理解，就是最基本的东西，很多样式简单的网站都采用一个简单的二级CSS文件模式，一个base.css通用于所有页面，而每个页面有一个特定的CSS文件，我想这就是Base的雏形。要说具体是什么，比如reset文件，再比如放置clearfix或BFC的一些类似工具集的文件。</p>\n<p>其实最终会发现，在Base中的CSS属性将会是几乎全站都要用到的属性，但我不想这么描述Base，因为这会误导人。大多数情况下，在一个网站建立之初也只会有几个简单的页面，于是这几个页面都要用到的属性就变成了通用属性，但并不是这么简单的。随着网站规模的扩大，需求的增加，设计师们灵感的迸发，所谓的通用和统一也在发生着潜移默化。所以在编写Base时，应该遵循的基准是，哪些样式是你做下一个网站时也会想用的，哪些样式即使设计改变了也只需要改变一些数值和颜色，哪些样式是一些基本原则；而不应该将目前大部分页面都在使用的样式放在Base中，还是那个道理，它们也许仅仅是恰好相同，而非逻辑一致。</p>\n<p><em><strong>2. Layout 布局</strong></em></p>\n<p>布局是一个网站的基本，无论是左右还是居中，甚至其他什么布局，要实现页面的基本浏览功能，布局必不可少。SMACSS将这一功能单独提出也是非常正确的，另外还约定了一个前缀<code>l-/layout-</code>来标识布局的class。举个最普遍的例子。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.l-header &#123;&#125;</span><br><span class=\"line\">\t.l-brand &#123;&#125;</span><br><span class=\"line\">\t.l-navigator &#123;&#125;</span><br><span class=\"line\">.l-container &#123;&#125;</span><br><span class=\"line\">\t.l-sidebar &#123;&#125;</span><br><span class=\"line\">\t.l-content &#123;&#125;</span><br><span class=\"line\">.l-footer &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这就是一个简单的左右布局，导航和Logo中规中矩在最顶部。</p>\n<p><em><strong>3. Module 模块</strong></em></p>\n<p>模块是SMACSS最基本的思想，同时也是大部分CSS理论的基本，将样式模块化就能达到复用和可维护的目的，但是SMACSS提出了更具体的模块化方案。首先表象上来看，SMACSS中的模块应该拥有一个名字，并且为其class名，而模块其他class皆以为前缀。比如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.product &#123;&#125;</span><br><span class=\"line\">\t.product-title &#123;&#125;</span><br><span class=\"line\">\t.product-image &#123;&#125;</span><br><span class=\"line\">\t.product-border &#123;&#125;</span><br><span class=\"line\">\t.product-shadow &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到例子中product是一个模块，title和image是包含在模块内的组件，可用可不用；border和shadow是类似OOCSS的附加class用来改变模块本身。总之，在模块内可以使用其名称做前缀任意组织模块结构，但目前是让其变得更易用，提高可扩展性和灵活度，如果仅仅为了某些功能而特意写一些class就有点有形无实的感觉了。</p>\n<p><em><strong>4. State 状态</strong></em></p>\n<p>状态经常和JavaScript放在一起使用，它是一种用来标识页面状态的class，无论是为用户标识还是用程序标识。还是一个常见的例子，马上就明白。active经常用来表示当前的tab，或者当前选中的目标，这就是一种状态，无论是样式还是程序都需要知道它。</p>\n<p>SMACSS仍然有一个对应的前缀用于标示状态class，<code>is-</code>是一个合适的词，指明某一元素是什么状态。</p>\n<p><em><strong>5. Theme 主题</strong></em></p>\n<p>主题就是皮肤，和OOCSS的分离皮肤与结构不谋而合。更重要的是对于可更换皮肤的站点来说，这样的分离是非常必要的，只需要更换加载的theme文件即可将皮肤更换。</p>\n<p>总的来说，SMACSS是一个较为注意细节与实现的CSS理论，非常适合初涉CSS的人，它可以让你的CSS跑在轨道上而不至于脱轨。其思想也与OOCSS有很多相通之处，如果没有适合的方案，我建议新手可以适当的融入OOCSS的思想而使用SMACSS的结构，这样写出来的网站样式至少不会马上陷入泥沼。</p>\n<h2 id=\"哪一个好用呢？\"><a href=\"#哪一个好用呢？\" class=\"headerlink\" title=\"哪一个好用呢？\"></a>哪一个好用呢？</h2><p>谈了许多的CSS原理，已经有点眼花缭乱，到底哪个好呢？这个问题又归结到了最佳实践上，虽然我并不认为有这样的实践，但我认为一个项目一定会有适合的实践，比如前面说的，如果你想做一个CSS框架然后再写HTML，那就用OOCSS；如果你想先写HTML或者已经有一个旧的页面，那DRYCSS应该很适合你；如果新手不知如何下手，那SMACSS可以指导你入门。</p>\n<p>无论如何，在我过去很长一段时间的独立UI开发“生涯”中，这些情况我都遇到过，也有一些自己的想法，我想我将在下一篇博客中谈谈自己对CSS的理解，并尝试整理出一些类似理论的东西来。</p>\n","site":{"data":{}},"excerpt":"<p>很久没有写博客了，一是刚入职比较忙，二是因为总有学到新的有趣的东西，停不下脚步来总结一下。最近出差到了帝都，反而能挤出些时间来写点什么了，也正好趁着出差做的这个项目讨论一下CSS理论。</p>\n<p>我现在面对的CSS基本上就是一个三头六臂的怪物，一点不夸张，因为真的是三头六臂，同一个样式在同一个element上作用了好几遍，而同一个样式又分散在4，5个class上，优先级有很多层。可以看得出这个怪物不是一个人造就的，早期的开发者选择了SCSS技术，但混乱的import导致了一些基本的样式被多次调用，而后面的开发者又为了摆脱之前的混乱引入了其他共用样式，但无济于事。原因出在HTML上，CSS依托于HTML没有被正确的抽象，而HTML又完全的依赖业务，所有class以业务取名，HTML和CSS基本没有复用，最终抽出的共用样式也仅仅是又一次的重复。CSS重构最难的地方在于没有脚手架，即测试。虽然有一些方法来测试，比如reftest，但还不够成熟。抱着有总比没好的心态，CSS被一层又一层的覆盖了上去。</p>","more":"<h2 id=\"真正的问题是什么？\"><a href=\"#真正的问题是什么？\" class=\"headerlink\" title=\"真正的问题是什么？\"></a>真正的问题是什么？</h2><p>CSS即层叠样式表，所以一层一层覆盖其实是其本质特征。真正的问题在于维护，许多人认为CSS仅是样式，不是代码，无需维护，所以任意书写，只要将自己需要的样式的优先级设为最高即可，才导致了深层级CSS的出现，因为每次添加一个样式就必须比以前的优先级高才能在页面看到。深层级不仅造成维护性降低，可读性也是一个问题，人不是机器，无法很优雅的按优先级阅读，所以很难确认一个样式用于哪里，其实还存在许多的冗余样式，在任何地方都被覆盖的样式。这样的代码在扩展性上，一开始反而是有优势的，因为添加一个新class，无需担心影响其他地方，但慢慢随着项目规模的增大，页面增多，需要复制样式的地方也越来越多，它们之间又存在微小的差异，设计的更改，需求的变化，这一切都会将这种快餐式的CSS推进柏油坑。因为难以维护，所以无法响应需求，所以无法复用，只能复制，恶性循环。</p>\n<p>正如上面所说的，问题在于可读性、维护性、扩展性、复用性这几个方面。所以只要提高它们就能解决问题, 虽然这么说，也不是如此简单的。先来谈谈在CSS中，这些概念都有着怎样的意义。</p>\n<h4 id=\"可读性\"><a href=\"#可读性\" class=\"headerlink\" title=\"可读性\"></a>可读性</h4><p>有人认为CSS不是程序，不需要可读性，有人认为CSS只要写出来就有可读性，因为很简单。抛开各种预处理器不说，原生CSS结构确实简单，没有需要编程的部分，但仍然可能导致混乱。原因有二，一是CSS可以层叠，其中涉及到了优先级和作用范围，如果写的不好，人很难读出其中的意义，二是CSS属性众多，加上CSS3引入了很多用法独特的属性，一个选择器可能包含几十个属性。比如下面这段我随便写的CSS代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">span &#123;</span><br><span class=\"line\">\t-webkit-box-shadow: 6px 4px 4px red;</span><br><span class=\"line\">\t-moz-box-shadow: 6px 4px 4px red;</span><br><span class=\"line\">\tbox-shadow: 6px 4px 4px red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">div span &#123;</span><br><span class=\"line\">\tborder-width: 4px;</span><br><span class=\"line\">\tborder-style: dotted;</span><br><span class=\"line\">\tborder-color: blue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">#box &#123;</span><br><span class=\"line\">\tborder-left: 2px solid red;</span><br><span class=\"line\">\tborder-bottom: 2px solid red; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>乍一看也没什么，都是border，大致能看出来这段CSS只是为了添加一个红色的阴影让box看起来比较立体。但中间的部分似乎是捣乱的，你可能会说这太傻了，看不到吗。是的，当这3部分散落在上万行的CSS中时，肯定看不到。于是有人很自然的想起了我们可爱的浏览器，没错，在浏览器中可以快速找到作用于目标的CSS样式，但这也是万恶之源。首先我假设你不知道中间那部分东西是为了什么而写的，因为你是靠浏览器找到它的。然后剩下两种可能，不管三七二十一改了再说和看看它为什么存在。前者悲剧的可能性是100%，后者悲剧的可能性是90%，因为你已经掉坑里了，很快我们会发现要修改它还牵扯到了另外的地方，接着在浏览器中探索到另一个莫名其妙的样式，当你弄懂全部的时候，你应该已经把上万行的代码弄了个一清二楚了，也许最幸运的是，浪费了几个小时的时间发现只需要修改一行就能达到目的。</p>\n<p>当然，我们可以天真的认为，只要把他们写在一起就可以了，这样找起来很简单。而我将继续顺着这样的思路来尝试曝露问题。</p>\n<h4 id=\"维护性\"><a href=\"#维护性\" class=\"headerlink\" title=\"维护性\"></a>维护性</h4><p>所谓物以类聚是很有道理的，人们习惯将事物归类，但问题是分类标准，样式并不关心业务，无论是什么文字内容，还是功能有何不同，它在乎的只是样式，比如文字的尺寸，间距和宽高，颜色等等。如果简单的将一个组件的样式放在一起，势必带来的就是小段代码的重复书写。不觉得有多严重？我来举个栗子。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">aside &#123;</span><br><span class=\"line\">\tbox-shadow: 6px 4px 4px #AA3343;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">nav &#123;</span><br><span class=\"line\">\tbox-shadow: 6px 4px 4px #AB3633;\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.item &#123;</span><br><span class=\"line\">\tbox-shadow: 6px 4px 4px #AA3732;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.item.otherStatus &#123;</span><br><span class=\"line\">\tbox-shadow: 6px 4px 4px #AA3132;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>继续说上面的例子，box需要阴影，但如果这个项目的UI统一风格，包括sidebar，navigator以及item都需要这样的阴影呢？再如果，明天客户或者UX一拍脑袋，这个阴影应该是灰色的不该是红色的呢？不要继续天真的认为全局替换是救命稻草。首先，没有几个网站会用red，blur做色调的，你用的应该是#AA3333，这样的代码，然后你发现sidebar用了#A43433，而navigator是#AB3633，等等，item有两个状态，而两个状态对应的颜色是不一样的。这怎么可能？但当你打开浏览器的时候你会发现本来就相差无几的颜色，在阴影中变得一模一样了，谁看的出来呢，当初使用的时候可能也不过是随意的在mockup中取的一个颜色。</p>\n<p>大量的重复带来的不仅仅是代码的冗余，我们必须靠人力去同步它们，而人很难保证它们的修改是完全一致的，尤其是当它们中引入了一些不一致的独特的东西时。不要小看CSS，其后果就是进度和人力的压力，后面就是PM有没有读过《人月神话》的事了。</p>\n<p>肯定有人在想，谁让你当初要写成这样呢。我们在读代码的时候最喜欢问，当初为什么要这么写？但慢慢的你会读出它的历史，有时候它是身不由己的。这就涉及到了下一个要讨论的内容。</p>\n<h4 id=\"扩展性\"><a href=\"#扩展性\" class=\"headerlink\" title=\"扩展性\"></a>扩展性</h4><p>扩展性是一个具有欺骗性的东西，所谓的扩展性其实就是在现有基础上再次开发新东西的性能，但我认为它还必须有前提条件，那就是保持可读性与维护性。</p>\n<p>简单的追求可维护性是自取灭亡，原因很简单，将新旧代码完全分离的时候扩展性最高，因为不必担心对以前的部分有影响，新的样式可以随意发挥。是不是很神奇，这样想的我们写下的代码，肯定就是前面我们追问的代码。所以自己回答自己吧，当初没考虑可读性和维护性，只想着快点增加新的样式，就这么写了。</p>\n<p>那什么才是一个好的扩展性呢，简单来说，就是多功能产品。比如一个box，也许它的样式就时</p>\n<h4 id=\"复用性\"><a href=\"#复用性\" class=\"headerlink\" title=\"复用性\"></a>复用性</h4><p>似乎我一直在说的就是重复，那我们就来说说复用性，如何才能复用CSS代码是一个很大的问题，比如粒度，是一两个属性进行复用还是一大组选择器进行复用呢，再比如对象，是为了class复用属性，还是为了html复用class呢。这些选择不算太重要，但是带来的影响却很重大，可以说是整个CSS结构的改变。下面继续用box的阴影来讨论复用。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.shadow &#123;</span><br><span class=\"line\">\t-webkit-box-shadow: 6px 4px 4px #A93334;</span><br><span class=\"line\">\t-moz-box-shadow: 6px 4px 4px #A93334;</span><br><span class=\"line\">\tbox-shadow: 6px 4px 4px #A93334;</span><br><span class=\"line\">\tborder-left: 2px solid #A93334\\9;</span><br><span class=\"line\">\tborder-bottom: 2px solid #A93334\\9; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样看起来我有了一个shadow的class可以给任意的目标加上这个阴影了，但这导致了一个复用的问题，和上面那段捣乱的CSS样式一样，如果item已有另外2个border了，那这个class是无法去除的。所以复用时不仅要考虑需要什么，还要考虑不需要什么。另外一些必须的属性比如display还有overflow等也是要考虑的，因为user agent的原因，很多属性是隐藏在element中的。</p>\n<h2 id=\"如何解决问题？\"><a href=\"#如何解决问题？\" class=\"headerlink\" title=\"如何解决问题？\"></a>如何解决问题？</h2><p>主流的CSS原则有OOCSS，DRY，SMACSS以及BEM，他们皆是为解决CSS的各种问题而生。</p>\n<h4 id=\"OOCSS\"><a href=\"#OOCSS\" class=\"headerlink\" title=\"OOCSS\"></a>OOCSS</h4><p>OOCSS即面向对象的CSS，这里对象指的是页面中的元素对象，与传统编程中的面向对象不太相同，比如不存在方法这种东西，硬要说的话，附加的一些class可以看作是继承或者接口之类的东西来实现对象的差异化。比如电商网站中的商品就是一个典型的对象，它们既有许多相同的部分，又有许多差异，宽高、按钮、图片、标题等基本布局都是相同的，而边距、线框、背景颜色、字号等都是差异化的。由此按照OOCSS的指导原则，我们应该写一个product class，然后为其添加一些border、theme之类的class来差异化它：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.product &#123;</span><br><span class=\"line\">\tdisplay: block;</span><br><span class=\"line\">\toverflow: hidden;</span><br><span class=\"line\">\tfloat: left;</span><br><span class=\"line\">\twidth: 200px;</span><br><span class=\"line\">\theight: auto;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.product-head&#123;...&#125;</span><br><span class=\"line\">.product-body&#123;...&#125;</span><br><span class=\"line\">.product-foot&#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.product-theme-black &#123;</span><br><span class=\"line\">\tbackground: black;</span><br><span class=\"line\">\tcolor: white;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.product-border &#123;</span><br><span class=\"line\">\tborder: 1px solid #333;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样在以上两种附加class的作用下，我们在html中就可以获得4种不同的product样式，随着附加class增加，product的样式也会呈指数增加，千变万化。这仅仅是一个简单的例子，意在点出OOCSS的理念，但并没有突出它的意义所在。别着急，先来看看OOCSS的两大原则。</p>\n<p><em><strong>1. 分离容器与内容</strong></em></p>\n<p>所谓的容器即包裹对象的元素，比如一个div，我们经常会命名为wrap、container、body等。那么如何才算是分离容器与内容呢？很简单，一句话，内容在哪都可用。也就是说不应该出现这样的情况：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.container .product &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样干的结果就是复用性大大降低，因为只能在这个容器内使用它了。但这并不代表我们应该将所需的样式全部一股脑的扔进单独的class中，对于差异化应该单独放在一个class中，这才是OOCSS的精髓。</p>\n<p>举个例子，当我们既不想牺牲太多性能，又想来个瀑布流显摆显摆的时候，大部分前端都会使用column，类似泳道的设计。你想说哦不，这是伪pinterest，但是谁在乎呢，用户是不会有闲工夫拖拽浏览器的宽度来鉴别它的，在IE下商品多的时候至少不会太卡。哈，别较真，首先分为几个column，然后按照高度往里填放商品，先来看看下面的代码吧，我有省略一些样式避免误导：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.column &#123;</span><br><span class=\"line\">\theight: auto;</span><br><span class=\"line\">\twidth: 200px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.product &#123;</span><br><span class=\"line\">\twidth: 180px;</span><br><span class=\"line\">\tmargin-right: 20px;</span><br><span class=\"line\">\tmargin-bottom: 10px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看起来不错，每列200px宽，商品放入其中，水平间距要大，垂直间距要小些才像column。但是等等，我们总还是需要整齐摆放的商品列表的对不对。也许margin并不是product的必要属性，至少它应该是可变的。我们抽出它来：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.product &#123;</span><br><span class=\"line\">\twidth: 180px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.vertical-product &#123;</span><br><span class=\"line\">\theight: 400px;</span><br><span class=\"line\">\tmargin-right: 10px;</span><br><span class=\"line\">\tmargin-bottom: 10px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.horizontal-product &#123;</span><br><span class=\"line\">\theight: auto;</span><br><span class=\"line\">\tmargin-right: 20px;</span><br><span class=\"line\">\tmargin-bottom: 10px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样便将column或list之类的容器与product分开来毫无关系了，即使以后出现了其他组织形式，只要product的基本结构没有变都可以直接复用，无非是添加一些附属样式到新的xxx-product的class中。另外这样做还有一个好处，设计逻辑放在了HTML中，CSS更加强大。</p>\n<p>什么是样式逻辑？商品在瀑布流中不定高，在列表中定高，这就是一种样式的逻辑，如果用父子选择器的形式写在CSS中，那它就失去了自由。而放在HTML通过选择添加何种附属class来展现不同形式的product，则非常的自由与灵活。另外值得一说的是，margin-bottom是一样的，但我们应该各自放在各自的class里面，原因很简单，它们仅仅是一不小心恰好一样，在设计逻辑中它们并不是一样的bottom，这里并不是重复，而是看起来一样。如果以后需要改变其中的一个bottom，共用则显得非常别扭。</p>\n<p><em><strong>2. 分离皮肤与结构</strong></em></p>\n<p>第二点很容易理解，皮肤（theme）就是视觉效果，即使被剔除网页也没有什么影响的就是皮肤；而结构指地并不是像HTML这样抽象的结构，因为CSS毕竟还是样式，所以结构只是相对的页面结构。</p>\n<p>先来看看我们的product吧，添加一些背景色和边框：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.product &#123;</span><br><span class=\"line\">\twidth: 200px;</span><br><span class=\"line\">\tbackground: #F6F2F2;</span><br><span class=\"line\">\tborder: 1px solid #C4A0A0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看起来还不错，不过设计师都是自大狂，精心的调色，完美的搭配，绝对不会让你仅仅使用这么一次的，页面的其他模块、sidebar甚至是header都可能采用相同的背景颜色与边框，它们甚至可能互相嵌套。好吧，这其实在设计上是为了视觉统一，毕竟没有几个设计大师能hold住3，4种以上的颜色。所以我们能做的并不是在每个class中添加这样的样式，而是把它提出来成为独立的class，原因就像我开篇说的那样，颜色为混沌之源。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.main-bg &#123;</span><br><span class=\"line\">\tbackground: #F6F2F2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.main-border &#123;</span><br><span class=\"line\">\tborder: 1px solid #C4A0A0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样就可以在页面中随时使用主要的设计元素了，而且需要修改时也非常的简单，不用担心有什么地方漏掉。另外我将背景与边框分为了两个class，原因还是设计逻辑应该放在HTML，背景与边框并不是一定同时出现的，两者的关系应该由HTML决定，即使设计上逻辑决定了两者的绑定，在实现时也有可能因为HTML结构而放在两个不同的元素上。</p>\n<p>OOCSS强调class，将每组样式写成一个class方便HTML中使用，众多class组合起来能千变万化组成一个对象。所以如果是想一劳永逸的写一套UI作为开发时使用的样式，我建议使用OOCSS来进行开发。但它也有缺点，过多的将设计逻辑放在HTML中，极大的自由化了页面开发时的选择，如果写HTML的开发者不能很好的理解整套CSS的结构，较易在HTML中造成class混乱。</p>\n<h4 id=\"DRY-CSS\"><a href=\"#DRY-CSS\" class=\"headerlink\" title=\"DRY CSS\"></a>DRY CSS</h4><p>DRY就是Donot repeat youself 不要重复。但其实这个名字有点无趣，哪个理论不是消除重复呢，但如何消除才是意义所在。总的来说我认为DRYCSS与OOCSS是两个极端，所以我将会以对比的方式来讲讲DRYCSS的内容。使用DRYCSS很简单，三步。</p>\n<p><em><strong>1. 分组可复用属性</strong></em></p>\n<p>DRYCSS跟OOCSS有点像，第一步都是分组样式，消除重复，但就像我说的，关键在于如何。OOCSS将样式集合看作对象，所以分组的逻辑是，某个元素本身应该是什么样的，而DRYCSS则关注重复，无论什么逻辑，只要是一样的就应该只有一个。其中粒度是值得思考的问题，如果太细，那只会成为一行样式一组这样无意义的情况，如果太粗，又会变成毫无复用性的庞然大物。我认为可以将一些有关联的缺了A时B就没作用的样式分为一组，还可以将某些惯用搭配分为一组。下面举个例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\tfloat: left;</span><br><span class=\"line\">\tposition: absolute;</span><br><span class=\"line\">\tdisplay: inline-block;</span><br><span class=\"line\">\toverflow: hidden;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这是一组样式，可用来触发<a href=\"http://kayosite.com/block-formatting-contexts-in-detail.html\">Block formatting Contexts（块级格式化上下文）</a>，如此就完成了一组样式。接着再写2组关于尺寸的样式吧。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\twidth: 960px;</span><br><span class=\"line\">\theight: auto;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\twidth: 720px;</span><br><span class=\"line\">\theight: 600px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\twidth: 220px;</span><br><span class=\"line\">\theight: 600px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是三组样式用来布局，将页面分为左右两部分。</p>\n<p><em><strong>2. 按逻辑为分组命名</strong></em></p>\n<p>接着我们来为其命名，其实就是添加一个ID选择器，但是我们并不真的使用它，而是用来标示该组样式。下面就来命名上面所分组的样式。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#BLOCK_FORMATTING_CONTEXTS</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tfloat: left;</span><br><span class=\"line\">\tposition: absolute;</span><br><span class=\"line\">\tdisplay: inline-block;</span><br><span class=\"line\">\toverflow: hidden;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">#LAYOUT_FULL</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\twidth: 960px;</span><br><span class=\"line\">\theight: auto;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">#LAYOUT_CONTENT</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\twidth: 720px;</span><br><span class=\"line\">\theight: 600px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">#LAYOUT_SIDEBAR</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\twidth: 220px;</span><br><span class=\"line\">\theight: 600px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这一步类似OOCSS的class，它决定了每组样式所代表的逻辑或用途，然而DRYCSS多了最关键的下一步，也是与OOCSS本质区别。</p>\n<p><em><strong>3. 为各个分组添加选择器</strong></em></p>\n<p>DRYCSS在使用时和OOCSS有着巨大的差异，在CSS文件中写入HTML中的class选择器来使用这些分组后的样式，而不是直接在HTML中使用CSS文件中写好的class。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.header,</span><br><span class=\"line\">.container,</span><br><span class=\"line\">.content-right,</span><br><span class=\"line\">.content-left,</span><br><span class=\"line\">#BLOCK_FORMATTING_CONTEXTS</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tfloat: left;</span><br><span class=\"line\">\tposition: absolute;</span><br><span class=\"line\">\tdisplay: inline-block;</span><br><span class=\"line\">\toverflow: hidden;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.header,</span><br><span class=\"line\">.navigator,</span><br><span class=\"line\">.container,</span><br><span class=\"line\">#LAYOUT_FULL</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\twidth: 960px;</span><br><span class=\"line\">\theight: auto;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">.content-right,</span><br><span class=\"line\">.section,</span><br><span class=\"line\">#LAYOUT_CONTENT</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\twidth: 720px;</span><br><span class=\"line\">\theight: 600px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.content-right,</span><br><span class=\"line\">.sidebar,</span><br><span class=\"line\">.profile,</span><br><span class=\"line\">#LAYOUT_SIDEBAR</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\twidth: 220px;</span><br><span class=\"line\">\theight: 600px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，使用DRYCSS时，在HTML中所写的class将会非常表意，元素本身是什么用来做什么，就使用其意义的class命名，而且基本上是一个元素对应一个class，HTML将变的简单明了。另外DRYCSS也是相对于OOCSS的一种逆向思维，这才是最有趣的地方。在开发中，不应该像OOCSS那样思考如何应对未来假象的HTML，而是仅仅思考CSS本身。</p>\n<p>总的来说，OOCSS适合开发CSS框架或整套UI模版，是自外向内的UI开发方式；而DRYCSS则适合拯救混沌的HTML，或者加强HTML的结构性和表意性，是自内向外的UI开发方式。这里的内指地是HTML结构，外指地是CSS样式。</p>\n<h4 id=\"SMACSS\"><a href=\"#SMACSS\" class=\"headerlink\" title=\"SMACSS\"></a>SMACSS</h4><p>这是一个相对繁杂的CSS理论，分为Base、Layout、Module、Status和Theme共五个部分。不过它的核心思想仍然和OOCSS类似，鼓励使用class。</p>\n<p><em><strong>1. Base 基本属性</strong></em></p>\n<p>基础属性很容易理解，就是最基本的东西，很多样式简单的网站都采用一个简单的二级CSS文件模式，一个base.css通用于所有页面，而每个页面有一个特定的CSS文件，我想这就是Base的雏形。要说具体是什么，比如reset文件，再比如放置clearfix或BFC的一些类似工具集的文件。</p>\n<p>其实最终会发现，在Base中的CSS属性将会是几乎全站都要用到的属性，但我不想这么描述Base，因为这会误导人。大多数情况下，在一个网站建立之初也只会有几个简单的页面，于是这几个页面都要用到的属性就变成了通用属性，但并不是这么简单的。随着网站规模的扩大，需求的增加，设计师们灵感的迸发，所谓的通用和统一也在发生着潜移默化。所以在编写Base时，应该遵循的基准是，哪些样式是你做下一个网站时也会想用的，哪些样式即使设计改变了也只需要改变一些数值和颜色，哪些样式是一些基本原则；而不应该将目前大部分页面都在使用的样式放在Base中，还是那个道理，它们也许仅仅是恰好相同，而非逻辑一致。</p>\n<p><em><strong>2. Layout 布局</strong></em></p>\n<p>布局是一个网站的基本，无论是左右还是居中，甚至其他什么布局，要实现页面的基本浏览功能，布局必不可少。SMACSS将这一功能单独提出也是非常正确的，另外还约定了一个前缀<code>l-/layout-</code>来标识布局的class。举个最普遍的例子。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.l-header &#123;&#125;</span><br><span class=\"line\">\t.l-brand &#123;&#125;</span><br><span class=\"line\">\t.l-navigator &#123;&#125;</span><br><span class=\"line\">.l-container &#123;&#125;</span><br><span class=\"line\">\t.l-sidebar &#123;&#125;</span><br><span class=\"line\">\t.l-content &#123;&#125;</span><br><span class=\"line\">.l-footer &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这就是一个简单的左右布局，导航和Logo中规中矩在最顶部。</p>\n<p><em><strong>3. Module 模块</strong></em></p>\n<p>模块是SMACSS最基本的思想，同时也是大部分CSS理论的基本，将样式模块化就能达到复用和可维护的目的，但是SMACSS提出了更具体的模块化方案。首先表象上来看，SMACSS中的模块应该拥有一个名字，并且为其class名，而模块其他class皆以为前缀。比如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.product &#123;&#125;</span><br><span class=\"line\">\t.product-title &#123;&#125;</span><br><span class=\"line\">\t.product-image &#123;&#125;</span><br><span class=\"line\">\t.product-border &#123;&#125;</span><br><span class=\"line\">\t.product-shadow &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到例子中product是一个模块，title和image是包含在模块内的组件，可用可不用；border和shadow是类似OOCSS的附加class用来改变模块本身。总之，在模块内可以使用其名称做前缀任意组织模块结构，但目前是让其变得更易用，提高可扩展性和灵活度，如果仅仅为了某些功能而特意写一些class就有点有形无实的感觉了。</p>\n<p><em><strong>4. State 状态</strong></em></p>\n<p>状态经常和JavaScript放在一起使用，它是一种用来标识页面状态的class，无论是为用户标识还是用程序标识。还是一个常见的例子，马上就明白。active经常用来表示当前的tab，或者当前选中的目标，这就是一种状态，无论是样式还是程序都需要知道它。</p>\n<p>SMACSS仍然有一个对应的前缀用于标示状态class，<code>is-</code>是一个合适的词，指明某一元素是什么状态。</p>\n<p><em><strong>5. Theme 主题</strong></em></p>\n<p>主题就是皮肤，和OOCSS的分离皮肤与结构不谋而合。更重要的是对于可更换皮肤的站点来说，这样的分离是非常必要的，只需要更换加载的theme文件即可将皮肤更换。</p>\n<p>总的来说，SMACSS是一个较为注意细节与实现的CSS理论，非常适合初涉CSS的人，它可以让你的CSS跑在轨道上而不至于脱轨。其思想也与OOCSS有很多相通之处，如果没有适合的方案，我建议新手可以适当的融入OOCSS的思想而使用SMACSS的结构，这样写出来的网站样式至少不会马上陷入泥沼。</p>\n<h2 id=\"哪一个好用呢？\"><a href=\"#哪一个好用呢？\" class=\"headerlink\" title=\"哪一个好用呢？\"></a>哪一个好用呢？</h2><p>谈了许多的CSS原理，已经有点眼花缭乱，到底哪个好呢？这个问题又归结到了最佳实践上，虽然我并不认为有这样的实践，但我认为一个项目一定会有适合的实践，比如前面说的，如果你想做一个CSS框架然后再写HTML，那就用OOCSS；如果你想先写HTML或者已经有一个旧的页面，那DRYCSS应该很适合你；如果新手不知如何下手，那SMACSS可以指导你入门。</p>\n<p>无论如何，在我过去很长一段时间的独立UI开发“生涯”中，这些情况我都遇到过，也有一些自己的想法，我想我将在下一篇博客中谈谈自己对CSS的理解，并尝试整理出一些类似理论的东西来。</p>"},{"layout":"post","title":"浅谈AngularJS模板","_content":"\n![AngularJS Template](/images/angular.jpg)\n\n作为最流行的MVVM（Model-View-View-Model）框架之一，相信大部分前端对AngularJS都不会陌生，我也一样久仰大名。不得不说，AngularJS所带来的改变是巨大的，被称为未来浏览器的模式一点也不为过，尤其是思维上的转变。\n\n作为一个常年挥舞着jQuery去指挥无穷无尽的DOM的前端，初次接触AngularJS是有困难的，许多先贤警告我们不要在AngularJS中使用jQuery，不是没有道理的。即使AngularJS中带有jQlite对象，也仅仅是为了弥补一些地方AngularJS的局限性。AngularJS操作UI的方式与jQuery有着极大区别，在深入学习之后，我渐渐的发现了这点。过去使用jQuery的前端就像一个操纵提线木偶的傀儡师，而手握AngularJS的前端简直是不折不扣的魔法师。前端开发者不再需要根据数据去改变DOM，然后填入数据，我们所要做的仅仅是决定数据的表现形式后等待数据的注入。文档流中的元素就像活过来了一样，根据数据表现出了对应的样子。\n\n这一切的核心除了匪夷所思的DOM监听机制，还有就是AngularJS的模板（template）以及其中多不胜数的内置指令（directive）了。因此，我将在本文中谈谈AngularJS的模板以及其思维模式。\n<!-- more -->\n\n### 模板中的内置指令\n\nAngularJS模板和EmberJS的模板相比更为普通一些，仍然是HTML格式的文件。这使得许多人并未真正了解AngularJS的模板，而认为AngularJS只是提供了一堆内置指令并可用于HTML文件。不过就先来说说这些内置指令吧，模板后面再详细讨论。\n\n1. ngIf是个对于模板很重要的指令，它是基本的条件表达，满足条件时则存在，不满足则不存在。通过它可以轻松的让模板基于数据呈现不同结构。另外它会形成独立Scope，这也是其与ngShow/ngHide的区别之一。如果ngIf出现太多可能会导致页面渲染速度降低，此时可以选择ngSwitch来代替它，不过此时最好先一下检查你的逻辑。\n\n\n1. ngRepeat则是另一重要指令，能循环创建DOM。可以说只要数据中有数组等结构，这一指令就必不可少。配合$index等索引变量，ngRepeat可以创造出多种形式的列表。还有ngRepeatStart/ngRepeatEnd可以将2个元素之间的内容循环创建，但我很少使用它们，因为这种混合多种元素的HTML结构不太好。\n\n1. ngClass是样式层面上的主要指令，它的值可以是存放class名的变量，也可以是带有条件的对象。如此可以通过表达式来选择需要的class，以呈现不同的样式。ngHide与ngShow其实就是特殊的ngClass，ng-hide=\"[expression]\"相当于ng-class=\"{'hide': [expression]}\"。\n\n这些基本的指令构成了一套很有效的模板逻辑，我们可以消除掉各种HTML的重复性代码，还能在单个模板中呈现出无数的形式。但我不赞成将大段的HTML做成partial或directive并通过switch或if来选择性呈现，因为模板应该是可复用的组件，而不是带有逻辑的路由。\n\n\n### 真正的页面只有一个\n\nAngularJS的主旨即快速创建单页面应用，所谓单页面就是说真正的页面只有一个，其中变化的只是模板和数据。但许多习惯于传统Web的开发人员往往找不到单页面的感觉，自然而然的将模板当作了以往的HTML页面，然后根据AngularJS的路由一一对应到模板。这是时常发生的情况，即使是在开发的中途也可能转入这个误区，因为模板的逻辑难以划分，还有被控制器牵连进去的，最后只能让每个路由单独使用对应模板。\n\n模板不是页面，不应该和路由有任何逻辑关系，它关心的应该仅仅是数据呈现结构。所谓的数据呈现结构是说数据需要以何种方式呈现，比如列表、统计图、详情或分页等，而不是数据结构。它往往依赖于HTML结构，所以当HTML的结构不够表意时，模板的划分也会跟着变得困难。一个模板就是一个对象，不属于它的东西，无论多麻烦，即使HTML可以放在一起，也一定要排除在外，无论封装成directive还是partial，或者分离出去与之变成平级关系。\n\n模板也不应该关心数据的内容，即使两个路由中显示的数据内容完全不一样，但显示结构一样或类似，模板就应该利用自身的逻辑在注入数据后呈现对应的内容。但值得注意的是，其自身逻辑应该判断数据本身而不是引用控制器的逻辑，也就是说模板要有自身的逻辑，不应该将页面逻辑混合散落在模板和控制器中。那么如何做才好呢，简而言之就是UI逻辑和业务逻辑的分离，模板中应该只存在UI逻辑。我们应该封装模板，像黑盒一样，无论控制器有什么业务逻辑，都不应该干涉UI逻辑。\n\n比如ngIf指令可以使用表达式，我们应该利用数据本身达到逻辑表达，而不是依赖于控制器中依赖于业务逻辑的变量，比如使用data.length > 0而不是hasData。这看起来是一样的，但其实区别很大，前者将具体逻辑放到了模板中，当数据为空时不显示，而后者则把逻辑抛给了控制器。这样就不仅仅是逻辑放置在哪的问题了，这是违背MVVM框架初衷的。因为当data为空后，控制器必须之前在监听data，并将hasData设为false，而这些事应该交由AngularJS在数据绑定时自动完成。所以如果实在分不清什么逻辑是UI逻辑要放在模板中，什么逻辑是业务逻辑该放在控制器中，那就遵循一个原则，能利用Angular性能时就利用，不要做AngularJS已经做过的事。\n\n### Scope属于谁？\n\n其实这是思维方式的转变，所以误入歧途是不可避免的，而其中最多的误解在于Scope。Scope本身是作为在控制器中的模板作用域，实际效果就是Scope上的属性在模板中可以直接使用，无论是在花括号还是Angular的表达式中，比如指令中。但开发人员很容易被其表面所迷惑，将其当作传统后端模板的变量来使用，更有甚者发明了$scope.vm作为ViewModule来使用，但其实Scope本身就应该是ViewModule。其原因还是在于思维，不同于传统后端的模板变量，Scope是依赖注入到控制器的，也就是说Scope不属于控制器，而属于模板。很明显在模板中将不需要Scope这一名称来指明，因为所有变量都是Scope的。\n\nScope属于控制器或模板有区别吗？有而且非常大。当Scope一片空白的来到控制器时，我们自然而然的认定这样一个原先空空的变量肯定是被控制器创造出的，然后在模板中被使用。但我们换个角度想想，如果模板先定义了它需要的Scope的结构，而后控制器仅仅只是按照预先的定义插入对应的数据，Scope的结构是不是明显属于模板。仔细想想其实很好理解，模板和任何控制器组合都是这套Scope结构，而控制器脱离了该模板Scope就变了，而且模板不用的东西，控制器放到Scope中也等于没有。也就是说，往往我们先定义了控制器才开始编辑模板，自然认为Scope是控制器创建好给模板用的，但如果我们先创建模板，控制器其实只能按照模板中规定的结构来填入数据。而这就像是Java中的接口一样，模板定义好接口，然后控制器只要满足这些填入自己的数据，就能在页面上获得需要的东西，而且同样它们都是一对多的关系。也许有人会说，那也存在同样的逻辑和结构却需要不同显示方式的情况。其实，这仅仅是表现形式的改变，数据呈现结构却没有发生本质上的改变，一个列表，无论是列、行还是格子都仍然是一个表格，模板应该用ngRepeat将其呈现，然后就是CSS的事情了。当你遇到无法使用CSS转变呈现方式的时候，首当其冲的应该考虑一下，是否HTML写的不好，不够灵活，没有语义化呢。\n\n当我们完成这样的思维转变，模板将不再依赖于控制器，它也可以完整的自我封装起来。这样做的好处显而易见，HTML的代码将有巨大的精简，重复的代码消失的无影无踪，因为当它们重复时就可以形成一个独立的模板，模板可以套模板，它们还可以互相引用。但要注意循环引用，比如a引用了b而b又引用了a。如此CSS的重构也将变得更加简单，此时考虑使用OOCSS等提高CSS复用性将变得易如反掌。另外如果某个模板具有关联十分紧密的复杂逻辑还可以打包做成指令，这样模板的逻辑将更加的强大。\n\n### 命名转变思维\n\n要做到这样的思维转变其实是很难的，不过有一个小技巧可以借以完成这样的转变，那就是命名。当设计模板Scope结构时，我们可以更多的考虑这样的一个结构中某数据是什么。在控制器中，也许是一组系统管理员的数据，我们可以命名为admins，也许是一组用户数据users，又或者是一组读者数据reader，还可能是采购员buyer。不过等等，一旦使用了这之中的某个命名，模板就会和控制器绑在一起，你无法为其他的数据使用该模板，而恰恰对于设计统一性来说，这些数据又很可能会放在同种结构之中，也许仅仅是颜色或标题的差异。\n\n此时还能做什么，复制一份相同的模板然后选择另外的命名？完全错误，我们应该抽象它们，它们都是一类数据，列表list。就像之前我说的，设计模板时仅仅应该关心其数据表现结构，它就是一个列表，列表的数据内容完全不会影响到结构。无论是users还是buyer，都可以放入一个list模板中。这是非常重要的，一个长期和数据库打交道的后端，惯性思维会将user和users归为一类，并认为admins和users是完全不同的。但是到了UI层面，这些显而易见的规则已经不适用了，users和admins都是list，而admin和user都是object。如果你担心不同数据类型需要的UI表现不一样，那就应该先考虑CSS实现兼容各种形式，其次是考虑嵌入一些不同的模板或指令来实现差异化，而不是直接复制两个模板。\n\n总之，使用AngularJS一定不要过多考虑流程，而要考虑UI本身，我觉得这有点像面向对象的思维方式，UI既对象。利用AngularJS的监听机制让数据驱动模板产生交互。甚至我还经常利用JavaScript中Object的引用类型特性，使一些关联的数据之间也能产生数据与视图之间的关联，这样连通UI与数据和数据与数据之后就不用再管UI了，只需要操作数据即可，UI自然会表现出应有的状态。\n","source":"_posts/2014-07-21-template-of-angularjs.md","raw":"---\nlayout: post\ntitle: 浅谈AngularJS模板\ntags: [javascript, angular, angularjs, template]\ncategory: Tech\n---\n\n![AngularJS Template](/images/angular.jpg)\n\n作为最流行的MVVM（Model-View-View-Model）框架之一，相信大部分前端对AngularJS都不会陌生，我也一样久仰大名。不得不说，AngularJS所带来的改变是巨大的，被称为未来浏览器的模式一点也不为过，尤其是思维上的转变。\n\n作为一个常年挥舞着jQuery去指挥无穷无尽的DOM的前端，初次接触AngularJS是有困难的，许多先贤警告我们不要在AngularJS中使用jQuery，不是没有道理的。即使AngularJS中带有jQlite对象，也仅仅是为了弥补一些地方AngularJS的局限性。AngularJS操作UI的方式与jQuery有着极大区别，在深入学习之后，我渐渐的发现了这点。过去使用jQuery的前端就像一个操纵提线木偶的傀儡师，而手握AngularJS的前端简直是不折不扣的魔法师。前端开发者不再需要根据数据去改变DOM，然后填入数据，我们所要做的仅仅是决定数据的表现形式后等待数据的注入。文档流中的元素就像活过来了一样，根据数据表现出了对应的样子。\n\n这一切的核心除了匪夷所思的DOM监听机制，还有就是AngularJS的模板（template）以及其中多不胜数的内置指令（directive）了。因此，我将在本文中谈谈AngularJS的模板以及其思维模式。\n<!-- more -->\n\n### 模板中的内置指令\n\nAngularJS模板和EmberJS的模板相比更为普通一些，仍然是HTML格式的文件。这使得许多人并未真正了解AngularJS的模板，而认为AngularJS只是提供了一堆内置指令并可用于HTML文件。不过就先来说说这些内置指令吧，模板后面再详细讨论。\n\n1. ngIf是个对于模板很重要的指令，它是基本的条件表达，满足条件时则存在，不满足则不存在。通过它可以轻松的让模板基于数据呈现不同结构。另外它会形成独立Scope，这也是其与ngShow/ngHide的区别之一。如果ngIf出现太多可能会导致页面渲染速度降低，此时可以选择ngSwitch来代替它，不过此时最好先一下检查你的逻辑。\n\n\n1. ngRepeat则是另一重要指令，能循环创建DOM。可以说只要数据中有数组等结构，这一指令就必不可少。配合$index等索引变量，ngRepeat可以创造出多种形式的列表。还有ngRepeatStart/ngRepeatEnd可以将2个元素之间的内容循环创建，但我很少使用它们，因为这种混合多种元素的HTML结构不太好。\n\n1. ngClass是样式层面上的主要指令，它的值可以是存放class名的变量，也可以是带有条件的对象。如此可以通过表达式来选择需要的class，以呈现不同的样式。ngHide与ngShow其实就是特殊的ngClass，ng-hide=\"[expression]\"相当于ng-class=\"{'hide': [expression]}\"。\n\n这些基本的指令构成了一套很有效的模板逻辑，我们可以消除掉各种HTML的重复性代码，还能在单个模板中呈现出无数的形式。但我不赞成将大段的HTML做成partial或directive并通过switch或if来选择性呈现，因为模板应该是可复用的组件，而不是带有逻辑的路由。\n\n\n### 真正的页面只有一个\n\nAngularJS的主旨即快速创建单页面应用，所谓单页面就是说真正的页面只有一个，其中变化的只是模板和数据。但许多习惯于传统Web的开发人员往往找不到单页面的感觉，自然而然的将模板当作了以往的HTML页面，然后根据AngularJS的路由一一对应到模板。这是时常发生的情况，即使是在开发的中途也可能转入这个误区，因为模板的逻辑难以划分，还有被控制器牵连进去的，最后只能让每个路由单独使用对应模板。\n\n模板不是页面，不应该和路由有任何逻辑关系，它关心的应该仅仅是数据呈现结构。所谓的数据呈现结构是说数据需要以何种方式呈现，比如列表、统计图、详情或分页等，而不是数据结构。它往往依赖于HTML结构，所以当HTML的结构不够表意时，模板的划分也会跟着变得困难。一个模板就是一个对象，不属于它的东西，无论多麻烦，即使HTML可以放在一起，也一定要排除在外，无论封装成directive还是partial，或者分离出去与之变成平级关系。\n\n模板也不应该关心数据的内容，即使两个路由中显示的数据内容完全不一样，但显示结构一样或类似，模板就应该利用自身的逻辑在注入数据后呈现对应的内容。但值得注意的是，其自身逻辑应该判断数据本身而不是引用控制器的逻辑，也就是说模板要有自身的逻辑，不应该将页面逻辑混合散落在模板和控制器中。那么如何做才好呢，简而言之就是UI逻辑和业务逻辑的分离，模板中应该只存在UI逻辑。我们应该封装模板，像黑盒一样，无论控制器有什么业务逻辑，都不应该干涉UI逻辑。\n\n比如ngIf指令可以使用表达式，我们应该利用数据本身达到逻辑表达，而不是依赖于控制器中依赖于业务逻辑的变量，比如使用data.length > 0而不是hasData。这看起来是一样的，但其实区别很大，前者将具体逻辑放到了模板中，当数据为空时不显示，而后者则把逻辑抛给了控制器。这样就不仅仅是逻辑放置在哪的问题了，这是违背MVVM框架初衷的。因为当data为空后，控制器必须之前在监听data，并将hasData设为false，而这些事应该交由AngularJS在数据绑定时自动完成。所以如果实在分不清什么逻辑是UI逻辑要放在模板中，什么逻辑是业务逻辑该放在控制器中，那就遵循一个原则，能利用Angular性能时就利用，不要做AngularJS已经做过的事。\n\n### Scope属于谁？\n\n其实这是思维方式的转变，所以误入歧途是不可避免的，而其中最多的误解在于Scope。Scope本身是作为在控制器中的模板作用域，实际效果就是Scope上的属性在模板中可以直接使用，无论是在花括号还是Angular的表达式中，比如指令中。但开发人员很容易被其表面所迷惑，将其当作传统后端模板的变量来使用，更有甚者发明了$scope.vm作为ViewModule来使用，但其实Scope本身就应该是ViewModule。其原因还是在于思维，不同于传统后端的模板变量，Scope是依赖注入到控制器的，也就是说Scope不属于控制器，而属于模板。很明显在模板中将不需要Scope这一名称来指明，因为所有变量都是Scope的。\n\nScope属于控制器或模板有区别吗？有而且非常大。当Scope一片空白的来到控制器时，我们自然而然的认定这样一个原先空空的变量肯定是被控制器创造出的，然后在模板中被使用。但我们换个角度想想，如果模板先定义了它需要的Scope的结构，而后控制器仅仅只是按照预先的定义插入对应的数据，Scope的结构是不是明显属于模板。仔细想想其实很好理解，模板和任何控制器组合都是这套Scope结构，而控制器脱离了该模板Scope就变了，而且模板不用的东西，控制器放到Scope中也等于没有。也就是说，往往我们先定义了控制器才开始编辑模板，自然认为Scope是控制器创建好给模板用的，但如果我们先创建模板，控制器其实只能按照模板中规定的结构来填入数据。而这就像是Java中的接口一样，模板定义好接口，然后控制器只要满足这些填入自己的数据，就能在页面上获得需要的东西，而且同样它们都是一对多的关系。也许有人会说，那也存在同样的逻辑和结构却需要不同显示方式的情况。其实，这仅仅是表现形式的改变，数据呈现结构却没有发生本质上的改变，一个列表，无论是列、行还是格子都仍然是一个表格，模板应该用ngRepeat将其呈现，然后就是CSS的事情了。当你遇到无法使用CSS转变呈现方式的时候，首当其冲的应该考虑一下，是否HTML写的不好，不够灵活，没有语义化呢。\n\n当我们完成这样的思维转变，模板将不再依赖于控制器，它也可以完整的自我封装起来。这样做的好处显而易见，HTML的代码将有巨大的精简，重复的代码消失的无影无踪，因为当它们重复时就可以形成一个独立的模板，模板可以套模板，它们还可以互相引用。但要注意循环引用，比如a引用了b而b又引用了a。如此CSS的重构也将变得更加简单，此时考虑使用OOCSS等提高CSS复用性将变得易如反掌。另外如果某个模板具有关联十分紧密的复杂逻辑还可以打包做成指令，这样模板的逻辑将更加的强大。\n\n### 命名转变思维\n\n要做到这样的思维转变其实是很难的，不过有一个小技巧可以借以完成这样的转变，那就是命名。当设计模板Scope结构时，我们可以更多的考虑这样的一个结构中某数据是什么。在控制器中，也许是一组系统管理员的数据，我们可以命名为admins，也许是一组用户数据users，又或者是一组读者数据reader，还可能是采购员buyer。不过等等，一旦使用了这之中的某个命名，模板就会和控制器绑在一起，你无法为其他的数据使用该模板，而恰恰对于设计统一性来说，这些数据又很可能会放在同种结构之中，也许仅仅是颜色或标题的差异。\n\n此时还能做什么，复制一份相同的模板然后选择另外的命名？完全错误，我们应该抽象它们，它们都是一类数据，列表list。就像之前我说的，设计模板时仅仅应该关心其数据表现结构，它就是一个列表，列表的数据内容完全不会影响到结构。无论是users还是buyer，都可以放入一个list模板中。这是非常重要的，一个长期和数据库打交道的后端，惯性思维会将user和users归为一类，并认为admins和users是完全不同的。但是到了UI层面，这些显而易见的规则已经不适用了，users和admins都是list，而admin和user都是object。如果你担心不同数据类型需要的UI表现不一样，那就应该先考虑CSS实现兼容各种形式，其次是考虑嵌入一些不同的模板或指令来实现差异化，而不是直接复制两个模板。\n\n总之，使用AngularJS一定不要过多考虑流程，而要考虑UI本身，我觉得这有点像面向对象的思维方式，UI既对象。利用AngularJS的监听机制让数据驱动模板产生交互。甚至我还经常利用JavaScript中Object的引用类型特性，使一些关联的数据之间也能产生数据与视图之间的关联，这样连通UI与数据和数据与数据之后就不用再管UI了，只需要操作数据即可，UI自然会表现出应有的状态。\n","slug":"template-of-angularjs","published":1,"date":"2014-07-20T16:00:00.000Z","updated":"2021-11-28T11:59:29.970Z","_id":"ckwj655190010vyjh2sbc3c3n","comments":1,"photos":[],"link":"","content":"<p><img src=\"/images/angular.jpg\" alt=\"AngularJS Template\"></p>\n<p>作为最流行的MVVM（Model-View-View-Model）框架之一，相信大部分前端对AngularJS都不会陌生，我也一样久仰大名。不得不说，AngularJS所带来的改变是巨大的，被称为未来浏览器的模式一点也不为过，尤其是思维上的转变。</p>\n<p>作为一个常年挥舞着jQuery去指挥无穷无尽的DOM的前端，初次接触AngularJS是有困难的，许多先贤警告我们不要在AngularJS中使用jQuery，不是没有道理的。即使AngularJS中带有jQlite对象，也仅仅是为了弥补一些地方AngularJS的局限性。AngularJS操作UI的方式与jQuery有着极大区别，在深入学习之后，我渐渐的发现了这点。过去使用jQuery的前端就像一个操纵提线木偶的傀儡师，而手握AngularJS的前端简直是不折不扣的魔法师。前端开发者不再需要根据数据去改变DOM，然后填入数据，我们所要做的仅仅是决定数据的表现形式后等待数据的注入。文档流中的元素就像活过来了一样，根据数据表现出了对应的样子。</p>\n<p>这一切的核心除了匪夷所思的DOM监听机制，还有就是AngularJS的模板（template）以及其中多不胜数的内置指令（directive）了。因此，我将在本文中谈谈AngularJS的模板以及其思维模式。</p>\n<span id=\"more\"></span>\n\n<h3 id=\"模板中的内置指令\"><a href=\"#模板中的内置指令\" class=\"headerlink\" title=\"模板中的内置指令\"></a>模板中的内置指令</h3><p>AngularJS模板和EmberJS的模板相比更为普通一些，仍然是HTML格式的文件。这使得许多人并未真正了解AngularJS的模板，而认为AngularJS只是提供了一堆内置指令并可用于HTML文件。不过就先来说说这些内置指令吧，模板后面再详细讨论。</p>\n<ol>\n<li>ngIf是个对于模板很重要的指令，它是基本的条件表达，满足条件时则存在，不满足则不存在。通过它可以轻松的让模板基于数据呈现不同结构。另外它会形成独立Scope，这也是其与ngShow/ngHide的区别之一。如果ngIf出现太多可能会导致页面渲染速度降低，此时可以选择ngSwitch来代替它，不过此时最好先一下检查你的逻辑。</li>\n</ol>\n<ol>\n<li><p>ngRepeat则是另一重要指令，能循环创建DOM。可以说只要数据中有数组等结构，这一指令就必不可少。配合$index等索引变量，ngRepeat可以创造出多种形式的列表。还有ngRepeatStart/ngRepeatEnd可以将2个元素之间的内容循环创建，但我很少使用它们，因为这种混合多种元素的HTML结构不太好。</p>\n</li>\n<li><p>ngClass是样式层面上的主要指令，它的值可以是存放class名的变量，也可以是带有条件的对象。如此可以通过表达式来选择需要的class，以呈现不同的样式。ngHide与ngShow其实就是特殊的ngClass，ng-hide=”[expression]”相当于ng-class=”{‘hide’: [expression]}”。</p>\n</li>\n</ol>\n<p>这些基本的指令构成了一套很有效的模板逻辑，我们可以消除掉各种HTML的重复性代码，还能在单个模板中呈现出无数的形式。但我不赞成将大段的HTML做成partial或directive并通过switch或if来选择性呈现，因为模板应该是可复用的组件，而不是带有逻辑的路由。</p>\n<h3 id=\"真正的页面只有一个\"><a href=\"#真正的页面只有一个\" class=\"headerlink\" title=\"真正的页面只有一个\"></a>真正的页面只有一个</h3><p>AngularJS的主旨即快速创建单页面应用，所谓单页面就是说真正的页面只有一个，其中变化的只是模板和数据。但许多习惯于传统Web的开发人员往往找不到单页面的感觉，自然而然的将模板当作了以往的HTML页面，然后根据AngularJS的路由一一对应到模板。这是时常发生的情况，即使是在开发的中途也可能转入这个误区，因为模板的逻辑难以划分，还有被控制器牵连进去的，最后只能让每个路由单独使用对应模板。</p>\n<p>模板不是页面，不应该和路由有任何逻辑关系，它关心的应该仅仅是数据呈现结构。所谓的数据呈现结构是说数据需要以何种方式呈现，比如列表、统计图、详情或分页等，而不是数据结构。它往往依赖于HTML结构，所以当HTML的结构不够表意时，模板的划分也会跟着变得困难。一个模板就是一个对象，不属于它的东西，无论多麻烦，即使HTML可以放在一起，也一定要排除在外，无论封装成directive还是partial，或者分离出去与之变成平级关系。</p>\n<p>模板也不应该关心数据的内容，即使两个路由中显示的数据内容完全不一样，但显示结构一样或类似，模板就应该利用自身的逻辑在注入数据后呈现对应的内容。但值得注意的是，其自身逻辑应该判断数据本身而不是引用控制器的逻辑，也就是说模板要有自身的逻辑，不应该将页面逻辑混合散落在模板和控制器中。那么如何做才好呢，简而言之就是UI逻辑和业务逻辑的分离，模板中应该只存在UI逻辑。我们应该封装模板，像黑盒一样，无论控制器有什么业务逻辑，都不应该干涉UI逻辑。</p>\n<p>比如ngIf指令可以使用表达式，我们应该利用数据本身达到逻辑表达，而不是依赖于控制器中依赖于业务逻辑的变量，比如使用data.length &gt; 0而不是hasData。这看起来是一样的，但其实区别很大，前者将具体逻辑放到了模板中，当数据为空时不显示，而后者则把逻辑抛给了控制器。这样就不仅仅是逻辑放置在哪的问题了，这是违背MVVM框架初衷的。因为当data为空后，控制器必须之前在监听data，并将hasData设为false，而这些事应该交由AngularJS在数据绑定时自动完成。所以如果实在分不清什么逻辑是UI逻辑要放在模板中，什么逻辑是业务逻辑该放在控制器中，那就遵循一个原则，能利用Angular性能时就利用，不要做AngularJS已经做过的事。</p>\n<h3 id=\"Scope属于谁？\"><a href=\"#Scope属于谁？\" class=\"headerlink\" title=\"Scope属于谁？\"></a>Scope属于谁？</h3><p>其实这是思维方式的转变，所以误入歧途是不可避免的，而其中最多的误解在于Scope。Scope本身是作为在控制器中的模板作用域，实际效果就是Scope上的属性在模板中可以直接使用，无论是在花括号还是Angular的表达式中，比如指令中。但开发人员很容易被其表面所迷惑，将其当作传统后端模板的变量来使用，更有甚者发明了$scope.vm作为ViewModule来使用，但其实Scope本身就应该是ViewModule。其原因还是在于思维，不同于传统后端的模板变量，Scope是依赖注入到控制器的，也就是说Scope不属于控制器，而属于模板。很明显在模板中将不需要Scope这一名称来指明，因为所有变量都是Scope的。</p>\n<p>Scope属于控制器或模板有区别吗？有而且非常大。当Scope一片空白的来到控制器时，我们自然而然的认定这样一个原先空空的变量肯定是被控制器创造出的，然后在模板中被使用。但我们换个角度想想，如果模板先定义了它需要的Scope的结构，而后控制器仅仅只是按照预先的定义插入对应的数据，Scope的结构是不是明显属于模板。仔细想想其实很好理解，模板和任何控制器组合都是这套Scope结构，而控制器脱离了该模板Scope就变了，而且模板不用的东西，控制器放到Scope中也等于没有。也就是说，往往我们先定义了控制器才开始编辑模板，自然认为Scope是控制器创建好给模板用的，但如果我们先创建模板，控制器其实只能按照模板中规定的结构来填入数据。而这就像是Java中的接口一样，模板定义好接口，然后控制器只要满足这些填入自己的数据，就能在页面上获得需要的东西，而且同样它们都是一对多的关系。也许有人会说，那也存在同样的逻辑和结构却需要不同显示方式的情况。其实，这仅仅是表现形式的改变，数据呈现结构却没有发生本质上的改变，一个列表，无论是列、行还是格子都仍然是一个表格，模板应该用ngRepeat将其呈现，然后就是CSS的事情了。当你遇到无法使用CSS转变呈现方式的时候，首当其冲的应该考虑一下，是否HTML写的不好，不够灵活，没有语义化呢。</p>\n<p>当我们完成这样的思维转变，模板将不再依赖于控制器，它也可以完整的自我封装起来。这样做的好处显而易见，HTML的代码将有巨大的精简，重复的代码消失的无影无踪，因为当它们重复时就可以形成一个独立的模板，模板可以套模板，它们还可以互相引用。但要注意循环引用，比如a引用了b而b又引用了a。如此CSS的重构也将变得更加简单，此时考虑使用OOCSS等提高CSS复用性将变得易如反掌。另外如果某个模板具有关联十分紧密的复杂逻辑还可以打包做成指令，这样模板的逻辑将更加的强大。</p>\n<h3 id=\"命名转变思维\"><a href=\"#命名转变思维\" class=\"headerlink\" title=\"命名转变思维\"></a>命名转变思维</h3><p>要做到这样的思维转变其实是很难的，不过有一个小技巧可以借以完成这样的转变，那就是命名。当设计模板Scope结构时，我们可以更多的考虑这样的一个结构中某数据是什么。在控制器中，也许是一组系统管理员的数据，我们可以命名为admins，也许是一组用户数据users，又或者是一组读者数据reader，还可能是采购员buyer。不过等等，一旦使用了这之中的某个命名，模板就会和控制器绑在一起，你无法为其他的数据使用该模板，而恰恰对于设计统一性来说，这些数据又很可能会放在同种结构之中，也许仅仅是颜色或标题的差异。</p>\n<p>此时还能做什么，复制一份相同的模板然后选择另外的命名？完全错误，我们应该抽象它们，它们都是一类数据，列表list。就像之前我说的，设计模板时仅仅应该关心其数据表现结构，它就是一个列表，列表的数据内容完全不会影响到结构。无论是users还是buyer，都可以放入一个list模板中。这是非常重要的，一个长期和数据库打交道的后端，惯性思维会将user和users归为一类，并认为admins和users是完全不同的。但是到了UI层面，这些显而易见的规则已经不适用了，users和admins都是list，而admin和user都是object。如果你担心不同数据类型需要的UI表现不一样，那就应该先考虑CSS实现兼容各种形式，其次是考虑嵌入一些不同的模板或指令来实现差异化，而不是直接复制两个模板。</p>\n<p>总之，使用AngularJS一定不要过多考虑流程，而要考虑UI本身，我觉得这有点像面向对象的思维方式，UI既对象。利用AngularJS的监听机制让数据驱动模板产生交互。甚至我还经常利用JavaScript中Object的引用类型特性，使一些关联的数据之间也能产生数据与视图之间的关联，这样连通UI与数据和数据与数据之后就不用再管UI了，只需要操作数据即可，UI自然会表现出应有的状态。</p>\n","site":{"data":{}},"excerpt":"<p><img src=\"/images/angular.jpg\" alt=\"AngularJS Template\"></p>\n<p>作为最流行的MVVM（Model-View-View-Model）框架之一，相信大部分前端对AngularJS都不会陌生，我也一样久仰大名。不得不说，AngularJS所带来的改变是巨大的，被称为未来浏览器的模式一点也不为过，尤其是思维上的转变。</p>\n<p>作为一个常年挥舞着jQuery去指挥无穷无尽的DOM的前端，初次接触AngularJS是有困难的，许多先贤警告我们不要在AngularJS中使用jQuery，不是没有道理的。即使AngularJS中带有jQlite对象，也仅仅是为了弥补一些地方AngularJS的局限性。AngularJS操作UI的方式与jQuery有着极大区别，在深入学习之后，我渐渐的发现了这点。过去使用jQuery的前端就像一个操纵提线木偶的傀儡师，而手握AngularJS的前端简直是不折不扣的魔法师。前端开发者不再需要根据数据去改变DOM，然后填入数据，我们所要做的仅仅是决定数据的表现形式后等待数据的注入。文档流中的元素就像活过来了一样，根据数据表现出了对应的样子。</p>\n<p>这一切的核心除了匪夷所思的DOM监听机制，还有就是AngularJS的模板（template）以及其中多不胜数的内置指令（directive）了。因此，我将在本文中谈谈AngularJS的模板以及其思维模式。</p>","more":"<h3 id=\"模板中的内置指令\"><a href=\"#模板中的内置指令\" class=\"headerlink\" title=\"模板中的内置指令\"></a>模板中的内置指令</h3><p>AngularJS模板和EmberJS的模板相比更为普通一些，仍然是HTML格式的文件。这使得许多人并未真正了解AngularJS的模板，而认为AngularJS只是提供了一堆内置指令并可用于HTML文件。不过就先来说说这些内置指令吧，模板后面再详细讨论。</p>\n<ol>\n<li>ngIf是个对于模板很重要的指令，它是基本的条件表达，满足条件时则存在，不满足则不存在。通过它可以轻松的让模板基于数据呈现不同结构。另外它会形成独立Scope，这也是其与ngShow/ngHide的区别之一。如果ngIf出现太多可能会导致页面渲染速度降低，此时可以选择ngSwitch来代替它，不过此时最好先一下检查你的逻辑。</li>\n</ol>\n<ol>\n<li><p>ngRepeat则是另一重要指令，能循环创建DOM。可以说只要数据中有数组等结构，这一指令就必不可少。配合$index等索引变量，ngRepeat可以创造出多种形式的列表。还有ngRepeatStart/ngRepeatEnd可以将2个元素之间的内容循环创建，但我很少使用它们，因为这种混合多种元素的HTML结构不太好。</p>\n</li>\n<li><p>ngClass是样式层面上的主要指令，它的值可以是存放class名的变量，也可以是带有条件的对象。如此可以通过表达式来选择需要的class，以呈现不同的样式。ngHide与ngShow其实就是特殊的ngClass，ng-hide=”[expression]”相当于ng-class=”{‘hide’: [expression]}”。</p>\n</li>\n</ol>\n<p>这些基本的指令构成了一套很有效的模板逻辑，我们可以消除掉各种HTML的重复性代码，还能在单个模板中呈现出无数的形式。但我不赞成将大段的HTML做成partial或directive并通过switch或if来选择性呈现，因为模板应该是可复用的组件，而不是带有逻辑的路由。</p>\n<h3 id=\"真正的页面只有一个\"><a href=\"#真正的页面只有一个\" class=\"headerlink\" title=\"真正的页面只有一个\"></a>真正的页面只有一个</h3><p>AngularJS的主旨即快速创建单页面应用，所谓单页面就是说真正的页面只有一个，其中变化的只是模板和数据。但许多习惯于传统Web的开发人员往往找不到单页面的感觉，自然而然的将模板当作了以往的HTML页面，然后根据AngularJS的路由一一对应到模板。这是时常发生的情况，即使是在开发的中途也可能转入这个误区，因为模板的逻辑难以划分，还有被控制器牵连进去的，最后只能让每个路由单独使用对应模板。</p>\n<p>模板不是页面，不应该和路由有任何逻辑关系，它关心的应该仅仅是数据呈现结构。所谓的数据呈现结构是说数据需要以何种方式呈现，比如列表、统计图、详情或分页等，而不是数据结构。它往往依赖于HTML结构，所以当HTML的结构不够表意时，模板的划分也会跟着变得困难。一个模板就是一个对象，不属于它的东西，无论多麻烦，即使HTML可以放在一起，也一定要排除在外，无论封装成directive还是partial，或者分离出去与之变成平级关系。</p>\n<p>模板也不应该关心数据的内容，即使两个路由中显示的数据内容完全不一样，但显示结构一样或类似，模板就应该利用自身的逻辑在注入数据后呈现对应的内容。但值得注意的是，其自身逻辑应该判断数据本身而不是引用控制器的逻辑，也就是说模板要有自身的逻辑，不应该将页面逻辑混合散落在模板和控制器中。那么如何做才好呢，简而言之就是UI逻辑和业务逻辑的分离，模板中应该只存在UI逻辑。我们应该封装模板，像黑盒一样，无论控制器有什么业务逻辑，都不应该干涉UI逻辑。</p>\n<p>比如ngIf指令可以使用表达式，我们应该利用数据本身达到逻辑表达，而不是依赖于控制器中依赖于业务逻辑的变量，比如使用data.length &gt; 0而不是hasData。这看起来是一样的，但其实区别很大，前者将具体逻辑放到了模板中，当数据为空时不显示，而后者则把逻辑抛给了控制器。这样就不仅仅是逻辑放置在哪的问题了，这是违背MVVM框架初衷的。因为当data为空后，控制器必须之前在监听data，并将hasData设为false，而这些事应该交由AngularJS在数据绑定时自动完成。所以如果实在分不清什么逻辑是UI逻辑要放在模板中，什么逻辑是业务逻辑该放在控制器中，那就遵循一个原则，能利用Angular性能时就利用，不要做AngularJS已经做过的事。</p>\n<h3 id=\"Scope属于谁？\"><a href=\"#Scope属于谁？\" class=\"headerlink\" title=\"Scope属于谁？\"></a>Scope属于谁？</h3><p>其实这是思维方式的转变，所以误入歧途是不可避免的，而其中最多的误解在于Scope。Scope本身是作为在控制器中的模板作用域，实际效果就是Scope上的属性在模板中可以直接使用，无论是在花括号还是Angular的表达式中，比如指令中。但开发人员很容易被其表面所迷惑，将其当作传统后端模板的变量来使用，更有甚者发明了$scope.vm作为ViewModule来使用，但其实Scope本身就应该是ViewModule。其原因还是在于思维，不同于传统后端的模板变量，Scope是依赖注入到控制器的，也就是说Scope不属于控制器，而属于模板。很明显在模板中将不需要Scope这一名称来指明，因为所有变量都是Scope的。</p>\n<p>Scope属于控制器或模板有区别吗？有而且非常大。当Scope一片空白的来到控制器时，我们自然而然的认定这样一个原先空空的变量肯定是被控制器创造出的，然后在模板中被使用。但我们换个角度想想，如果模板先定义了它需要的Scope的结构，而后控制器仅仅只是按照预先的定义插入对应的数据，Scope的结构是不是明显属于模板。仔细想想其实很好理解，模板和任何控制器组合都是这套Scope结构，而控制器脱离了该模板Scope就变了，而且模板不用的东西，控制器放到Scope中也等于没有。也就是说，往往我们先定义了控制器才开始编辑模板，自然认为Scope是控制器创建好给模板用的，但如果我们先创建模板，控制器其实只能按照模板中规定的结构来填入数据。而这就像是Java中的接口一样，模板定义好接口，然后控制器只要满足这些填入自己的数据，就能在页面上获得需要的东西，而且同样它们都是一对多的关系。也许有人会说，那也存在同样的逻辑和结构却需要不同显示方式的情况。其实，这仅仅是表现形式的改变，数据呈现结构却没有发生本质上的改变，一个列表，无论是列、行还是格子都仍然是一个表格，模板应该用ngRepeat将其呈现，然后就是CSS的事情了。当你遇到无法使用CSS转变呈现方式的时候，首当其冲的应该考虑一下，是否HTML写的不好，不够灵活，没有语义化呢。</p>\n<p>当我们完成这样的思维转变，模板将不再依赖于控制器，它也可以完整的自我封装起来。这样做的好处显而易见，HTML的代码将有巨大的精简，重复的代码消失的无影无踪，因为当它们重复时就可以形成一个独立的模板，模板可以套模板，它们还可以互相引用。但要注意循环引用，比如a引用了b而b又引用了a。如此CSS的重构也将变得更加简单，此时考虑使用OOCSS等提高CSS复用性将变得易如反掌。另外如果某个模板具有关联十分紧密的复杂逻辑还可以打包做成指令，这样模板的逻辑将更加的强大。</p>\n<h3 id=\"命名转变思维\"><a href=\"#命名转变思维\" class=\"headerlink\" title=\"命名转变思维\"></a>命名转变思维</h3><p>要做到这样的思维转变其实是很难的，不过有一个小技巧可以借以完成这样的转变，那就是命名。当设计模板Scope结构时，我们可以更多的考虑这样的一个结构中某数据是什么。在控制器中，也许是一组系统管理员的数据，我们可以命名为admins，也许是一组用户数据users，又或者是一组读者数据reader，还可能是采购员buyer。不过等等，一旦使用了这之中的某个命名，模板就会和控制器绑在一起，你无法为其他的数据使用该模板，而恰恰对于设计统一性来说，这些数据又很可能会放在同种结构之中，也许仅仅是颜色或标题的差异。</p>\n<p>此时还能做什么，复制一份相同的模板然后选择另外的命名？完全错误，我们应该抽象它们，它们都是一类数据，列表list。就像之前我说的，设计模板时仅仅应该关心其数据表现结构，它就是一个列表，列表的数据内容完全不会影响到结构。无论是users还是buyer，都可以放入一个list模板中。这是非常重要的，一个长期和数据库打交道的后端，惯性思维会将user和users归为一类，并认为admins和users是完全不同的。但是到了UI层面，这些显而易见的规则已经不适用了，users和admins都是list，而admin和user都是object。如果你担心不同数据类型需要的UI表现不一样，那就应该先考虑CSS实现兼容各种形式，其次是考虑嵌入一些不同的模板或指令来实现差异化，而不是直接复制两个模板。</p>\n<p>总之，使用AngularJS一定不要过多考虑流程，而要考虑UI本身，我觉得这有点像面向对象的思维方式，UI既对象。利用AngularJS的监听机制让数据驱动模板产生交互。甚至我还经常利用JavaScript中Object的引用类型特性，使一些关联的数据之间也能产生数据与视图之间的关联，这样连通UI与数据和数据与数据之后就不用再管UI了，只需要操作数据即可，UI自然会表现出应有的状态。</p>"},{"layout":"post","title":"CSS语义思维","_content":"\n![Linguistic](/images/linguistic.png)\n\n前一阵子在项目组中讲了一个关于CSS的Session，在讲之前我曾收到了许多意见，大部分是希望能讲讲CSS实用性的技术，比如盒模型，CSS3之类的。干货人人都喜欢，因为看得见摸得着，拿来就有用，但我最后还是决定讲一些”湿货“。因为在Code Diff的时候我发现了许多样式的问题不是由于不会写CSS导致的，而是由于在错误的地方使用了写在错误地方的样式。\n\n其实CSS很简单，没有计算没有流程，只是一直描述，无论什么复杂的效果，你只要Google一下就知道怎么写了，甚至可以直接copy。但CSS又很复杂，一个元素的表现会受到它旁边的兄弟元素，也会受到内部的子元素影响，还会受到父元素影响，在这种多重影响下，一个元素的显示逻辑会变得错综复杂。有没有面对塌陷的块级元素而束手无策？无论怎么改它的属性就是得不到自己想要的，但看看似乎一模一样的示例程序却安然无恙，是不是恨得咬牙切齿？我想这就是本文所要解决的主要问题，让你学会如何优雅的写CSS。\n\n<!-- more -->\n\n### 泾渭分明 - 明确书写意图和表现语义\n\n其实我们只要稍微接触过CSS，一定都学过盒模型，我假设你已经对margin、padding和border已经很熟悉。好了，我们经常会遇到一种情况，想让父元素和子元素之间有一些空间，比如布局的时候，container和content之间的留白。一般来说有两种方式，一种是给父元素加padding内边距，另一种是给子元素加margin外边距。现在想想，你是否慎重考虑过用哪一种方式？你是否明白两者的区别？如果你从未考虑过这些，现在考虑也不迟，这真的很重要，如果你真的想优雅的运用CSS，而不是被它耍的团团转，如果你真的想把CSS写出规模，那你就要认真的思考这里面的逻辑。\n\n先说说父元素的container加上padding的方式，子元素的背景将不会延伸到空白区域，另一种给子元素加margin的方式则反之。但我想先抛下这个表象，看看此时加上padding的父元素的逻辑。它意味着，我创建了一个容器，并且该容器的内部有一些区域是被看不见的东西填充的，无论放入什么都不应该占据这个区域。在你的脑海中想象一个厚厚的玻璃瓶，它就好像是在说“虽然我是透明的，但是在这厚厚的玻璃之内才是你应该呆的地方，无论是什么只要你想放在瓶子里”。现在来看看子元素，是的，其背景也应该并且确实在内部，而不该占据那段空白的区域。如果是为子元素加上margin，这意味着我在容器中创建了某个东西，而这个东西有一个自己的地盘，容器内的其他东西都不能进入这里。\n\n所以他们的本质区别在于其所表达的意义，也就是语义，一个是容器上的语义，另一个是容器内元素的语义，主语也不同，谓语意义也不同。那么这能说明什么呢，不得不提一下高级语言中的高级，这代表某个语言将机器语言封装的更好，接口更接近自然语言，其强大不言而喻。其实编程语言的发展轨迹就是不断把机器语言往自然语言翻译，让人们可以更容易的跟机器沟通，终极目标自然是人工智能，和机器用自然语言自由沟通。所以虽然代码或者说CSS的语法并没有什么变化，但我们应该在思维上清楚的区分代码片段的意图和语义来写CSS。\n\n语言学家乔姆斯基曾构造过一句符合语法的话:\n\n>“Colorless green ideas sleep furiously”\n\n意思是无色的绿色想法愤怒的睡觉。想法睡觉是违反常识的，无色的绿色是矛盾的，愤怒的睡觉是不合常理的。仅仅符合语法是不够的，仅仅不报错也是不够的，尤其是CSS这种描述性的语言很少会报错，所以我想说的是，其描述性质让我们有更多选择来实现我们所期望的效果，但我们却应该慎重，要让语义分明，而不是在有限的语法规则下任意妄为，那样写不出好的CSS代码。除了其本身的语法规则，我们必须自我约束，引入语义规则，不仅仅是为了提高可读性这样的理由，而是拉近人与机器的距离，让我们在思维上更加和代码契合，这样才能写出优秀的程序。\n\n言归正传，究竟如何语义化CSS呢。之前有讲过OOCSS，其实面向对象的思想就是一种语义化，将虚拟的元素看作实际的对象，用常识来构造代码，就像是用户体验中的用户习惯一样，这是一种遍及全人类的用户习惯，让代码更友好，即所谓的优雅。\n\n比如最常见的布局，我们一般都会有header、body和footer，这样无需任何说明和规则，谁都会理解，header在前，footer在后，中间是body。有趣的是table中的thead、tbody和tfoot，由于加载优化，我们即使把tfoot放在tbody前面，让其先加载，但显示的时候tfoot仍然会在tbody下面，由此可见语义化的重要，否则你一定会以为不是W3C的人弄错了标准，就是浏览器厂商搞出了Bug。虽然这是HTML标签不是CSS，但我觉得这个例子很恰当的说明了一点，显示逻辑是独立的，不应该和其他逻辑混为一谈，它应该只关心如何显示。\n\n再比如，一个导航条一般分为左右两边，里面各有若干链接。你会如何命名？navbar-left和navbar-right是Bootstrap所使用的class，但当宽度减少，Responsive响应式的Bootstrap会让这些链接都收进下拉菜单中，左和右又从何谈起呢？同样是Bootstrap中的颜色命名就做的十分成熟，不是green、blue、red这些词汇，而是success、primary、warning这些词，它们的区别是表现化与语义化的区别，我喜欢把这个叫做`显示逻辑`。也就是说在class层面我们应该只关注元素（或者说对象）是用来做什么的（意图）以及它应该表示什么（语义）。这里三种颜色代表成功、重要和警告，至于我们是用绿、蓝和红来表示还是通过其他什么颜色甚至形状，应该在style层面写CSS属性表示。如此我们使用class时无需迷茫于表示成功应该用绿色还是红色，意图明确无误。回到导航栏的例子，我们应该使用main和sub之类的词语标识导航栏中重要的和次要的链接，即使在某些实现下，主要和次要没有区别也不用担心，那是该实现的显示逻辑，我们不应该横加干涉。\n\n### 狡兔三窟 - 善用class与style多对多的复杂关系\n\n说到class和style（样式属性），这又是一段混乱不清的关系。其实每当我们要实现一个样式，自觉或不自觉的都会考虑，是将元素和class一一对应，然后为元素上的class写style，还是用class和几条style对应之后在元素上搭配组合。前者的好处是每个class中的style不会影响其他class，但可用性十分的低，极端点说这已经不算是在编程了，而是在画页面；后者的好处可以灵活使用不同的样式搭配给元素使用，组合出元素需要的效果，但很难维护，牵一发动全身，样式很难测试，无法保证在你动了一条style之后，没有影响其他的地方。甚至最要命的是大部分CSS代码都是无意识的游走在这两种情况之间，所以我们要做的不是选择一种极端，而是找到一个平衡点，并使用一些方法使得我们的CSS既能灵活复用在各种元素上，又能易于维护，不致修了这破坏那的情况。\n\n###### 分组\n\n首先，对于一个或一套元素的样式，我们应该有自己的创建原则，而不是想到哪写到哪。比如，我一般使用这样的步骤来创建元素：\n\n1. 结构\n    \n首先仅关注结构布局，以站点整体为基准，将元素抽象为一个或多个结构。\n\n比如制作一个按钮，你也许会发现它的尺寸和导航上的链接一致，而内外边距以及display和overflow之类的属性又和页面容器一样，这时你就可以把按钮的结构拆成两个结构，一个是尺寸，一个是边界逻辑，这种情况时常发生，所以有的CSS理论认为应该把width和height这对尺寸属性和padding以及margin这对边距属性彻底的分开也是这个道理。其实并不是说它们4个放一起就决定不行，只是一般它们都有各自复用的价值，所以常常被拆开使用，归根揭底这是由显示逻辑决定的。\n\n1. 皮肤\n\n一般由于设计统一性，我们可以借助设计指导，轻松的制作出标准皮肤。但要注意的是，皮肤指的不仅仅甚至不一定是颜色之类的。继续用Bootstrap举例，有5种基础颜色，但这并不是皮肤，5种颜色的语义不同，它们只是默认用了5种颜色，勉强可以看作默认皮肤，而真正的皮肤是theme，让按钮变得有立体感。还有一个误区就是认为哪几种属性是皮肤，哪几种不是。就像前面所说的，我们要在语义上进行划分。一个属性在某些意图下可能是结构，在另外的意图中可能是皮肤。![Logo](https://raw.githubusercontent.com/UIWorkshop/onlyjs/master/source/Logo.jpg)举个极端的例子，在一个Workshop中我用CSS和HTML制作了左边这样的Logo，Logo本身应该完全算是皮肤，因为一般来说就是一张图片，所以制作它的所有CSS属性都应该算作皮肤。下面的CSS代码中，无论是定位还是文字的处理，以及尺寸等，都是为了构造Logo，所以这些属性都是皮肤。\n\n```css\n#logo i, #logo b {\n  position: relative;\n}\n#logo i {\n  left: -30px;\n  transform: rotate(-30deg);\n  font-size: 60px;\n  letter-spacing: -11px;\n  opacity: 0.3;\n}\n#logo b {\n  top: -43px;\n  left: 40px;\n  font-size: 68px;\n  word-break: break-all;\n  width: 3px;\n  line-height: 10px;\n  text-indent: 6px;\n}\n```\n\n1. 状态\n\n除了结构和皮肤，其实还有一类很容易被人忽视的样式，即使是设计人员也经常忘了它，那就是状态。最常见的是hover，鼠标触碰元素与否的状态，以及active，当前选中的标签，当前所在的分页等等。通常人们会把它划分到皮肤中，但你要明白我们划分的依据是意图，很显然，状态不是皮肤，仅仅是通常为表达某些状态时会使用一些颜色，毕竟颜色是最好的表示方法。它还与各种逻辑有着千丝万缕的联系，经常会使用JavaScript来加以控制，所以将状态单独分出来是极有必要的，JavaScript只需要更改一个class就可以实现状态的切换，而不是在执行的时候才想起来应该把哪里隐藏把哪里显示，或者是变个颜色出个动画之类的。\n\n###### 使用\n\n接着，无论我们是已经把各种写好的CSS属性分好了组，还是正准备以这种方式开始写CSS，我先引入一个语言学的术语 `语块（Lexical chunk）`，创造这一术语的 Michael Lewis 认为语言并非由传统语法和词汇组成，而是由多个词汇的预制语块组成。我们现在分好的组其实就是一个个CSS的语块，CSS本身就是这种预制功能，我们要做的就是把style语块化，然后在HTML中写上代表它的class名称，当HTML元素上的多个class组合在一起时就组成完整的语义。\n\n比如表示步骤的元素，这是一个形状类似标签，一个挨一个的排列的元素。我将它的尺寸等属性抽出来命名为label，然后把布局的属性组命名为float-left，如果我的设计风格是扁平化的，我可以把相关的皮肤属性命名为flat，你知道虽然扁平化一般用不着特别的属性，但我也可以写一些强制去掉圆角和渐变背景的属性。作为步骤，会分为当前的步骤，之前的步骤，以及还没到的步骤，当前的步骤可以命名为current，或者is—active，后面的步骤不能点所以可以命名为is-disable，这些都是状态。而现在我们来看看当前步骤元素是什么样的\n\n```\n    <div class=\"flat label float-left is-active\"></div>\n```\n\n总结成一句话就是“The flat label which float left is active”。这就是语义化的CSS。把组织好的语块像说话一样作用于元素上，对元素发出指令，让其变成想要的样式。而且你应该会发现，一组该元素所独有的属性，或者是尺寸之类的一般是主语，布局是动宾短语，而皮肤多是一些形容词，最后状态可以用表语。\n\n总之，CSS作为一个描述性的语言，有很多人觉得不能算一种语言，但我反而觉得这是一种高级语言，因为更接近自然语言。当然其主要作用是在视觉渲染上，所以应该是一种受限的语言，可以看作是接近自然语言的子集。所以它的性质觉得了其重语义轻语法的特点，写CSS不能仅靠语法规则，一定要用上语义规则，最好是能和项目中所有人达成共识，CSS框架其实就是一种通用共识。\n","source":"_posts/2015-03-14-thinking-in-semantic-css.md","raw":"---\nlayout: post\ntitle: CSS语义思维\ntags: [css, style, front-end]\ncategory: Tech\n---\n\n![Linguistic](/images/linguistic.png)\n\n前一阵子在项目组中讲了一个关于CSS的Session，在讲之前我曾收到了许多意见，大部分是希望能讲讲CSS实用性的技术，比如盒模型，CSS3之类的。干货人人都喜欢，因为看得见摸得着，拿来就有用，但我最后还是决定讲一些”湿货“。因为在Code Diff的时候我发现了许多样式的问题不是由于不会写CSS导致的，而是由于在错误的地方使用了写在错误地方的样式。\n\n其实CSS很简单，没有计算没有流程，只是一直描述，无论什么复杂的效果，你只要Google一下就知道怎么写了，甚至可以直接copy。但CSS又很复杂，一个元素的表现会受到它旁边的兄弟元素，也会受到内部的子元素影响，还会受到父元素影响，在这种多重影响下，一个元素的显示逻辑会变得错综复杂。有没有面对塌陷的块级元素而束手无策？无论怎么改它的属性就是得不到自己想要的，但看看似乎一模一样的示例程序却安然无恙，是不是恨得咬牙切齿？我想这就是本文所要解决的主要问题，让你学会如何优雅的写CSS。\n\n<!-- more -->\n\n### 泾渭分明 - 明确书写意图和表现语义\n\n其实我们只要稍微接触过CSS，一定都学过盒模型，我假设你已经对margin、padding和border已经很熟悉。好了，我们经常会遇到一种情况，想让父元素和子元素之间有一些空间，比如布局的时候，container和content之间的留白。一般来说有两种方式，一种是给父元素加padding内边距，另一种是给子元素加margin外边距。现在想想，你是否慎重考虑过用哪一种方式？你是否明白两者的区别？如果你从未考虑过这些，现在考虑也不迟，这真的很重要，如果你真的想优雅的运用CSS，而不是被它耍的团团转，如果你真的想把CSS写出规模，那你就要认真的思考这里面的逻辑。\n\n先说说父元素的container加上padding的方式，子元素的背景将不会延伸到空白区域，另一种给子元素加margin的方式则反之。但我想先抛下这个表象，看看此时加上padding的父元素的逻辑。它意味着，我创建了一个容器，并且该容器的内部有一些区域是被看不见的东西填充的，无论放入什么都不应该占据这个区域。在你的脑海中想象一个厚厚的玻璃瓶，它就好像是在说“虽然我是透明的，但是在这厚厚的玻璃之内才是你应该呆的地方，无论是什么只要你想放在瓶子里”。现在来看看子元素，是的，其背景也应该并且确实在内部，而不该占据那段空白的区域。如果是为子元素加上margin，这意味着我在容器中创建了某个东西，而这个东西有一个自己的地盘，容器内的其他东西都不能进入这里。\n\n所以他们的本质区别在于其所表达的意义，也就是语义，一个是容器上的语义，另一个是容器内元素的语义，主语也不同，谓语意义也不同。那么这能说明什么呢，不得不提一下高级语言中的高级，这代表某个语言将机器语言封装的更好，接口更接近自然语言，其强大不言而喻。其实编程语言的发展轨迹就是不断把机器语言往自然语言翻译，让人们可以更容易的跟机器沟通，终极目标自然是人工智能，和机器用自然语言自由沟通。所以虽然代码或者说CSS的语法并没有什么变化，但我们应该在思维上清楚的区分代码片段的意图和语义来写CSS。\n\n语言学家乔姆斯基曾构造过一句符合语法的话:\n\n>“Colorless green ideas sleep furiously”\n\n意思是无色的绿色想法愤怒的睡觉。想法睡觉是违反常识的，无色的绿色是矛盾的，愤怒的睡觉是不合常理的。仅仅符合语法是不够的，仅仅不报错也是不够的，尤其是CSS这种描述性的语言很少会报错，所以我想说的是，其描述性质让我们有更多选择来实现我们所期望的效果，但我们却应该慎重，要让语义分明，而不是在有限的语法规则下任意妄为，那样写不出好的CSS代码。除了其本身的语法规则，我们必须自我约束，引入语义规则，不仅仅是为了提高可读性这样的理由，而是拉近人与机器的距离，让我们在思维上更加和代码契合，这样才能写出优秀的程序。\n\n言归正传，究竟如何语义化CSS呢。之前有讲过OOCSS，其实面向对象的思想就是一种语义化，将虚拟的元素看作实际的对象，用常识来构造代码，就像是用户体验中的用户习惯一样，这是一种遍及全人类的用户习惯，让代码更友好，即所谓的优雅。\n\n比如最常见的布局，我们一般都会有header、body和footer，这样无需任何说明和规则，谁都会理解，header在前，footer在后，中间是body。有趣的是table中的thead、tbody和tfoot，由于加载优化，我们即使把tfoot放在tbody前面，让其先加载，但显示的时候tfoot仍然会在tbody下面，由此可见语义化的重要，否则你一定会以为不是W3C的人弄错了标准，就是浏览器厂商搞出了Bug。虽然这是HTML标签不是CSS，但我觉得这个例子很恰当的说明了一点，显示逻辑是独立的，不应该和其他逻辑混为一谈，它应该只关心如何显示。\n\n再比如，一个导航条一般分为左右两边，里面各有若干链接。你会如何命名？navbar-left和navbar-right是Bootstrap所使用的class，但当宽度减少，Responsive响应式的Bootstrap会让这些链接都收进下拉菜单中，左和右又从何谈起呢？同样是Bootstrap中的颜色命名就做的十分成熟，不是green、blue、red这些词汇，而是success、primary、warning这些词，它们的区别是表现化与语义化的区别，我喜欢把这个叫做`显示逻辑`。也就是说在class层面我们应该只关注元素（或者说对象）是用来做什么的（意图）以及它应该表示什么（语义）。这里三种颜色代表成功、重要和警告，至于我们是用绿、蓝和红来表示还是通过其他什么颜色甚至形状，应该在style层面写CSS属性表示。如此我们使用class时无需迷茫于表示成功应该用绿色还是红色，意图明确无误。回到导航栏的例子，我们应该使用main和sub之类的词语标识导航栏中重要的和次要的链接，即使在某些实现下，主要和次要没有区别也不用担心，那是该实现的显示逻辑，我们不应该横加干涉。\n\n### 狡兔三窟 - 善用class与style多对多的复杂关系\n\n说到class和style（样式属性），这又是一段混乱不清的关系。其实每当我们要实现一个样式，自觉或不自觉的都会考虑，是将元素和class一一对应，然后为元素上的class写style，还是用class和几条style对应之后在元素上搭配组合。前者的好处是每个class中的style不会影响其他class，但可用性十分的低，极端点说这已经不算是在编程了，而是在画页面；后者的好处可以灵活使用不同的样式搭配给元素使用，组合出元素需要的效果，但很难维护，牵一发动全身，样式很难测试，无法保证在你动了一条style之后，没有影响其他的地方。甚至最要命的是大部分CSS代码都是无意识的游走在这两种情况之间，所以我们要做的不是选择一种极端，而是找到一个平衡点，并使用一些方法使得我们的CSS既能灵活复用在各种元素上，又能易于维护，不致修了这破坏那的情况。\n\n###### 分组\n\n首先，对于一个或一套元素的样式，我们应该有自己的创建原则，而不是想到哪写到哪。比如，我一般使用这样的步骤来创建元素：\n\n1. 结构\n    \n首先仅关注结构布局，以站点整体为基准，将元素抽象为一个或多个结构。\n\n比如制作一个按钮，你也许会发现它的尺寸和导航上的链接一致，而内外边距以及display和overflow之类的属性又和页面容器一样，这时你就可以把按钮的结构拆成两个结构，一个是尺寸，一个是边界逻辑，这种情况时常发生，所以有的CSS理论认为应该把width和height这对尺寸属性和padding以及margin这对边距属性彻底的分开也是这个道理。其实并不是说它们4个放一起就决定不行，只是一般它们都有各自复用的价值，所以常常被拆开使用，归根揭底这是由显示逻辑决定的。\n\n1. 皮肤\n\n一般由于设计统一性，我们可以借助设计指导，轻松的制作出标准皮肤。但要注意的是，皮肤指的不仅仅甚至不一定是颜色之类的。继续用Bootstrap举例，有5种基础颜色，但这并不是皮肤，5种颜色的语义不同，它们只是默认用了5种颜色，勉强可以看作默认皮肤，而真正的皮肤是theme，让按钮变得有立体感。还有一个误区就是认为哪几种属性是皮肤，哪几种不是。就像前面所说的，我们要在语义上进行划分。一个属性在某些意图下可能是结构，在另外的意图中可能是皮肤。![Logo](https://raw.githubusercontent.com/UIWorkshop/onlyjs/master/source/Logo.jpg)举个极端的例子，在一个Workshop中我用CSS和HTML制作了左边这样的Logo，Logo本身应该完全算是皮肤，因为一般来说就是一张图片，所以制作它的所有CSS属性都应该算作皮肤。下面的CSS代码中，无论是定位还是文字的处理，以及尺寸等，都是为了构造Logo，所以这些属性都是皮肤。\n\n```css\n#logo i, #logo b {\n  position: relative;\n}\n#logo i {\n  left: -30px;\n  transform: rotate(-30deg);\n  font-size: 60px;\n  letter-spacing: -11px;\n  opacity: 0.3;\n}\n#logo b {\n  top: -43px;\n  left: 40px;\n  font-size: 68px;\n  word-break: break-all;\n  width: 3px;\n  line-height: 10px;\n  text-indent: 6px;\n}\n```\n\n1. 状态\n\n除了结构和皮肤，其实还有一类很容易被人忽视的样式，即使是设计人员也经常忘了它，那就是状态。最常见的是hover，鼠标触碰元素与否的状态，以及active，当前选中的标签，当前所在的分页等等。通常人们会把它划分到皮肤中，但你要明白我们划分的依据是意图，很显然，状态不是皮肤，仅仅是通常为表达某些状态时会使用一些颜色，毕竟颜色是最好的表示方法。它还与各种逻辑有着千丝万缕的联系，经常会使用JavaScript来加以控制，所以将状态单独分出来是极有必要的，JavaScript只需要更改一个class就可以实现状态的切换，而不是在执行的时候才想起来应该把哪里隐藏把哪里显示，或者是变个颜色出个动画之类的。\n\n###### 使用\n\n接着，无论我们是已经把各种写好的CSS属性分好了组，还是正准备以这种方式开始写CSS，我先引入一个语言学的术语 `语块（Lexical chunk）`，创造这一术语的 Michael Lewis 认为语言并非由传统语法和词汇组成，而是由多个词汇的预制语块组成。我们现在分好的组其实就是一个个CSS的语块，CSS本身就是这种预制功能，我们要做的就是把style语块化，然后在HTML中写上代表它的class名称，当HTML元素上的多个class组合在一起时就组成完整的语义。\n\n比如表示步骤的元素，这是一个形状类似标签，一个挨一个的排列的元素。我将它的尺寸等属性抽出来命名为label，然后把布局的属性组命名为float-left，如果我的设计风格是扁平化的，我可以把相关的皮肤属性命名为flat，你知道虽然扁平化一般用不着特别的属性，但我也可以写一些强制去掉圆角和渐变背景的属性。作为步骤，会分为当前的步骤，之前的步骤，以及还没到的步骤，当前的步骤可以命名为current，或者is—active，后面的步骤不能点所以可以命名为is-disable，这些都是状态。而现在我们来看看当前步骤元素是什么样的\n\n```\n    <div class=\"flat label float-left is-active\"></div>\n```\n\n总结成一句话就是“The flat label which float left is active”。这就是语义化的CSS。把组织好的语块像说话一样作用于元素上，对元素发出指令，让其变成想要的样式。而且你应该会发现，一组该元素所独有的属性，或者是尺寸之类的一般是主语，布局是动宾短语，而皮肤多是一些形容词，最后状态可以用表语。\n\n总之，CSS作为一个描述性的语言，有很多人觉得不能算一种语言，但我反而觉得这是一种高级语言，因为更接近自然语言。当然其主要作用是在视觉渲染上，所以应该是一种受限的语言，可以看作是接近自然语言的子集。所以它的性质觉得了其重语义轻语法的特点，写CSS不能仅靠语法规则，一定要用上语义规则，最好是能和项目中所有人达成共识，CSS框架其实就是一种通用共识。\n","slug":"thinking-in-semantic-css","published":1,"date":"2015-03-13T16:00:00.000Z","updated":"2021-11-28T11:59:29.970Z","_id":"ckwj655190013vyjh5pll4fuf","comments":1,"photos":[],"link":"","content":"<p><img src=\"/images/linguistic.png\" alt=\"Linguistic\"></p>\n<p>前一阵子在项目组中讲了一个关于CSS的Session，在讲之前我曾收到了许多意见，大部分是希望能讲讲CSS实用性的技术，比如盒模型，CSS3之类的。干货人人都喜欢，因为看得见摸得着，拿来就有用，但我最后还是决定讲一些”湿货“。因为在Code Diff的时候我发现了许多样式的问题不是由于不会写CSS导致的，而是由于在错误的地方使用了写在错误地方的样式。</p>\n<p>其实CSS很简单，没有计算没有流程，只是一直描述，无论什么复杂的效果，你只要Google一下就知道怎么写了，甚至可以直接copy。但CSS又很复杂，一个元素的表现会受到它旁边的兄弟元素，也会受到内部的子元素影响，还会受到父元素影响，在这种多重影响下，一个元素的显示逻辑会变得错综复杂。有没有面对塌陷的块级元素而束手无策？无论怎么改它的属性就是得不到自己想要的，但看看似乎一模一样的示例程序却安然无恙，是不是恨得咬牙切齿？我想这就是本文所要解决的主要问题，让你学会如何优雅的写CSS。</p>\n<span id=\"more\"></span>\n\n<h3 id=\"泾渭分明-明确书写意图和表现语义\"><a href=\"#泾渭分明-明确书写意图和表现语义\" class=\"headerlink\" title=\"泾渭分明 - 明确书写意图和表现语义\"></a>泾渭分明 - 明确书写意图和表现语义</h3><p>其实我们只要稍微接触过CSS，一定都学过盒模型，我假设你已经对margin、padding和border已经很熟悉。好了，我们经常会遇到一种情况，想让父元素和子元素之间有一些空间，比如布局的时候，container和content之间的留白。一般来说有两种方式，一种是给父元素加padding内边距，另一种是给子元素加margin外边距。现在想想，你是否慎重考虑过用哪一种方式？你是否明白两者的区别？如果你从未考虑过这些，现在考虑也不迟，这真的很重要，如果你真的想优雅的运用CSS，而不是被它耍的团团转，如果你真的想把CSS写出规模，那你就要认真的思考这里面的逻辑。</p>\n<p>先说说父元素的container加上padding的方式，子元素的背景将不会延伸到空白区域，另一种给子元素加margin的方式则反之。但我想先抛下这个表象，看看此时加上padding的父元素的逻辑。它意味着，我创建了一个容器，并且该容器的内部有一些区域是被看不见的东西填充的，无论放入什么都不应该占据这个区域。在你的脑海中想象一个厚厚的玻璃瓶，它就好像是在说“虽然我是透明的，但是在这厚厚的玻璃之内才是你应该呆的地方，无论是什么只要你想放在瓶子里”。现在来看看子元素，是的，其背景也应该并且确实在内部，而不该占据那段空白的区域。如果是为子元素加上margin，这意味着我在容器中创建了某个东西，而这个东西有一个自己的地盘，容器内的其他东西都不能进入这里。</p>\n<p>所以他们的本质区别在于其所表达的意义，也就是语义，一个是容器上的语义，另一个是容器内元素的语义，主语也不同，谓语意义也不同。那么这能说明什么呢，不得不提一下高级语言中的高级，这代表某个语言将机器语言封装的更好，接口更接近自然语言，其强大不言而喻。其实编程语言的发展轨迹就是不断把机器语言往自然语言翻译，让人们可以更容易的跟机器沟通，终极目标自然是人工智能，和机器用自然语言自由沟通。所以虽然代码或者说CSS的语法并没有什么变化，但我们应该在思维上清楚的区分代码片段的意图和语义来写CSS。</p>\n<p>语言学家乔姆斯基曾构造过一句符合语法的话:</p>\n<blockquote>\n<p>“Colorless green ideas sleep furiously”</p>\n</blockquote>\n<p>意思是无色的绿色想法愤怒的睡觉。想法睡觉是违反常识的，无色的绿色是矛盾的，愤怒的睡觉是不合常理的。仅仅符合语法是不够的，仅仅不报错也是不够的，尤其是CSS这种描述性的语言很少会报错，所以我想说的是，其描述性质让我们有更多选择来实现我们所期望的效果，但我们却应该慎重，要让语义分明，而不是在有限的语法规则下任意妄为，那样写不出好的CSS代码。除了其本身的语法规则，我们必须自我约束，引入语义规则，不仅仅是为了提高可读性这样的理由，而是拉近人与机器的距离，让我们在思维上更加和代码契合，这样才能写出优秀的程序。</p>\n<p>言归正传，究竟如何语义化CSS呢。之前有讲过OOCSS，其实面向对象的思想就是一种语义化，将虚拟的元素看作实际的对象，用常识来构造代码，就像是用户体验中的用户习惯一样，这是一种遍及全人类的用户习惯，让代码更友好，即所谓的优雅。</p>\n<p>比如最常见的布局，我们一般都会有header、body和footer，这样无需任何说明和规则，谁都会理解，header在前，footer在后，中间是body。有趣的是table中的thead、tbody和tfoot，由于加载优化，我们即使把tfoot放在tbody前面，让其先加载，但显示的时候tfoot仍然会在tbody下面，由此可见语义化的重要，否则你一定会以为不是W3C的人弄错了标准，就是浏览器厂商搞出了Bug。虽然这是HTML标签不是CSS，但我觉得这个例子很恰当的说明了一点，显示逻辑是独立的，不应该和其他逻辑混为一谈，它应该只关心如何显示。</p>\n<p>再比如，一个导航条一般分为左右两边，里面各有若干链接。你会如何命名？navbar-left和navbar-right是Bootstrap所使用的class，但当宽度减少，Responsive响应式的Bootstrap会让这些链接都收进下拉菜单中，左和右又从何谈起呢？同样是Bootstrap中的颜色命名就做的十分成熟，不是green、blue、red这些词汇，而是success、primary、warning这些词，它们的区别是表现化与语义化的区别，我喜欢把这个叫做<code>显示逻辑</code>。也就是说在class层面我们应该只关注元素（或者说对象）是用来做什么的（意图）以及它应该表示什么（语义）。这里三种颜色代表成功、重要和警告，至于我们是用绿、蓝和红来表示还是通过其他什么颜色甚至形状，应该在style层面写CSS属性表示。如此我们使用class时无需迷茫于表示成功应该用绿色还是红色，意图明确无误。回到导航栏的例子，我们应该使用main和sub之类的词语标识导航栏中重要的和次要的链接，即使在某些实现下，主要和次要没有区别也不用担心，那是该实现的显示逻辑，我们不应该横加干涉。</p>\n<h3 id=\"狡兔三窟-善用class与style多对多的复杂关系\"><a href=\"#狡兔三窟-善用class与style多对多的复杂关系\" class=\"headerlink\" title=\"狡兔三窟 - 善用class与style多对多的复杂关系\"></a>狡兔三窟 - 善用class与style多对多的复杂关系</h3><p>说到class和style（样式属性），这又是一段混乱不清的关系。其实每当我们要实现一个样式，自觉或不自觉的都会考虑，是将元素和class一一对应，然后为元素上的class写style，还是用class和几条style对应之后在元素上搭配组合。前者的好处是每个class中的style不会影响其他class，但可用性十分的低，极端点说这已经不算是在编程了，而是在画页面；后者的好处可以灵活使用不同的样式搭配给元素使用，组合出元素需要的效果，但很难维护，牵一发动全身，样式很难测试，无法保证在你动了一条style之后，没有影响其他的地方。甚至最要命的是大部分CSS代码都是无意识的游走在这两种情况之间，所以我们要做的不是选择一种极端，而是找到一个平衡点，并使用一些方法使得我们的CSS既能灵活复用在各种元素上，又能易于维护，不致修了这破坏那的情况。</p>\n<h6 id=\"分组\"><a href=\"#分组\" class=\"headerlink\" title=\"分组\"></a>分组</h6><p>首先，对于一个或一套元素的样式，我们应该有自己的创建原则，而不是想到哪写到哪。比如，我一般使用这样的步骤来创建元素：</p>\n<ol>\n<li>结构</li>\n</ol>\n<p>首先仅关注结构布局，以站点整体为基准，将元素抽象为一个或多个结构。</p>\n<p>比如制作一个按钮，你也许会发现它的尺寸和导航上的链接一致，而内外边距以及display和overflow之类的属性又和页面容器一样，这时你就可以把按钮的结构拆成两个结构，一个是尺寸，一个是边界逻辑，这种情况时常发生，所以有的CSS理论认为应该把width和height这对尺寸属性和padding以及margin这对边距属性彻底的分开也是这个道理。其实并不是说它们4个放一起就决定不行，只是一般它们都有各自复用的价值，所以常常被拆开使用，归根揭底这是由显示逻辑决定的。</p>\n<ol>\n<li>皮肤</li>\n</ol>\n<p>一般由于设计统一性，我们可以借助设计指导，轻松的制作出标准皮肤。但要注意的是，皮肤指的不仅仅甚至不一定是颜色之类的。继续用Bootstrap举例，有5种基础颜色，但这并不是皮肤，5种颜色的语义不同，它们只是默认用了5种颜色，勉强可以看作默认皮肤，而真正的皮肤是theme，让按钮变得有立体感。还有一个误区就是认为哪几种属性是皮肤，哪几种不是。就像前面所说的，我们要在语义上进行划分。一个属性在某些意图下可能是结构，在另外的意图中可能是皮肤。<img src=\"https://raw.githubusercontent.com/UIWorkshop/onlyjs/master/source/Logo.jpg\" alt=\"Logo\">举个极端的例子，在一个Workshop中我用CSS和HTML制作了左边这样的Logo，Logo本身应该完全算是皮肤，因为一般来说就是一张图片，所以制作它的所有CSS属性都应该算作皮肤。下面的CSS代码中，无论是定位还是文字的处理，以及尺寸等，都是为了构造Logo，所以这些属性都是皮肤。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#logo</span> <span class=\"selector-tag\">i</span>, <span class=\"selector-id\">#logo</span> <span class=\"selector-tag\">b</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-id\">#logo</span> <span class=\"selector-tag\">i</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">left</span>: -<span class=\"number\">30px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">rotate</span>(-<span class=\"number\">30deg</span>);</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">60px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">letter-spacing</span>: -<span class=\"number\">11px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">opacity</span>: <span class=\"number\">0.3</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-id\">#logo</span> <span class=\"selector-tag\">b</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">top</span>: -<span class=\"number\">43px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">left</span>: <span class=\"number\">40px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">68px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">word-break</span>: break-all;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">3px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">line-height</span>: <span class=\"number\">10px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">text-indent</span>: <span class=\"number\">6px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>状态</li>\n</ol>\n<p>除了结构和皮肤，其实还有一类很容易被人忽视的样式，即使是设计人员也经常忘了它，那就是状态。最常见的是hover，鼠标触碰元素与否的状态，以及active，当前选中的标签，当前所在的分页等等。通常人们会把它划分到皮肤中，但你要明白我们划分的依据是意图，很显然，状态不是皮肤，仅仅是通常为表达某些状态时会使用一些颜色，毕竟颜色是最好的表示方法。它还与各种逻辑有着千丝万缕的联系，经常会使用JavaScript来加以控制，所以将状态单独分出来是极有必要的，JavaScript只需要更改一个class就可以实现状态的切换，而不是在执行的时候才想起来应该把哪里隐藏把哪里显示，或者是变个颜色出个动画之类的。</p>\n<h6 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h6><p>接着，无论我们是已经把各种写好的CSS属性分好了组，还是正准备以这种方式开始写CSS，我先引入一个语言学的术语 <code>语块（Lexical chunk）</code>，创造这一术语的 Michael Lewis 认为语言并非由传统语法和词汇组成，而是由多个词汇的预制语块组成。我们现在分好的组其实就是一个个CSS的语块，CSS本身就是这种预制功能，我们要做的就是把style语块化，然后在HTML中写上代表它的class名称，当HTML元素上的多个class组合在一起时就组成完整的语义。</p>\n<p>比如表示步骤的元素，这是一个形状类似标签，一个挨一个的排列的元素。我将它的尺寸等属性抽出来命名为label，然后把布局的属性组命名为float-left，如果我的设计风格是扁平化的，我可以把相关的皮肤属性命名为flat，你知道虽然扁平化一般用不着特别的属性，但我也可以写一些强制去掉圆角和渐变背景的属性。作为步骤，会分为当前的步骤，之前的步骤，以及还没到的步骤，当前的步骤可以命名为current，或者is—active，后面的步骤不能点所以可以命名为is-disable，这些都是状态。而现在我们来看看当前步骤元素是什么样的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div class=&quot;flat label float-left is-active&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<p>总结成一句话就是“The flat label which float left is active”。这就是语义化的CSS。把组织好的语块像说话一样作用于元素上，对元素发出指令，让其变成想要的样式。而且你应该会发现，一组该元素所独有的属性，或者是尺寸之类的一般是主语，布局是动宾短语，而皮肤多是一些形容词，最后状态可以用表语。</p>\n<p>总之，CSS作为一个描述性的语言，有很多人觉得不能算一种语言，但我反而觉得这是一种高级语言，因为更接近自然语言。当然其主要作用是在视觉渲染上，所以应该是一种受限的语言，可以看作是接近自然语言的子集。所以它的性质觉得了其重语义轻语法的特点，写CSS不能仅靠语法规则，一定要用上语义规则，最好是能和项目中所有人达成共识，CSS框架其实就是一种通用共识。</p>\n","site":{"data":{}},"excerpt":"<p><img src=\"/images/linguistic.png\" alt=\"Linguistic\"></p>\n<p>前一阵子在项目组中讲了一个关于CSS的Session，在讲之前我曾收到了许多意见，大部分是希望能讲讲CSS实用性的技术，比如盒模型，CSS3之类的。干货人人都喜欢，因为看得见摸得着，拿来就有用，但我最后还是决定讲一些”湿货“。因为在Code Diff的时候我发现了许多样式的问题不是由于不会写CSS导致的，而是由于在错误的地方使用了写在错误地方的样式。</p>\n<p>其实CSS很简单，没有计算没有流程，只是一直描述，无论什么复杂的效果，你只要Google一下就知道怎么写了，甚至可以直接copy。但CSS又很复杂，一个元素的表现会受到它旁边的兄弟元素，也会受到内部的子元素影响，还会受到父元素影响，在这种多重影响下，一个元素的显示逻辑会变得错综复杂。有没有面对塌陷的块级元素而束手无策？无论怎么改它的属性就是得不到自己想要的，但看看似乎一模一样的示例程序却安然无恙，是不是恨得咬牙切齿？我想这就是本文所要解决的主要问题，让你学会如何优雅的写CSS。</p>","more":"<h3 id=\"泾渭分明-明确书写意图和表现语义\"><a href=\"#泾渭分明-明确书写意图和表现语义\" class=\"headerlink\" title=\"泾渭分明 - 明确书写意图和表现语义\"></a>泾渭分明 - 明确书写意图和表现语义</h3><p>其实我们只要稍微接触过CSS，一定都学过盒模型，我假设你已经对margin、padding和border已经很熟悉。好了，我们经常会遇到一种情况，想让父元素和子元素之间有一些空间，比如布局的时候，container和content之间的留白。一般来说有两种方式，一种是给父元素加padding内边距，另一种是给子元素加margin外边距。现在想想，你是否慎重考虑过用哪一种方式？你是否明白两者的区别？如果你从未考虑过这些，现在考虑也不迟，这真的很重要，如果你真的想优雅的运用CSS，而不是被它耍的团团转，如果你真的想把CSS写出规模，那你就要认真的思考这里面的逻辑。</p>\n<p>先说说父元素的container加上padding的方式，子元素的背景将不会延伸到空白区域，另一种给子元素加margin的方式则反之。但我想先抛下这个表象，看看此时加上padding的父元素的逻辑。它意味着，我创建了一个容器，并且该容器的内部有一些区域是被看不见的东西填充的，无论放入什么都不应该占据这个区域。在你的脑海中想象一个厚厚的玻璃瓶，它就好像是在说“虽然我是透明的，但是在这厚厚的玻璃之内才是你应该呆的地方，无论是什么只要你想放在瓶子里”。现在来看看子元素，是的，其背景也应该并且确实在内部，而不该占据那段空白的区域。如果是为子元素加上margin，这意味着我在容器中创建了某个东西，而这个东西有一个自己的地盘，容器内的其他东西都不能进入这里。</p>\n<p>所以他们的本质区别在于其所表达的意义，也就是语义，一个是容器上的语义，另一个是容器内元素的语义，主语也不同，谓语意义也不同。那么这能说明什么呢，不得不提一下高级语言中的高级，这代表某个语言将机器语言封装的更好，接口更接近自然语言，其强大不言而喻。其实编程语言的发展轨迹就是不断把机器语言往自然语言翻译，让人们可以更容易的跟机器沟通，终极目标自然是人工智能，和机器用自然语言自由沟通。所以虽然代码或者说CSS的语法并没有什么变化，但我们应该在思维上清楚的区分代码片段的意图和语义来写CSS。</p>\n<p>语言学家乔姆斯基曾构造过一句符合语法的话:</p>\n<blockquote>\n<p>“Colorless green ideas sleep furiously”</p>\n</blockquote>\n<p>意思是无色的绿色想法愤怒的睡觉。想法睡觉是违反常识的，无色的绿色是矛盾的，愤怒的睡觉是不合常理的。仅仅符合语法是不够的，仅仅不报错也是不够的，尤其是CSS这种描述性的语言很少会报错，所以我想说的是，其描述性质让我们有更多选择来实现我们所期望的效果，但我们却应该慎重，要让语义分明，而不是在有限的语法规则下任意妄为，那样写不出好的CSS代码。除了其本身的语法规则，我们必须自我约束，引入语义规则，不仅仅是为了提高可读性这样的理由，而是拉近人与机器的距离，让我们在思维上更加和代码契合，这样才能写出优秀的程序。</p>\n<p>言归正传，究竟如何语义化CSS呢。之前有讲过OOCSS，其实面向对象的思想就是一种语义化，将虚拟的元素看作实际的对象，用常识来构造代码，就像是用户体验中的用户习惯一样，这是一种遍及全人类的用户习惯，让代码更友好，即所谓的优雅。</p>\n<p>比如最常见的布局，我们一般都会有header、body和footer，这样无需任何说明和规则，谁都会理解，header在前，footer在后，中间是body。有趣的是table中的thead、tbody和tfoot，由于加载优化，我们即使把tfoot放在tbody前面，让其先加载，但显示的时候tfoot仍然会在tbody下面，由此可见语义化的重要，否则你一定会以为不是W3C的人弄错了标准，就是浏览器厂商搞出了Bug。虽然这是HTML标签不是CSS，但我觉得这个例子很恰当的说明了一点，显示逻辑是独立的，不应该和其他逻辑混为一谈，它应该只关心如何显示。</p>\n<p>再比如，一个导航条一般分为左右两边，里面各有若干链接。你会如何命名？navbar-left和navbar-right是Bootstrap所使用的class，但当宽度减少，Responsive响应式的Bootstrap会让这些链接都收进下拉菜单中，左和右又从何谈起呢？同样是Bootstrap中的颜色命名就做的十分成熟，不是green、blue、red这些词汇，而是success、primary、warning这些词，它们的区别是表现化与语义化的区别，我喜欢把这个叫做<code>显示逻辑</code>。也就是说在class层面我们应该只关注元素（或者说对象）是用来做什么的（意图）以及它应该表示什么（语义）。这里三种颜色代表成功、重要和警告，至于我们是用绿、蓝和红来表示还是通过其他什么颜色甚至形状，应该在style层面写CSS属性表示。如此我们使用class时无需迷茫于表示成功应该用绿色还是红色，意图明确无误。回到导航栏的例子，我们应该使用main和sub之类的词语标识导航栏中重要的和次要的链接，即使在某些实现下，主要和次要没有区别也不用担心，那是该实现的显示逻辑，我们不应该横加干涉。</p>\n<h3 id=\"狡兔三窟-善用class与style多对多的复杂关系\"><a href=\"#狡兔三窟-善用class与style多对多的复杂关系\" class=\"headerlink\" title=\"狡兔三窟 - 善用class与style多对多的复杂关系\"></a>狡兔三窟 - 善用class与style多对多的复杂关系</h3><p>说到class和style（样式属性），这又是一段混乱不清的关系。其实每当我们要实现一个样式，自觉或不自觉的都会考虑，是将元素和class一一对应，然后为元素上的class写style，还是用class和几条style对应之后在元素上搭配组合。前者的好处是每个class中的style不会影响其他class，但可用性十分的低，极端点说这已经不算是在编程了，而是在画页面；后者的好处可以灵活使用不同的样式搭配给元素使用，组合出元素需要的效果，但很难维护，牵一发动全身，样式很难测试，无法保证在你动了一条style之后，没有影响其他的地方。甚至最要命的是大部分CSS代码都是无意识的游走在这两种情况之间，所以我们要做的不是选择一种极端，而是找到一个平衡点，并使用一些方法使得我们的CSS既能灵活复用在各种元素上，又能易于维护，不致修了这破坏那的情况。</p>\n<h6 id=\"分组\"><a href=\"#分组\" class=\"headerlink\" title=\"分组\"></a>分组</h6><p>首先，对于一个或一套元素的样式，我们应该有自己的创建原则，而不是想到哪写到哪。比如，我一般使用这样的步骤来创建元素：</p>\n<ol>\n<li>结构</li>\n</ol>\n<p>首先仅关注结构布局，以站点整体为基准，将元素抽象为一个或多个结构。</p>\n<p>比如制作一个按钮，你也许会发现它的尺寸和导航上的链接一致，而内外边距以及display和overflow之类的属性又和页面容器一样，这时你就可以把按钮的结构拆成两个结构，一个是尺寸，一个是边界逻辑，这种情况时常发生，所以有的CSS理论认为应该把width和height这对尺寸属性和padding以及margin这对边距属性彻底的分开也是这个道理。其实并不是说它们4个放一起就决定不行，只是一般它们都有各自复用的价值，所以常常被拆开使用，归根揭底这是由显示逻辑决定的。</p>\n<ol>\n<li>皮肤</li>\n</ol>\n<p>一般由于设计统一性，我们可以借助设计指导，轻松的制作出标准皮肤。但要注意的是，皮肤指的不仅仅甚至不一定是颜色之类的。继续用Bootstrap举例，有5种基础颜色，但这并不是皮肤，5种颜色的语义不同，它们只是默认用了5种颜色，勉强可以看作默认皮肤，而真正的皮肤是theme，让按钮变得有立体感。还有一个误区就是认为哪几种属性是皮肤，哪几种不是。就像前面所说的，我们要在语义上进行划分。一个属性在某些意图下可能是结构，在另外的意图中可能是皮肤。<img src=\"https://raw.githubusercontent.com/UIWorkshop/onlyjs/master/source/Logo.jpg\" alt=\"Logo\">举个极端的例子，在一个Workshop中我用CSS和HTML制作了左边这样的Logo，Logo本身应该完全算是皮肤，因为一般来说就是一张图片，所以制作它的所有CSS属性都应该算作皮肤。下面的CSS代码中，无论是定位还是文字的处理，以及尺寸等，都是为了构造Logo，所以这些属性都是皮肤。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#logo</span> <span class=\"selector-tag\">i</span>, <span class=\"selector-id\">#logo</span> <span class=\"selector-tag\">b</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-id\">#logo</span> <span class=\"selector-tag\">i</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">left</span>: -<span class=\"number\">30px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">rotate</span>(-<span class=\"number\">30deg</span>);</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">60px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">letter-spacing</span>: -<span class=\"number\">11px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">opacity</span>: <span class=\"number\">0.3</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-id\">#logo</span> <span class=\"selector-tag\">b</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">top</span>: -<span class=\"number\">43px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">left</span>: <span class=\"number\">40px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">68px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">word-break</span>: break-all;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">3px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">line-height</span>: <span class=\"number\">10px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">text-indent</span>: <span class=\"number\">6px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>状态</li>\n</ol>\n<p>除了结构和皮肤，其实还有一类很容易被人忽视的样式，即使是设计人员也经常忘了它，那就是状态。最常见的是hover，鼠标触碰元素与否的状态，以及active，当前选中的标签，当前所在的分页等等。通常人们会把它划分到皮肤中，但你要明白我们划分的依据是意图，很显然，状态不是皮肤，仅仅是通常为表达某些状态时会使用一些颜色，毕竟颜色是最好的表示方法。它还与各种逻辑有着千丝万缕的联系，经常会使用JavaScript来加以控制，所以将状态单独分出来是极有必要的，JavaScript只需要更改一个class就可以实现状态的切换，而不是在执行的时候才想起来应该把哪里隐藏把哪里显示，或者是变个颜色出个动画之类的。</p>\n<h6 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h6><p>接着，无论我们是已经把各种写好的CSS属性分好了组，还是正准备以这种方式开始写CSS，我先引入一个语言学的术语 <code>语块（Lexical chunk）</code>，创造这一术语的 Michael Lewis 认为语言并非由传统语法和词汇组成，而是由多个词汇的预制语块组成。我们现在分好的组其实就是一个个CSS的语块，CSS本身就是这种预制功能，我们要做的就是把style语块化，然后在HTML中写上代表它的class名称，当HTML元素上的多个class组合在一起时就组成完整的语义。</p>\n<p>比如表示步骤的元素，这是一个形状类似标签，一个挨一个的排列的元素。我将它的尺寸等属性抽出来命名为label，然后把布局的属性组命名为float-left，如果我的设计风格是扁平化的，我可以把相关的皮肤属性命名为flat，你知道虽然扁平化一般用不着特别的属性，但我也可以写一些强制去掉圆角和渐变背景的属性。作为步骤，会分为当前的步骤，之前的步骤，以及还没到的步骤，当前的步骤可以命名为current，或者is—active，后面的步骤不能点所以可以命名为is-disable，这些都是状态。而现在我们来看看当前步骤元素是什么样的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div class=&quot;flat label float-left is-active&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<p>总结成一句话就是“The flat label which float left is active”。这就是语义化的CSS。把组织好的语块像说话一样作用于元素上，对元素发出指令，让其变成想要的样式。而且你应该会发现，一组该元素所独有的属性，或者是尺寸之类的一般是主语，布局是动宾短语，而皮肤多是一些形容词，最后状态可以用表语。</p>\n<p>总之，CSS作为一个描述性的语言，有很多人觉得不能算一种语言，但我反而觉得这是一种高级语言，因为更接近自然语言。当然其主要作用是在视觉渲染上，所以应该是一种受限的语言，可以看作是接近自然语言的子集。所以它的性质觉得了其重语义轻语法的特点，写CSS不能仅靠语法规则，一定要用上语义规则，最好是能和项目中所有人达成共识，CSS框架其实就是一种通用共识。</p>"},{"layout":"post","title":"用“五个为什么”写CSS","_content":"\n相信大多数人都有过关于CSS的痛苦经历，从我加入公司到现在，不到两年的时间里，听到最多CSS相关的讨论就是‘很难调’。所以我也一直在探究这其中有怎样的问题，为什么很多人觉得CSS很难写，如何才能让其他人更优雅的写CSS。在Code Review的时候，我渐渐的发现了问题所在，其实很多人已经掌握了丰富的CSS知识，但却不知道如何分组属性写成class。最后只好在需要改变样式的元素上随意起个名字做class然后把所有要写的属性丢进这个class里，如果优先级不够，再把前面的选择器都加上。结果就是CSS代码不断堆积，重复和冗余不断增多，维护也变得举步维艰。\n<!-- more -->\n\n问题找到了，但如何解决呢，虽然我在项目组内做了几次分享，还经常在Code Review的时候提出一些问题，却还是收效甚微。有时候知道什么是正确的很容易，但知道如何才能做到正确却很难。直到最近，看了几本书之后，发现了一个很适合指导设计CSS的方法，那就是五个为什么或者叫五问法。五问法来自丰田的精益生产，后来自然衍生到了精益创业中，在DDD以及UX相关书籍中都会见到这个方法，其主旨是深入发觉大量现象的背后所隐藏的真正原因。乍一看它是一个管理方法，其实我觉得它是一种思维方式，即刨根问底的找到问题的根本原因并解决。所以被应用于各个领域，自然对于CSS所面临的问题也正恰如其分。\n\n## 场景示例\n\n先来举个例子吧，某天Code Review发现了一条CSS代码是这样写的：\n\n```\n.max-width {\n\tmax-width: 300px;\n}\n```\n\n由此产生了以下对话（纯属虚构）：\n\n\n>UI Dev：“不应该这样写，这和直接写内联样式有什么区别呢？”\n\n>Dev：“如果我不加最大宽度，页面上那个元素左边就会多出一部分，不然加个margin外边距可以吗？”\n\n>UI Dev：“这个...我也不确定，我从没遇到过这样的问题，一定是哪里有问题。”\n\n>Dev：“确实这样写也挺不好的，过一段时间就不知道这行代码什么意思了，也不敢修改它。但究竟应该如何写呢？”\n\n>UI Dev：“呃，这样吧，我们来试试五个为什么，找找问题的根本原因。”\n\n>Dev：“好啊，CSS的问题也困扰我好久了，能解决就最好了。”\n\n>UI Dev：“首先问问，为什么要给元素加最大宽度呢？”\n\n>Dev：“因为不加就就会多出一部分呀。”\n\n>UI Dev：“那为什么这个元素会多一部分呢？”\n\n>Dev：“因为没加最大宽度，开个玩笑，别生气，其实我也不确定，不过用DevTools看了一下，好像它的父元素的宽度也不对。”\n\n>UI Dev：“已经接近了，为什么父元素的宽度不对？”\n\n>Dev：“因为父元素的内边距两边不一样。”\n\n>UI Dev：“为什么父元素的内边距不一致？”\n\n>Dev：“啊，我知道了，原来为父元素的父元素写了一个last的伪选择器，它是用来把padding-right设为0的，因为父元素现在正好是最后一个，所以被影响了。”\n\n>UI Dev：“别急，为什么要把最后一个元素的padding-right设为0？”\n\n>Dev：“因为原先最后面的那个元素里面是一个无法修改样式的控件，需要把padding-right设为0才能放得下。”\n\n>UI Dev：“所以这才是问题所在，我们的意图是给空间的容器加上padding-right为0的属性对吗？而不是给最后一个元素加，所以应该写一个class，也许叫做‘widget-container’之类的，放在那个容器上，然后把last伪选择器删掉，如此一切就正常了。原先出问题的地方其实是没问题的。”\n\n>Dev：“原来是这样，太好了，我学到了，样式出问题的地方不一定是代码有问题的地方，五个为什么太有用了。”\n\n这样反复问多次“为什么”可以让我们找到问题的根本所在，如果仅仅从表面现象去解决问题很可能导致南辕北辙的后果。而且在例子中的last伪选择器就是因为没有找到根本原因而简单粗暴的写了这样一行代码而导致的。这个例子还很好的展现了五个为什么对于CSS的益处，不仅是找到问题的根本原因，还使得我们在写CSS的时候意图更加明确。如此一来，class命名难的问题也迎刃而解，padding-right应该为的0的元素是那个控件的容器，所以很容易想出“widget-container”这样的名字，因为通过五个为什么的方法找到了真正的意图，此时，class叫什么和应该放在哪都是水到渠成了。\n\n## 按比例投入\n\n但有时候我们所面对的项目不会这么善良，“为什么”的层级越多，说明CSS的关系也越复杂，所以现在我们来谈谈五个为什么中的一个重要原则，按比例投入。其主旨是小问题小投入，大问题大投入，问题等级越高，投入也应该越大。在CSS中来讲，就是当发现样式异常时，使用五个为什么深入找到的根本原因所在之处的重复次数越多，说明问题越严重，对问题的解决方案也应投入的更多。\n\n再回到上面的例子中，通过一个元素位置异常的问题，找到根本原因来自一个控件需要内边距为0的容器元素，由于第一次发现，所以选择投入较小的解决方案，针对该控件加一个class用来去掉内边距。目前看来是很正确的，但如果接二连三的从不同的问题上深入找到这个控件上，那就说明问题等级提升了，不应该仅仅是在每个调用控件的容器上添加该class。此时我们可以考虑其他方式，比如把所有容器内边距都设为0，而有针对性的对内部元素添加外边距，如果问题等级继续提升，还可以修改甚至替换控件，或者重构其他部分来适应该控件。总之就是要按问题等级选择解决问题的手段，这样的好处不仅仅是原先在精益中那样可以自动调节效率，还可以等样式需求更明确的时候作出相应的重构。\n\n由于CSS的描述性，使得它很自由，所以同一个需求，往往一百个开发者有一百种实现。在第一次碰到一个需求时，更是很难写出最佳实现，只能有针对性的写一个专属class把需要的属性扔进去。其实问题不在于此，而在于之后是否能在相同问题出现时重构原先的代码，根据所有相关问题写出更具普适性的class。有经验的UI Dev有时会通过经验来判断，直接写出这种class，Bootstrap这类框架就是这样的，但没有或较少经验的开发者就会产生疑惑。五个为什么的按比例投入原则可以很好的驱动CSS的开发，用深入的根本原因连接不同元素甚至不同页面上出现的问题，这样使我们能够安心的以目前的问题等级来组织代码，等到再次碰到问题并找到这里，才再次重构以解决问题。","source":"_posts/2015-06-20-five-whys-for-css.md","raw":"---\nlayout: post\ntitle: 用“五个为什么”写CSS\ntags: [css, style, front-end, fivewhys]\ncategory: Tech\n---\n\n相信大多数人都有过关于CSS的痛苦经历，从我加入公司到现在，不到两年的时间里，听到最多CSS相关的讨论就是‘很难调’。所以我也一直在探究这其中有怎样的问题，为什么很多人觉得CSS很难写，如何才能让其他人更优雅的写CSS。在Code Review的时候，我渐渐的发现了问题所在，其实很多人已经掌握了丰富的CSS知识，但却不知道如何分组属性写成class。最后只好在需要改变样式的元素上随意起个名字做class然后把所有要写的属性丢进这个class里，如果优先级不够，再把前面的选择器都加上。结果就是CSS代码不断堆积，重复和冗余不断增多，维护也变得举步维艰。\n<!-- more -->\n\n问题找到了，但如何解决呢，虽然我在项目组内做了几次分享，还经常在Code Review的时候提出一些问题，却还是收效甚微。有时候知道什么是正确的很容易，但知道如何才能做到正确却很难。直到最近，看了几本书之后，发现了一个很适合指导设计CSS的方法，那就是五个为什么或者叫五问法。五问法来自丰田的精益生产，后来自然衍生到了精益创业中，在DDD以及UX相关书籍中都会见到这个方法，其主旨是深入发觉大量现象的背后所隐藏的真正原因。乍一看它是一个管理方法，其实我觉得它是一种思维方式，即刨根问底的找到问题的根本原因并解决。所以被应用于各个领域，自然对于CSS所面临的问题也正恰如其分。\n\n## 场景示例\n\n先来举个例子吧，某天Code Review发现了一条CSS代码是这样写的：\n\n```\n.max-width {\n\tmax-width: 300px;\n}\n```\n\n由此产生了以下对话（纯属虚构）：\n\n\n>UI Dev：“不应该这样写，这和直接写内联样式有什么区别呢？”\n\n>Dev：“如果我不加最大宽度，页面上那个元素左边就会多出一部分，不然加个margin外边距可以吗？”\n\n>UI Dev：“这个...我也不确定，我从没遇到过这样的问题，一定是哪里有问题。”\n\n>Dev：“确实这样写也挺不好的，过一段时间就不知道这行代码什么意思了，也不敢修改它。但究竟应该如何写呢？”\n\n>UI Dev：“呃，这样吧，我们来试试五个为什么，找找问题的根本原因。”\n\n>Dev：“好啊，CSS的问题也困扰我好久了，能解决就最好了。”\n\n>UI Dev：“首先问问，为什么要给元素加最大宽度呢？”\n\n>Dev：“因为不加就就会多出一部分呀。”\n\n>UI Dev：“那为什么这个元素会多一部分呢？”\n\n>Dev：“因为没加最大宽度，开个玩笑，别生气，其实我也不确定，不过用DevTools看了一下，好像它的父元素的宽度也不对。”\n\n>UI Dev：“已经接近了，为什么父元素的宽度不对？”\n\n>Dev：“因为父元素的内边距两边不一样。”\n\n>UI Dev：“为什么父元素的内边距不一致？”\n\n>Dev：“啊，我知道了，原来为父元素的父元素写了一个last的伪选择器，它是用来把padding-right设为0的，因为父元素现在正好是最后一个，所以被影响了。”\n\n>UI Dev：“别急，为什么要把最后一个元素的padding-right设为0？”\n\n>Dev：“因为原先最后面的那个元素里面是一个无法修改样式的控件，需要把padding-right设为0才能放得下。”\n\n>UI Dev：“所以这才是问题所在，我们的意图是给空间的容器加上padding-right为0的属性对吗？而不是给最后一个元素加，所以应该写一个class，也许叫做‘widget-container’之类的，放在那个容器上，然后把last伪选择器删掉，如此一切就正常了。原先出问题的地方其实是没问题的。”\n\n>Dev：“原来是这样，太好了，我学到了，样式出问题的地方不一定是代码有问题的地方，五个为什么太有用了。”\n\n这样反复问多次“为什么”可以让我们找到问题的根本所在，如果仅仅从表面现象去解决问题很可能导致南辕北辙的后果。而且在例子中的last伪选择器就是因为没有找到根本原因而简单粗暴的写了这样一行代码而导致的。这个例子还很好的展现了五个为什么对于CSS的益处，不仅是找到问题的根本原因，还使得我们在写CSS的时候意图更加明确。如此一来，class命名难的问题也迎刃而解，padding-right应该为的0的元素是那个控件的容器，所以很容易想出“widget-container”这样的名字，因为通过五个为什么的方法找到了真正的意图，此时，class叫什么和应该放在哪都是水到渠成了。\n\n## 按比例投入\n\n但有时候我们所面对的项目不会这么善良，“为什么”的层级越多，说明CSS的关系也越复杂，所以现在我们来谈谈五个为什么中的一个重要原则，按比例投入。其主旨是小问题小投入，大问题大投入，问题等级越高，投入也应该越大。在CSS中来讲，就是当发现样式异常时，使用五个为什么深入找到的根本原因所在之处的重复次数越多，说明问题越严重，对问题的解决方案也应投入的更多。\n\n再回到上面的例子中，通过一个元素位置异常的问题，找到根本原因来自一个控件需要内边距为0的容器元素，由于第一次发现，所以选择投入较小的解决方案，针对该控件加一个class用来去掉内边距。目前看来是很正确的，但如果接二连三的从不同的问题上深入找到这个控件上，那就说明问题等级提升了，不应该仅仅是在每个调用控件的容器上添加该class。此时我们可以考虑其他方式，比如把所有容器内边距都设为0，而有针对性的对内部元素添加外边距，如果问题等级继续提升，还可以修改甚至替换控件，或者重构其他部分来适应该控件。总之就是要按问题等级选择解决问题的手段，这样的好处不仅仅是原先在精益中那样可以自动调节效率，还可以等样式需求更明确的时候作出相应的重构。\n\n由于CSS的描述性，使得它很自由，所以同一个需求，往往一百个开发者有一百种实现。在第一次碰到一个需求时，更是很难写出最佳实现，只能有针对性的写一个专属class把需要的属性扔进去。其实问题不在于此，而在于之后是否能在相同问题出现时重构原先的代码，根据所有相关问题写出更具普适性的class。有经验的UI Dev有时会通过经验来判断，直接写出这种class，Bootstrap这类框架就是这样的，但没有或较少经验的开发者就会产生疑惑。五个为什么的按比例投入原则可以很好的驱动CSS的开发，用深入的根本原因连接不同元素甚至不同页面上出现的问题，这样使我们能够安心的以目前的问题等级来组织代码，等到再次碰到问题并找到这里，才再次重构以解决问题。","slug":"five-whys-for-css","published":1,"date":"2015-06-19T16:00:00.000Z","updated":"2021-11-28T11:37:27.160Z","comments":1,"photos":[],"link":"","_id":"ckwj6551a0016vyjhg56w5tni","content":"<p>相信大多数人都有过关于CSS的痛苦经历，从我加入公司到现在，不到两年的时间里，听到最多CSS相关的讨论就是‘很难调’。所以我也一直在探究这其中有怎样的问题，为什么很多人觉得CSS很难写，如何才能让其他人更优雅的写CSS。在Code Review的时候，我渐渐的发现了问题所在，其实很多人已经掌握了丰富的CSS知识，但却不知道如何分组属性写成class。最后只好在需要改变样式的元素上随意起个名字做class然后把所有要写的属性丢进这个class里，如果优先级不够，再把前面的选择器都加上。结果就是CSS代码不断堆积，重复和冗余不断增多，维护也变得举步维艰。</p>\n<span id=\"more\"></span>\n\n<p>问题找到了，但如何解决呢，虽然我在项目组内做了几次分享，还经常在Code Review的时候提出一些问题，却还是收效甚微。有时候知道什么是正确的很容易，但知道如何才能做到正确却很难。直到最近，看了几本书之后，发现了一个很适合指导设计CSS的方法，那就是五个为什么或者叫五问法。五问法来自丰田的精益生产，后来自然衍生到了精益创业中，在DDD以及UX相关书籍中都会见到这个方法，其主旨是深入发觉大量现象的背后所隐藏的真正原因。乍一看它是一个管理方法，其实我觉得它是一种思维方式，即刨根问底的找到问题的根本原因并解决。所以被应用于各个领域，自然对于CSS所面临的问题也正恰如其分。</p>\n<h2 id=\"场景示例\"><a href=\"#场景示例\" class=\"headerlink\" title=\"场景示例\"></a>场景示例</h2><p>先来举个例子吧，某天Code Review发现了一条CSS代码是这样写的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.max-width &#123;</span><br><span class=\"line\">\tmax-width: 300px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由此产生了以下对话（纯属虚构）：</p>\n<blockquote>\n<p>UI Dev：“不应该这样写，这和直接写内联样式有什么区别呢？”</p>\n</blockquote>\n<blockquote>\n<p>Dev：“如果我不加最大宽度，页面上那个元素左边就会多出一部分，不然加个margin外边距可以吗？”</p>\n</blockquote>\n<blockquote>\n<p>UI Dev：“这个…我也不确定，我从没遇到过这样的问题，一定是哪里有问题。”</p>\n</blockquote>\n<blockquote>\n<p>Dev：“确实这样写也挺不好的，过一段时间就不知道这行代码什么意思了，也不敢修改它。但究竟应该如何写呢？”</p>\n</blockquote>\n<blockquote>\n<p>UI Dev：“呃，这样吧，我们来试试五个为什么，找找问题的根本原因。”</p>\n</blockquote>\n<blockquote>\n<p>Dev：“好啊，CSS的问题也困扰我好久了，能解决就最好了。”</p>\n</blockquote>\n<blockquote>\n<p>UI Dev：“首先问问，为什么要给元素加最大宽度呢？”</p>\n</blockquote>\n<blockquote>\n<p>Dev：“因为不加就就会多出一部分呀。”</p>\n</blockquote>\n<blockquote>\n<p>UI Dev：“那为什么这个元素会多一部分呢？”</p>\n</blockquote>\n<blockquote>\n<p>Dev：“因为没加最大宽度，开个玩笑，别生气，其实我也不确定，不过用DevTools看了一下，好像它的父元素的宽度也不对。”</p>\n</blockquote>\n<blockquote>\n<p>UI Dev：“已经接近了，为什么父元素的宽度不对？”</p>\n</blockquote>\n<blockquote>\n<p>Dev：“因为父元素的内边距两边不一样。”</p>\n</blockquote>\n<blockquote>\n<p>UI Dev：“为什么父元素的内边距不一致？”</p>\n</blockquote>\n<blockquote>\n<p>Dev：“啊，我知道了，原来为父元素的父元素写了一个last的伪选择器，它是用来把padding-right设为0的，因为父元素现在正好是最后一个，所以被影响了。”</p>\n</blockquote>\n<blockquote>\n<p>UI Dev：“别急，为什么要把最后一个元素的padding-right设为0？”</p>\n</blockquote>\n<blockquote>\n<p>Dev：“因为原先最后面的那个元素里面是一个无法修改样式的控件，需要把padding-right设为0才能放得下。”</p>\n</blockquote>\n<blockquote>\n<p>UI Dev：“所以这才是问题所在，我们的意图是给空间的容器加上padding-right为0的属性对吗？而不是给最后一个元素加，所以应该写一个class，也许叫做‘widget-container’之类的，放在那个容器上，然后把last伪选择器删掉，如此一切就正常了。原先出问题的地方其实是没问题的。”</p>\n</blockquote>\n<blockquote>\n<p>Dev：“原来是这样，太好了，我学到了，样式出问题的地方不一定是代码有问题的地方，五个为什么太有用了。”</p>\n</blockquote>\n<p>这样反复问多次“为什么”可以让我们找到问题的根本所在，如果仅仅从表面现象去解决问题很可能导致南辕北辙的后果。而且在例子中的last伪选择器就是因为没有找到根本原因而简单粗暴的写了这样一行代码而导致的。这个例子还很好的展现了五个为什么对于CSS的益处，不仅是找到问题的根本原因，还使得我们在写CSS的时候意图更加明确。如此一来，class命名难的问题也迎刃而解，padding-right应该为的0的元素是那个控件的容器，所以很容易想出“widget-container”这样的名字，因为通过五个为什么的方法找到了真正的意图，此时，class叫什么和应该放在哪都是水到渠成了。</p>\n<h2 id=\"按比例投入\"><a href=\"#按比例投入\" class=\"headerlink\" title=\"按比例投入\"></a>按比例投入</h2><p>但有时候我们所面对的项目不会这么善良，“为什么”的层级越多，说明CSS的关系也越复杂，所以现在我们来谈谈五个为什么中的一个重要原则，按比例投入。其主旨是小问题小投入，大问题大投入，问题等级越高，投入也应该越大。在CSS中来讲，就是当发现样式异常时，使用五个为什么深入找到的根本原因所在之处的重复次数越多，说明问题越严重，对问题的解决方案也应投入的更多。</p>\n<p>再回到上面的例子中，通过一个元素位置异常的问题，找到根本原因来自一个控件需要内边距为0的容器元素，由于第一次发现，所以选择投入较小的解决方案，针对该控件加一个class用来去掉内边距。目前看来是很正确的，但如果接二连三的从不同的问题上深入找到这个控件上，那就说明问题等级提升了，不应该仅仅是在每个调用控件的容器上添加该class。此时我们可以考虑其他方式，比如把所有容器内边距都设为0，而有针对性的对内部元素添加外边距，如果问题等级继续提升，还可以修改甚至替换控件，或者重构其他部分来适应该控件。总之就是要按问题等级选择解决问题的手段，这样的好处不仅仅是原先在精益中那样可以自动调节效率，还可以等样式需求更明确的时候作出相应的重构。</p>\n<p>由于CSS的描述性，使得它很自由，所以同一个需求，往往一百个开发者有一百种实现。在第一次碰到一个需求时，更是很难写出最佳实现，只能有针对性的写一个专属class把需要的属性扔进去。其实问题不在于此，而在于之后是否能在相同问题出现时重构原先的代码，根据所有相关问题写出更具普适性的class。有经验的UI Dev有时会通过经验来判断，直接写出这种class，Bootstrap这类框架就是这样的，但没有或较少经验的开发者就会产生疑惑。五个为什么的按比例投入原则可以很好的驱动CSS的开发，用深入的根本原因连接不同元素甚至不同页面上出现的问题，这样使我们能够安心的以目前的问题等级来组织代码，等到再次碰到问题并找到这里，才再次重构以解决问题。</p>\n","site":{"data":{}},"excerpt":"<p>相信大多数人都有过关于CSS的痛苦经历，从我加入公司到现在，不到两年的时间里，听到最多CSS相关的讨论就是‘很难调’。所以我也一直在探究这其中有怎样的问题，为什么很多人觉得CSS很难写，如何才能让其他人更优雅的写CSS。在Code Review的时候，我渐渐的发现了问题所在，其实很多人已经掌握了丰富的CSS知识，但却不知道如何分组属性写成class。最后只好在需要改变样式的元素上随意起个名字做class然后把所有要写的属性丢进这个class里，如果优先级不够，再把前面的选择器都加上。结果就是CSS代码不断堆积，重复和冗余不断增多，维护也变得举步维艰。</p>","more":"<p>问题找到了，但如何解决呢，虽然我在项目组内做了几次分享，还经常在Code Review的时候提出一些问题，却还是收效甚微。有时候知道什么是正确的很容易，但知道如何才能做到正确却很难。直到最近，看了几本书之后，发现了一个很适合指导设计CSS的方法，那就是五个为什么或者叫五问法。五问法来自丰田的精益生产，后来自然衍生到了精益创业中，在DDD以及UX相关书籍中都会见到这个方法，其主旨是深入发觉大量现象的背后所隐藏的真正原因。乍一看它是一个管理方法，其实我觉得它是一种思维方式，即刨根问底的找到问题的根本原因并解决。所以被应用于各个领域，自然对于CSS所面临的问题也正恰如其分。</p>\n<h2 id=\"场景示例\"><a href=\"#场景示例\" class=\"headerlink\" title=\"场景示例\"></a>场景示例</h2><p>先来举个例子吧，某天Code Review发现了一条CSS代码是这样写的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.max-width &#123;</span><br><span class=\"line\">\tmax-width: 300px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由此产生了以下对话（纯属虚构）：</p>\n<blockquote>\n<p>UI Dev：“不应该这样写，这和直接写内联样式有什么区别呢？”</p>\n</blockquote>\n<blockquote>\n<p>Dev：“如果我不加最大宽度，页面上那个元素左边就会多出一部分，不然加个margin外边距可以吗？”</p>\n</blockquote>\n<blockquote>\n<p>UI Dev：“这个…我也不确定，我从没遇到过这样的问题，一定是哪里有问题。”</p>\n</blockquote>\n<blockquote>\n<p>Dev：“确实这样写也挺不好的，过一段时间就不知道这行代码什么意思了，也不敢修改它。但究竟应该如何写呢？”</p>\n</blockquote>\n<blockquote>\n<p>UI Dev：“呃，这样吧，我们来试试五个为什么，找找问题的根本原因。”</p>\n</blockquote>\n<blockquote>\n<p>Dev：“好啊，CSS的问题也困扰我好久了，能解决就最好了。”</p>\n</blockquote>\n<blockquote>\n<p>UI Dev：“首先问问，为什么要给元素加最大宽度呢？”</p>\n</blockquote>\n<blockquote>\n<p>Dev：“因为不加就就会多出一部分呀。”</p>\n</blockquote>\n<blockquote>\n<p>UI Dev：“那为什么这个元素会多一部分呢？”</p>\n</blockquote>\n<blockquote>\n<p>Dev：“因为没加最大宽度，开个玩笑，别生气，其实我也不确定，不过用DevTools看了一下，好像它的父元素的宽度也不对。”</p>\n</blockquote>\n<blockquote>\n<p>UI Dev：“已经接近了，为什么父元素的宽度不对？”</p>\n</blockquote>\n<blockquote>\n<p>Dev：“因为父元素的内边距两边不一样。”</p>\n</blockquote>\n<blockquote>\n<p>UI Dev：“为什么父元素的内边距不一致？”</p>\n</blockquote>\n<blockquote>\n<p>Dev：“啊，我知道了，原来为父元素的父元素写了一个last的伪选择器，它是用来把padding-right设为0的，因为父元素现在正好是最后一个，所以被影响了。”</p>\n</blockquote>\n<blockquote>\n<p>UI Dev：“别急，为什么要把最后一个元素的padding-right设为0？”</p>\n</blockquote>\n<blockquote>\n<p>Dev：“因为原先最后面的那个元素里面是一个无法修改样式的控件，需要把padding-right设为0才能放得下。”</p>\n</blockquote>\n<blockquote>\n<p>UI Dev：“所以这才是问题所在，我们的意图是给空间的容器加上padding-right为0的属性对吗？而不是给最后一个元素加，所以应该写一个class，也许叫做‘widget-container’之类的，放在那个容器上，然后把last伪选择器删掉，如此一切就正常了。原先出问题的地方其实是没问题的。”</p>\n</blockquote>\n<blockquote>\n<p>Dev：“原来是这样，太好了，我学到了，样式出问题的地方不一定是代码有问题的地方，五个为什么太有用了。”</p>\n</blockquote>\n<p>这样反复问多次“为什么”可以让我们找到问题的根本所在，如果仅仅从表面现象去解决问题很可能导致南辕北辙的后果。而且在例子中的last伪选择器就是因为没有找到根本原因而简单粗暴的写了这样一行代码而导致的。这个例子还很好的展现了五个为什么对于CSS的益处，不仅是找到问题的根本原因，还使得我们在写CSS的时候意图更加明确。如此一来，class命名难的问题也迎刃而解，padding-right应该为的0的元素是那个控件的容器，所以很容易想出“widget-container”这样的名字，因为通过五个为什么的方法找到了真正的意图，此时，class叫什么和应该放在哪都是水到渠成了。</p>\n<h2 id=\"按比例投入\"><a href=\"#按比例投入\" class=\"headerlink\" title=\"按比例投入\"></a>按比例投入</h2><p>但有时候我们所面对的项目不会这么善良，“为什么”的层级越多，说明CSS的关系也越复杂，所以现在我们来谈谈五个为什么中的一个重要原则，按比例投入。其主旨是小问题小投入，大问题大投入，问题等级越高，投入也应该越大。在CSS中来讲，就是当发现样式异常时，使用五个为什么深入找到的根本原因所在之处的重复次数越多，说明问题越严重，对问题的解决方案也应投入的更多。</p>\n<p>再回到上面的例子中，通过一个元素位置异常的问题，找到根本原因来自一个控件需要内边距为0的容器元素，由于第一次发现，所以选择投入较小的解决方案，针对该控件加一个class用来去掉内边距。目前看来是很正确的，但如果接二连三的从不同的问题上深入找到这个控件上，那就说明问题等级提升了，不应该仅仅是在每个调用控件的容器上添加该class。此时我们可以考虑其他方式，比如把所有容器内边距都设为0，而有针对性的对内部元素添加外边距，如果问题等级继续提升，还可以修改甚至替换控件，或者重构其他部分来适应该控件。总之就是要按问题等级选择解决问题的手段，这样的好处不仅仅是原先在精益中那样可以自动调节效率，还可以等样式需求更明确的时候作出相应的重构。</p>\n<p>由于CSS的描述性，使得它很自由，所以同一个需求，往往一百个开发者有一百种实现。在第一次碰到一个需求时，更是很难写出最佳实现，只能有针对性的写一个专属class把需要的属性扔进去。其实问题不在于此，而在于之后是否能在相同问题出现时重构原先的代码，根据所有相关问题写出更具普适性的class。有经验的UI Dev有时会通过经验来判断，直接写出这种class，Bootstrap这类框架就是这样的，但没有或较少经验的开发者就会产生疑惑。五个为什么的按比例投入原则可以很好的驱动CSS的开发，用深入的根本原因连接不同元素甚至不同页面上出现的问题，这样使我们能够安心的以目前的问题等级来组织代码，等到再次碰到问题并找到这里，才再次重构以解决问题。</p>"},{"layout":"post","title":"翻译《Pro AngularJS》","_content":"\n![Pro AngularJS](/images/pro-angularjs.png)\n\n从去年春天就开始翻译这本《Pro AngularJS》，前前后后将近1年半总算是正式出版。从最初的兴奋，到期间的苦逼，最后拿到样书，还是很满足的。这本书由浅入深的详细介绍了AngularJS的各种功能和原理，以及大量示例贯穿全书，开头甚至还有一些JavaScript的基础。原书一共600多页，我和同事各翻译了300多页，我主要是翻译的关于Services的第三部分以及第一部分的后几章。\n\n总的来说收获很多，对AngularJS有了更深入的理解，虽然书中使用的AngularJS版本已经比较旧了，但是对很多方法的使用以及原理的解读还是非常不错的。并且英语阅读能力也感到有明显提升，许多长句子一开始完全不知所云，花了好几个小时通过上下文和代码才慢慢理解其中深意。当然就翻译本来说，也是有许多感想，所以才写了这篇文章总结一下翻译一本书所需要注意的地方。\n\n<!-- more -->\n\n### 格式\n\n其实Markdown在今天已经十分的成熟，就像本文一样，直接使用编辑器就可以书写，还可以添加各种CSS样式。但是翻译时我还是选择了Word来编辑文本，而且由于Mac上没有购买正版，我只能用虚拟机在Windows中使用WPS免费版来编辑。费这么多功夫是为什么呢，原因很简单，出版社的编辑用的是Word，你没法指望他们使用CSS去编辑样式出版书籍。所以痛苦的格式修改开始了。\n\n在最初开始翻译的时候，几乎一半的时间都花在了格式上。其实最后是有编辑来调整格式的，作为译者不需要做什么特别修改。但有一个小问题，如果你全部都使用正文的话，哪些标题是同级的，哪些标题是不同级的，完全就搞不清楚了，就算加个粗什么也会由于前后记忆偏差而导致乱掉，甚至目录都无法生成。所以首先要做的不是把这些文本调整成什么样式，而是把他们调整成不同的区分开来。\n\n比如我后来设置了标题1、标题2、标题3、标题4、正文、代码、特别、警告等类型的文本，然后需要用什么就点一下。之后翻译的进度就大大提升了，并不需要特别在意当前的样式，只是区分，如此以后只要修改对应类型的格式就可以把全文的格式都修改了。\n\n### 翻译\n\n说到翻译，最难的其实不是英语水平问题，而是技术水平，这就是为什么技术书籍的翻译要找技术人员来做，而不是专业翻译人员。如果只是按照字面来翻，看上去可能和作者的话相一致，但技术层面可能会出现误解之类的地方，所以一定要作为技术人员去解读，把代码也看一遍，弄懂作者的意图再来翻译文本就会好很多。比如原书中这一句话：\n\n> These are an artifact of\nAngularJS processing the elements and resolving data bindings.\n\n其中的`artifact`的字面意思是人工制品，但是这句话要是翻成“AngularJS有人工制品处理元素并解决数据绑定”，感觉太奇怪了。所以我查了许多字典，发现这个词不仅有人工制品的意思，还有古文物的意思，所以它真正的意思是器具。然后我又看了看上下文和相关代码，这里作者要表达的意思是AngularJS已经有了能处理那些的东西，开发者不需要管这些，所以它们应该是特别好用的一个“器”。最终我把Artifact翻译成了“神器”，自认为还是比较贴切的。\n\n通过上面的例子，说明翻译不仅需要英语水平，还需要技术的理解。所以我的意思是说，还是需要英语水平的，确实两者缺一不可。所以再来看一个长句子：\n\n> The benefit of using this technique is that it allows you to\nlimit the scope of controller functionality to the part of the application where it will be used, which makes it easier to\nperform good unit tests (as described in Chapter 25) and prevents unexpected dependencies between components in\nthe application.\n\n里面包含了that、where、which各种从句，所以断句是很重要的，把逗号和which后面的部分断开，来看看前面的这句。首先有一个benefit，意思是这个好处就是（is that）后面这句话，而后面这句话断开后剩下“limit the scope of controller functionality to the part of the application”，再加上前面的部分，和where所带的部分，翻译后就是“使用该技术的好处是|它让你可以|将控制器的作用域的功能限制在应用程序中|使用它的那部分上”。\n\n接着应该调整一下后面那部分的顺序，按中文习惯断句，就成了“使用该技术的好处是，它可以让你将控制器作用域的功能限制在应用程序的一部分中，就是使用该功能的那部分。”\n\n最后，我觉得翻译最重要的就是，说人话。如果生搬硬套的把英文翻译成中文，但失去了原有的意思，那将是致命的，所以一定要语法通畅和语义明确。\n\n### 注解\n\n有一种东西叫译者注，是翻译者自己的话。所以很多时候我们看到书中的译者注成了译者的吐槽弹幕，有翻译不了的注一下，有专有名词注一下，甚至原文有错也注一下，这都是或多或少的滥用了译者注。最开始我也是这样使用，但后面校对的时候，我以一个读者的思维看了一遍，感觉译者注基本都是废话，大大的破坏了原书的感觉。\n\n比如翻译方面的解释，其实这说明译文有问题，应该优化译文，让其表达的更清楚，而无需注解。\n\n专有名词也不需要解释，读者不是小白，书籍所面向的人群是否可以理解该专有名词，不是译者该考虑的问题，如果作者认为有必要解释，原文就会有解释，译者只需要翻译就行了，如果没有，说明作者认为读者应该理解，就不该解释。\n\n原文有错与否也不是译者该操心的，如果是明显的印刷错误，可以翻译为正确的，然后注解一下或不注解。如果是其他层面的错误，就应该翻译成错的，况且我也不认为译者可以100%保证那就是错误的。\n\n但究竟什么时候应该使用译者注呢？我认为只有在翻译之后会产生问题的地方才该使用译者注。举个典型的例子，在译文中有这样一段话：\n\n> 迷惑的是，AngularJS所提供的内置过滤器叫作filter。\n\n读者真的迷惑了，迷惑的到底是什么？从中文来看没什么迷惑的地方。所以我们再看看原文：\n\n> One of the built-in filters that AngularJS provides is called, confusingly, filter.\n\n明显看出了问题，过滤器的英文就是filter，所以在英文中这句话看着很奇怪，好比在中文里说，AngularJS所提供的过滤器叫做过滤器。所以直接翻译过来时，中文读者反而会迷惑，此时译者注就可以光明正大的出来解释一下了。\n\n### 协作\n\n这次的翻译过程最有意思的就是合译了，因为有协作的部分。虽然我们是分开翻译，但是还是有很多地方需要协作。比如最常见的就是专有名词翻译的统一性问题，就算是自己一个人翻都有可能前后出现偏差，何况是两人呢。\n\n由于我在HTML中文兴趣组参与过几次翻译工作，所以知道这个问题，一开始我就在Github建立了一个单词对照表（[glossary](https://github.com/tychio/glossary/blob/master/JavaScript/AngularJS.md)）用来维护专有名词对照表。要特别注意的是，每个对照单位都应该是专有的，特别的，可能是词组也可能是单词，或者也可能是语团，但绝不能用其中的任意两项来组合使用，它们都应该是独立的。\n\n无论如何，第一次翻译书籍，肯定有很多不足之处，但也收获了大量的经验，如果还有下一次的机会，希望能做的更好。总结这些，也希望能帮到其他人，无论是翻译书籍还是文档，以一个读者的心就做应该会有所收获。\n\n","source":"_posts/2015-09-01-translate-pro-angularjs.md","raw":"---\nlayout: post\ntitle: 翻译《Pro AngularJS》\ntags: [translate, angularjs, javascript]\ncategory: Work\n---\n\n![Pro AngularJS](/images/pro-angularjs.png)\n\n从去年春天就开始翻译这本《Pro AngularJS》，前前后后将近1年半总算是正式出版。从最初的兴奋，到期间的苦逼，最后拿到样书，还是很满足的。这本书由浅入深的详细介绍了AngularJS的各种功能和原理，以及大量示例贯穿全书，开头甚至还有一些JavaScript的基础。原书一共600多页，我和同事各翻译了300多页，我主要是翻译的关于Services的第三部分以及第一部分的后几章。\n\n总的来说收获很多，对AngularJS有了更深入的理解，虽然书中使用的AngularJS版本已经比较旧了，但是对很多方法的使用以及原理的解读还是非常不错的。并且英语阅读能力也感到有明显提升，许多长句子一开始完全不知所云，花了好几个小时通过上下文和代码才慢慢理解其中深意。当然就翻译本来说，也是有许多感想，所以才写了这篇文章总结一下翻译一本书所需要注意的地方。\n\n<!-- more -->\n\n### 格式\n\n其实Markdown在今天已经十分的成熟，就像本文一样，直接使用编辑器就可以书写，还可以添加各种CSS样式。但是翻译时我还是选择了Word来编辑文本，而且由于Mac上没有购买正版，我只能用虚拟机在Windows中使用WPS免费版来编辑。费这么多功夫是为什么呢，原因很简单，出版社的编辑用的是Word，你没法指望他们使用CSS去编辑样式出版书籍。所以痛苦的格式修改开始了。\n\n在最初开始翻译的时候，几乎一半的时间都花在了格式上。其实最后是有编辑来调整格式的，作为译者不需要做什么特别修改。但有一个小问题，如果你全部都使用正文的话，哪些标题是同级的，哪些标题是不同级的，完全就搞不清楚了，就算加个粗什么也会由于前后记忆偏差而导致乱掉，甚至目录都无法生成。所以首先要做的不是把这些文本调整成什么样式，而是把他们调整成不同的区分开来。\n\n比如我后来设置了标题1、标题2、标题3、标题4、正文、代码、特别、警告等类型的文本，然后需要用什么就点一下。之后翻译的进度就大大提升了，并不需要特别在意当前的样式，只是区分，如此以后只要修改对应类型的格式就可以把全文的格式都修改了。\n\n### 翻译\n\n说到翻译，最难的其实不是英语水平问题，而是技术水平，这就是为什么技术书籍的翻译要找技术人员来做，而不是专业翻译人员。如果只是按照字面来翻，看上去可能和作者的话相一致，但技术层面可能会出现误解之类的地方，所以一定要作为技术人员去解读，把代码也看一遍，弄懂作者的意图再来翻译文本就会好很多。比如原书中这一句话：\n\n> These are an artifact of\nAngularJS processing the elements and resolving data bindings.\n\n其中的`artifact`的字面意思是人工制品，但是这句话要是翻成“AngularJS有人工制品处理元素并解决数据绑定”，感觉太奇怪了。所以我查了许多字典，发现这个词不仅有人工制品的意思，还有古文物的意思，所以它真正的意思是器具。然后我又看了看上下文和相关代码，这里作者要表达的意思是AngularJS已经有了能处理那些的东西，开发者不需要管这些，所以它们应该是特别好用的一个“器”。最终我把Artifact翻译成了“神器”，自认为还是比较贴切的。\n\n通过上面的例子，说明翻译不仅需要英语水平，还需要技术的理解。所以我的意思是说，还是需要英语水平的，确实两者缺一不可。所以再来看一个长句子：\n\n> The benefit of using this technique is that it allows you to\nlimit the scope of controller functionality to the part of the application where it will be used, which makes it easier to\nperform good unit tests (as described in Chapter 25) and prevents unexpected dependencies between components in\nthe application.\n\n里面包含了that、where、which各种从句，所以断句是很重要的，把逗号和which后面的部分断开，来看看前面的这句。首先有一个benefit，意思是这个好处就是（is that）后面这句话，而后面这句话断开后剩下“limit the scope of controller functionality to the part of the application”，再加上前面的部分，和where所带的部分，翻译后就是“使用该技术的好处是|它让你可以|将控制器的作用域的功能限制在应用程序中|使用它的那部分上”。\n\n接着应该调整一下后面那部分的顺序，按中文习惯断句，就成了“使用该技术的好处是，它可以让你将控制器作用域的功能限制在应用程序的一部分中，就是使用该功能的那部分。”\n\n最后，我觉得翻译最重要的就是，说人话。如果生搬硬套的把英文翻译成中文，但失去了原有的意思，那将是致命的，所以一定要语法通畅和语义明确。\n\n### 注解\n\n有一种东西叫译者注，是翻译者自己的话。所以很多时候我们看到书中的译者注成了译者的吐槽弹幕，有翻译不了的注一下，有专有名词注一下，甚至原文有错也注一下，这都是或多或少的滥用了译者注。最开始我也是这样使用，但后面校对的时候，我以一个读者的思维看了一遍，感觉译者注基本都是废话，大大的破坏了原书的感觉。\n\n比如翻译方面的解释，其实这说明译文有问题，应该优化译文，让其表达的更清楚，而无需注解。\n\n专有名词也不需要解释，读者不是小白，书籍所面向的人群是否可以理解该专有名词，不是译者该考虑的问题，如果作者认为有必要解释，原文就会有解释，译者只需要翻译就行了，如果没有，说明作者认为读者应该理解，就不该解释。\n\n原文有错与否也不是译者该操心的，如果是明显的印刷错误，可以翻译为正确的，然后注解一下或不注解。如果是其他层面的错误，就应该翻译成错的，况且我也不认为译者可以100%保证那就是错误的。\n\n但究竟什么时候应该使用译者注呢？我认为只有在翻译之后会产生问题的地方才该使用译者注。举个典型的例子，在译文中有这样一段话：\n\n> 迷惑的是，AngularJS所提供的内置过滤器叫作filter。\n\n读者真的迷惑了，迷惑的到底是什么？从中文来看没什么迷惑的地方。所以我们再看看原文：\n\n> One of the built-in filters that AngularJS provides is called, confusingly, filter.\n\n明显看出了问题，过滤器的英文就是filter，所以在英文中这句话看着很奇怪，好比在中文里说，AngularJS所提供的过滤器叫做过滤器。所以直接翻译过来时，中文读者反而会迷惑，此时译者注就可以光明正大的出来解释一下了。\n\n### 协作\n\n这次的翻译过程最有意思的就是合译了，因为有协作的部分。虽然我们是分开翻译，但是还是有很多地方需要协作。比如最常见的就是专有名词翻译的统一性问题，就算是自己一个人翻都有可能前后出现偏差，何况是两人呢。\n\n由于我在HTML中文兴趣组参与过几次翻译工作，所以知道这个问题，一开始我就在Github建立了一个单词对照表（[glossary](https://github.com/tychio/glossary/blob/master/JavaScript/AngularJS.md)）用来维护专有名词对照表。要特别注意的是，每个对照单位都应该是专有的，特别的，可能是词组也可能是单词，或者也可能是语团，但绝不能用其中的任意两项来组合使用，它们都应该是独立的。\n\n无论如何，第一次翻译书籍，肯定有很多不足之处，但也收获了大量的经验，如果还有下一次的机会，希望能做的更好。总结这些，也希望能帮到其他人，无论是翻译书籍还是文档，以一个读者的心就做应该会有所收获。\n\n","slug":"translate-pro-angularjs","published":1,"date":"2015-08-31T16:00:00.000Z","updated":"2021-11-28T11:59:29.970Z","_id":"ckwj6551b0018vyjhda56gq96","comments":1,"photos":[],"link":"","content":"<p><img src=\"/images/pro-angularjs.png\" alt=\"Pro AngularJS\"></p>\n<p>从去年春天就开始翻译这本《Pro AngularJS》，前前后后将近1年半总算是正式出版。从最初的兴奋，到期间的苦逼，最后拿到样书，还是很满足的。这本书由浅入深的详细介绍了AngularJS的各种功能和原理，以及大量示例贯穿全书，开头甚至还有一些JavaScript的基础。原书一共600多页，我和同事各翻译了300多页，我主要是翻译的关于Services的第三部分以及第一部分的后几章。</p>\n<p>总的来说收获很多，对AngularJS有了更深入的理解，虽然书中使用的AngularJS版本已经比较旧了，但是对很多方法的使用以及原理的解读还是非常不错的。并且英语阅读能力也感到有明显提升，许多长句子一开始完全不知所云，花了好几个小时通过上下文和代码才慢慢理解其中深意。当然就翻译本来说，也是有许多感想，所以才写了这篇文章总结一下翻译一本书所需要注意的地方。</p>\n<span id=\"more\"></span>\n\n<h3 id=\"格式\"><a href=\"#格式\" class=\"headerlink\" title=\"格式\"></a>格式</h3><p>其实Markdown在今天已经十分的成熟，就像本文一样，直接使用编辑器就可以书写，还可以添加各种CSS样式。但是翻译时我还是选择了Word来编辑文本，而且由于Mac上没有购买正版，我只能用虚拟机在Windows中使用WPS免费版来编辑。费这么多功夫是为什么呢，原因很简单，出版社的编辑用的是Word，你没法指望他们使用CSS去编辑样式出版书籍。所以痛苦的格式修改开始了。</p>\n<p>在最初开始翻译的时候，几乎一半的时间都花在了格式上。其实最后是有编辑来调整格式的，作为译者不需要做什么特别修改。但有一个小问题，如果你全部都使用正文的话，哪些标题是同级的，哪些标题是不同级的，完全就搞不清楚了，就算加个粗什么也会由于前后记忆偏差而导致乱掉，甚至目录都无法生成。所以首先要做的不是把这些文本调整成什么样式，而是把他们调整成不同的区分开来。</p>\n<p>比如我后来设置了标题1、标题2、标题3、标题4、正文、代码、特别、警告等类型的文本，然后需要用什么就点一下。之后翻译的进度就大大提升了，并不需要特别在意当前的样式，只是区分，如此以后只要修改对应类型的格式就可以把全文的格式都修改了。</p>\n<h3 id=\"翻译\"><a href=\"#翻译\" class=\"headerlink\" title=\"翻译\"></a>翻译</h3><p>说到翻译，最难的其实不是英语水平问题，而是技术水平，这就是为什么技术书籍的翻译要找技术人员来做，而不是专业翻译人员。如果只是按照字面来翻，看上去可能和作者的话相一致，但技术层面可能会出现误解之类的地方，所以一定要作为技术人员去解读，把代码也看一遍，弄懂作者的意图再来翻译文本就会好很多。比如原书中这一句话：</p>\n<blockquote>\n<p>These are an artifact of<br>AngularJS processing the elements and resolving data bindings.</p>\n</blockquote>\n<p>其中的<code>artifact</code>的字面意思是人工制品，但是这句话要是翻成“AngularJS有人工制品处理元素并解决数据绑定”，感觉太奇怪了。所以我查了许多字典，发现这个词不仅有人工制品的意思，还有古文物的意思，所以它真正的意思是器具。然后我又看了看上下文和相关代码，这里作者要表达的意思是AngularJS已经有了能处理那些的东西，开发者不需要管这些，所以它们应该是特别好用的一个“器”。最终我把Artifact翻译成了“神器”，自认为还是比较贴切的。</p>\n<p>通过上面的例子，说明翻译不仅需要英语水平，还需要技术的理解。所以我的意思是说，还是需要英语水平的，确实两者缺一不可。所以再来看一个长句子：</p>\n<blockquote>\n<p>The benefit of using this technique is that it allows you to<br>limit the scope of controller functionality to the part of the application where it will be used, which makes it easier to<br>perform good unit tests (as described in Chapter 25) and prevents unexpected dependencies between components in<br>the application.</p>\n</blockquote>\n<p>里面包含了that、where、which各种从句，所以断句是很重要的，把逗号和which后面的部分断开，来看看前面的这句。首先有一个benefit，意思是这个好处就是（is that）后面这句话，而后面这句话断开后剩下“limit the scope of controller functionality to the part of the application”，再加上前面的部分，和where所带的部分，翻译后就是“使用该技术的好处是|它让你可以|将控制器的作用域的功能限制在应用程序中|使用它的那部分上”。</p>\n<p>接着应该调整一下后面那部分的顺序，按中文习惯断句，就成了“使用该技术的好处是，它可以让你将控制器作用域的功能限制在应用程序的一部分中，就是使用该功能的那部分。”</p>\n<p>最后，我觉得翻译最重要的就是，说人话。如果生搬硬套的把英文翻译成中文，但失去了原有的意思，那将是致命的，所以一定要语法通畅和语义明确。</p>\n<h3 id=\"注解\"><a href=\"#注解\" class=\"headerlink\" title=\"注解\"></a>注解</h3><p>有一种东西叫译者注，是翻译者自己的话。所以很多时候我们看到书中的译者注成了译者的吐槽弹幕，有翻译不了的注一下，有专有名词注一下，甚至原文有错也注一下，这都是或多或少的滥用了译者注。最开始我也是这样使用，但后面校对的时候，我以一个读者的思维看了一遍，感觉译者注基本都是废话，大大的破坏了原书的感觉。</p>\n<p>比如翻译方面的解释，其实这说明译文有问题，应该优化译文，让其表达的更清楚，而无需注解。</p>\n<p>专有名词也不需要解释，读者不是小白，书籍所面向的人群是否可以理解该专有名词，不是译者该考虑的问题，如果作者认为有必要解释，原文就会有解释，译者只需要翻译就行了，如果没有，说明作者认为读者应该理解，就不该解释。</p>\n<p>原文有错与否也不是译者该操心的，如果是明显的印刷错误，可以翻译为正确的，然后注解一下或不注解。如果是其他层面的错误，就应该翻译成错的，况且我也不认为译者可以100%保证那就是错误的。</p>\n<p>但究竟什么时候应该使用译者注呢？我认为只有在翻译之后会产生问题的地方才该使用译者注。举个典型的例子，在译文中有这样一段话：</p>\n<blockquote>\n<p>迷惑的是，AngularJS所提供的内置过滤器叫作filter。</p>\n</blockquote>\n<p>读者真的迷惑了，迷惑的到底是什么？从中文来看没什么迷惑的地方。所以我们再看看原文：</p>\n<blockquote>\n<p>One of the built-in filters that AngularJS provides is called, confusingly, filter.</p>\n</blockquote>\n<p>明显看出了问题，过滤器的英文就是filter，所以在英文中这句话看着很奇怪，好比在中文里说，AngularJS所提供的过滤器叫做过滤器。所以直接翻译过来时，中文读者反而会迷惑，此时译者注就可以光明正大的出来解释一下了。</p>\n<h3 id=\"协作\"><a href=\"#协作\" class=\"headerlink\" title=\"协作\"></a>协作</h3><p>这次的翻译过程最有意思的就是合译了，因为有协作的部分。虽然我们是分开翻译，但是还是有很多地方需要协作。比如最常见的就是专有名词翻译的统一性问题，就算是自己一个人翻都有可能前后出现偏差，何况是两人呢。</p>\n<p>由于我在HTML中文兴趣组参与过几次翻译工作，所以知道这个问题，一开始我就在Github建立了一个单词对照表（<a href=\"https://github.com/tychio/glossary/blob/master/JavaScript/AngularJS.md\">glossary</a>）用来维护专有名词对照表。要特别注意的是，每个对照单位都应该是专有的，特别的，可能是词组也可能是单词，或者也可能是语团，但绝不能用其中的任意两项来组合使用，它们都应该是独立的。</p>\n<p>无论如何，第一次翻译书籍，肯定有很多不足之处，但也收获了大量的经验，如果还有下一次的机会，希望能做的更好。总结这些，也希望能帮到其他人，无论是翻译书籍还是文档，以一个读者的心就做应该会有所收获。</p>\n","site":{"data":{}},"excerpt":"<p><img src=\"/images/pro-angularjs.png\" alt=\"Pro AngularJS\"></p>\n<p>从去年春天就开始翻译这本《Pro AngularJS》，前前后后将近1年半总算是正式出版。从最初的兴奋，到期间的苦逼，最后拿到样书，还是很满足的。这本书由浅入深的详细介绍了AngularJS的各种功能和原理，以及大量示例贯穿全书，开头甚至还有一些JavaScript的基础。原书一共600多页，我和同事各翻译了300多页，我主要是翻译的关于Services的第三部分以及第一部分的后几章。</p>\n<p>总的来说收获很多，对AngularJS有了更深入的理解，虽然书中使用的AngularJS版本已经比较旧了，但是对很多方法的使用以及原理的解读还是非常不错的。并且英语阅读能力也感到有明显提升，许多长句子一开始完全不知所云，花了好几个小时通过上下文和代码才慢慢理解其中深意。当然就翻译本来说，也是有许多感想，所以才写了这篇文章总结一下翻译一本书所需要注意的地方。</p>","more":"<h3 id=\"格式\"><a href=\"#格式\" class=\"headerlink\" title=\"格式\"></a>格式</h3><p>其实Markdown在今天已经十分的成熟，就像本文一样，直接使用编辑器就可以书写，还可以添加各种CSS样式。但是翻译时我还是选择了Word来编辑文本，而且由于Mac上没有购买正版，我只能用虚拟机在Windows中使用WPS免费版来编辑。费这么多功夫是为什么呢，原因很简单，出版社的编辑用的是Word，你没法指望他们使用CSS去编辑样式出版书籍。所以痛苦的格式修改开始了。</p>\n<p>在最初开始翻译的时候，几乎一半的时间都花在了格式上。其实最后是有编辑来调整格式的，作为译者不需要做什么特别修改。但有一个小问题，如果你全部都使用正文的话，哪些标题是同级的，哪些标题是不同级的，完全就搞不清楚了，就算加个粗什么也会由于前后记忆偏差而导致乱掉，甚至目录都无法生成。所以首先要做的不是把这些文本调整成什么样式，而是把他们调整成不同的区分开来。</p>\n<p>比如我后来设置了标题1、标题2、标题3、标题4、正文、代码、特别、警告等类型的文本，然后需要用什么就点一下。之后翻译的进度就大大提升了，并不需要特别在意当前的样式，只是区分，如此以后只要修改对应类型的格式就可以把全文的格式都修改了。</p>\n<h3 id=\"翻译\"><a href=\"#翻译\" class=\"headerlink\" title=\"翻译\"></a>翻译</h3><p>说到翻译，最难的其实不是英语水平问题，而是技术水平，这就是为什么技术书籍的翻译要找技术人员来做，而不是专业翻译人员。如果只是按照字面来翻，看上去可能和作者的话相一致，但技术层面可能会出现误解之类的地方，所以一定要作为技术人员去解读，把代码也看一遍，弄懂作者的意图再来翻译文本就会好很多。比如原书中这一句话：</p>\n<blockquote>\n<p>These are an artifact of<br>AngularJS processing the elements and resolving data bindings.</p>\n</blockquote>\n<p>其中的<code>artifact</code>的字面意思是人工制品，但是这句话要是翻成“AngularJS有人工制品处理元素并解决数据绑定”，感觉太奇怪了。所以我查了许多字典，发现这个词不仅有人工制品的意思，还有古文物的意思，所以它真正的意思是器具。然后我又看了看上下文和相关代码，这里作者要表达的意思是AngularJS已经有了能处理那些的东西，开发者不需要管这些，所以它们应该是特别好用的一个“器”。最终我把Artifact翻译成了“神器”，自认为还是比较贴切的。</p>\n<p>通过上面的例子，说明翻译不仅需要英语水平，还需要技术的理解。所以我的意思是说，还是需要英语水平的，确实两者缺一不可。所以再来看一个长句子：</p>\n<blockquote>\n<p>The benefit of using this technique is that it allows you to<br>limit the scope of controller functionality to the part of the application where it will be used, which makes it easier to<br>perform good unit tests (as described in Chapter 25) and prevents unexpected dependencies between components in<br>the application.</p>\n</blockquote>\n<p>里面包含了that、where、which各种从句，所以断句是很重要的，把逗号和which后面的部分断开，来看看前面的这句。首先有一个benefit，意思是这个好处就是（is that）后面这句话，而后面这句话断开后剩下“limit the scope of controller functionality to the part of the application”，再加上前面的部分，和where所带的部分，翻译后就是“使用该技术的好处是|它让你可以|将控制器的作用域的功能限制在应用程序中|使用它的那部分上”。</p>\n<p>接着应该调整一下后面那部分的顺序，按中文习惯断句，就成了“使用该技术的好处是，它可以让你将控制器作用域的功能限制在应用程序的一部分中，就是使用该功能的那部分。”</p>\n<p>最后，我觉得翻译最重要的就是，说人话。如果生搬硬套的把英文翻译成中文，但失去了原有的意思，那将是致命的，所以一定要语法通畅和语义明确。</p>\n<h3 id=\"注解\"><a href=\"#注解\" class=\"headerlink\" title=\"注解\"></a>注解</h3><p>有一种东西叫译者注，是翻译者自己的话。所以很多时候我们看到书中的译者注成了译者的吐槽弹幕，有翻译不了的注一下，有专有名词注一下，甚至原文有错也注一下，这都是或多或少的滥用了译者注。最开始我也是这样使用，但后面校对的时候，我以一个读者的思维看了一遍，感觉译者注基本都是废话，大大的破坏了原书的感觉。</p>\n<p>比如翻译方面的解释，其实这说明译文有问题，应该优化译文，让其表达的更清楚，而无需注解。</p>\n<p>专有名词也不需要解释，读者不是小白，书籍所面向的人群是否可以理解该专有名词，不是译者该考虑的问题，如果作者认为有必要解释，原文就会有解释，译者只需要翻译就行了，如果没有，说明作者认为读者应该理解，就不该解释。</p>\n<p>原文有错与否也不是译者该操心的，如果是明显的印刷错误，可以翻译为正确的，然后注解一下或不注解。如果是其他层面的错误，就应该翻译成错的，况且我也不认为译者可以100%保证那就是错误的。</p>\n<p>但究竟什么时候应该使用译者注呢？我认为只有在翻译之后会产生问题的地方才该使用译者注。举个典型的例子，在译文中有这样一段话：</p>\n<blockquote>\n<p>迷惑的是，AngularJS所提供的内置过滤器叫作filter。</p>\n</blockquote>\n<p>读者真的迷惑了，迷惑的到底是什么？从中文来看没什么迷惑的地方。所以我们再看看原文：</p>\n<blockquote>\n<p>One of the built-in filters that AngularJS provides is called, confusingly, filter.</p>\n</blockquote>\n<p>明显看出了问题，过滤器的英文就是filter，所以在英文中这句话看着很奇怪，好比在中文里说，AngularJS所提供的过滤器叫做过滤器。所以直接翻译过来时，中文读者反而会迷惑，此时译者注就可以光明正大的出来解释一下了。</p>\n<h3 id=\"协作\"><a href=\"#协作\" class=\"headerlink\" title=\"协作\"></a>协作</h3><p>这次的翻译过程最有意思的就是合译了，因为有协作的部分。虽然我们是分开翻译，但是还是有很多地方需要协作。比如最常见的就是专有名词翻译的统一性问题，就算是自己一个人翻都有可能前后出现偏差，何况是两人呢。</p>\n<p>由于我在HTML中文兴趣组参与过几次翻译工作，所以知道这个问题，一开始我就在Github建立了一个单词对照表（<a href=\"https://github.com/tychio/glossary/blob/master/JavaScript/AngularJS.md\">glossary</a>）用来维护专有名词对照表。要特别注意的是，每个对照单位都应该是专有的，特别的，可能是词组也可能是单词，或者也可能是语团，但绝不能用其中的任意两项来组合使用，它们都应该是独立的。</p>\n<p>无论如何，第一次翻译书籍，肯定有很多不足之处，但也收获了大量的经验，如果还有下一次的机会，希望能做的更好。总结这些，也希望能帮到其他人，无论是翻译书籍还是文档，以一个读者的心就做应该会有所收获。</p>"},{"layout":"post","title":"碎片化结对编程","_content":"\n![clastic](/images/clastic-pair.jpg)\n\n真的很久没写博客了，一直提不起兴趣，总觉得写一些代码如何写，工具如何用，过一阵子就不是很有用了，所以想写一些自己的心得体会，但又很难总结成文章。这几天突然间想通了一些，也许我是时候抛开前端这个枷锁了，今天我们来谈谈敏捷开发的结对编程。\n\n想当年（然而并没有几年）刚来到ThoughtWorks的时候，除了英语，我最不适应的就是pair，即*结对编程*。因为刚上项目的我只能跟着结对对象的思维走，即使我思路正确了也无非是在我的结对对象写的代码上印证了一下，少有的贡献就是不时的提醒他一下typo之类无关紧要的错误。然后当我拿到键盘时，还是因为信息的不对等，我无法在全局层面上做出贡献，因为我必须非常熟悉整个项目才能说服我的pair，修改一些架构上的代码，否则只能改进一些细节上的代码片段。这种毫无创造性的工作方式让我昏昏欲睡，说好的挑战，困难，压力呢？我感到了一种可有可无的迷茫。\n\n<!-- more -->\n\n### 不同的Pair类型\n\n接着我开始了没有什么意义的强势逆袭之路，每天回家之后熟悉代码，有时半夜还在写代码，当然没有结对编程的我只能写完checkout，仅仅是为了熟悉代码库。因为我感受到对代码库的熟悉程度某种程度上决定了结对编程时的话语权。\n\n后来终于在第四个项目上，我始终掌握了代码库最全的信息，至少在团队内是这样的。虽然进度压力仍然不小，但我们还是装模作样的进行了结对编程，这次是从项目开始我就加入了，如此，我在结对时的角色发生了变化，大部分是在给我的结对对象传授知识。慢慢的我发现我总是在写代码，我的结对对象只负责看，这样好像不太对，为什么不对呢？那时我并不知道原因，但我试着改变了风格，让对方来写，我提建议。当然有时候遇到复杂的问题，我也会急不可耐的把键盘抢过来快速搞定它，再讲解一番，接着在code review的时候发现我的结对对象并没有听懂我为什么要这么做，然而这是另外一个问题了，暂且不谈。\n\n其实上面提到的就是几种不同类型的结对方式：\n\n1. **Backseat Driver**\n\n    就是改变风格的我，让对方写，但还是我drive，这样至少一个在写，一个在思考，交流还是比较多的。\n\n1. **Keyboard Grabber**\n\n    就是急不可闹抢过键盘飞快写起来的我，通常是因为双方技术和信息量差距较大，而较高一方没有耐心了。\n\n1. **Silent Sleeper**\n\n    也就是上面提到的昏昏欲睡的我，这一般是另一方太快，而且没有说清楚自己的逻辑导致的，当然也有可能是你思维太慢，比如代码库的信息量太少。\n\n1. **Sprinter**\n\n    在第一个项目我刚刚上手写的时候，大概我的结对对象眼中我就是个sprinter吧，总是想从架构上做一些重构，但又不会TDD，所以刚有个念头就被喊stop了。\n\n### 结对编程究竟为了什么\n\n简单来说，结对编程是为了交流并传播知识，还有避免陷入思维盲区，所以要让两个人一起写代码，沟通相互的不同，在从思维差异到相通的过程中找到更棒的解决方案，最终使团队中每个人都能达到共同智慧所能达到的最高境界——思维的并集。然而从我们决定结对编程开始，一直到最高境界是有很长一段路要走的。在磨合的过程中，这恰好又是四个类型：\n\n1. 高手写，新手看。\n1. 新手写，高手看。\n1. 两个高手相争。\n1. 两个新手入坑。\n\n注意，这里的高手和新手只是指的相对而言，可能是对代码的信息量不同，也可能是技术方向不同导致的。\n\n前面两种其实都是在传授知识，只不过一种是直接传授，一种是通过反馈来传授。这两种情况都是在团队成员所掌握的信息不平衡时所出现的，它们的目标都是最终达到每个人的知识都是一致的。\n\n而后面两种才是项目中的常态，先让我们抛弃高手与新手这样的概念，只是两个水平和信息量相近的程序员进行结对编程。如果两人的思路差异比较大就会产生第三种情况，在某些技术点上产生分歧，然后挣的面红耳赤。最终可能是某人赢得了胜利，这样就失去了结对编程得意义，也浪费了另一个人的思维。也可能是在两边的妥协中产生了一个微妙的结果，这显然没有达到理想的状态，仅仅是思维的交集。如果两人的沟通渐入佳境，找到了和谐的思维交流方式，仍然要小心陷入第四种情况。\n\n我们知道结对编程的好处之一是防止陷入思维盲区，因为一个人的思维是有限的，很容易忽略掉一些东西而不自知，俗话说得好，旁观者清，也是这个道理。但当两人的思维渐渐一致，有了默契之后还算两个思维吗？是不是也会存在思维盲区。如此看来结对编程的目标是让两个人思维一致的理想状态，而这种理想状态又会导致没有结对时思维盲区的问题，这就像是一个悖论，难道我们只能在即将到达理想状态的时候体验一下结对编程的好处？我渐渐的发现，肯定有哪里不对。\n\n### 结对编程状态模型\n\n既然两个人总在结对编程时会产生这样的问题，那我们就轮换着来，实际上很多项目就是这样做的，但通常我们会用一个小程序随意选择结对对象。看起来很科学，我们终于可以比较均匀的和其他人结对了，这样就不会和某个人变成同一个思维了。\n\n然而问题就和bug一样总是层出不穷。如果在任务粒度比较粗，而人数又不多的时候，交换结对又变得很艰难，因为你做完了这个用户故事，另一对人可能才刚发现并开始着手解决问题，此时显然不适合更换，而你和你的结对对象也不可能干等着，依赖于另一对人当前用户故事的用户故事也没法做，于是经常出现某对结对一直在做某个部分的用户故事，然而我们只能祈祷两对结对刚好差不多同时做完。这某种程度上就是所谓的理想状态，两个人变成了一个人。\n\n必须继续改进，所以我们让一个人待在用户故事上，另一个人交换。尝试了一阵子后，又有人觉得更换结对对象太频繁了，刚加入项目的新人还没来得及熟悉一个用户故事，又被换到另一个用户故事上了，最后变成了一个人在主导用户故事，另一个人始终旁观。这又变成了最初的状态，一个人做，另一个看，还是一个人的思维。\n\n虽然问题很多，但我忽然间想到了一个模型，也许能把问题简化一下，如图：\n![pair model](/images/pair-model.jpg)\n\n这条轴代表的是沟通交流的程度，可以称为结对编程的状态轴，而两个端点就是上面提及的问题的状态，没有沟通和彻底沟通都会形成单一思维，失去了结对编程的意义。在结对编程的过程中双方就会变得一致，往右边移动，如果有什么因素使得双方信息不对等或者知识不一致，就会产生分歧，往左边移动。中间的红线则代表了真正最佳的状态，有一定的沟通，但又不是一种思维，可以避免思维盲区。\n\n现在问题就简单了，我们如何驱动一对结对对象向左或者向右，将状态维持在红线附近呢？\n\n### 打碎你的结对\n\n我认为必须改变我们的目标，否则两个人的目标一致总会达成彻底的沟通。而我们的目标就是完成用户故事解决问题，所以我想到了改变两人所分配的用户故事，也就是说你和你的结对对象将不再工作在同一张卡上。这听起来有点天方夜谭，如果两个人不工作在同一张卡上还算是结对编程吗？我认为只要两个人坐在一起有交流就算是结对编程，无所谓你们的目标是什么，至少你们的共同目标还是做好项目。\n\n这样一来我们可以更容易的做一些改变，因为结对被打碎后变得更灵活了，尤其是对任务粒度粗而人数少的团队而言。\n\n###### 基于更细的粒度\n\n现在，我们可以更容易的交换了，你只需要找到跟你目前做的部分有可能有重叠的其他人，或者更容易实践的做法是，找到可能跟你产生代码冲突的人，跟他结对去解决可能冲突的地方。可能是一个模块，也可能是一个方法，甚至是几行公用代码。\n\n你肯定有个疑问，如果自己领的任务和其他人都没有关系怎么办。我想项目中总会有人擅长这个，或者做过类似的东西，找到他打断他目前的工作，和你一起搞定关键的部分，至少要让你明白如何做才能解决问题。如果没有这样的人，那说明也许你就是这个人，相信自己完成这个任务。或者可以找BA（业务分析师）一起结对完成，这样可以保证方向正确性。无论是什么情况，总会有办法找到你的结对对象，因为这是从你的意图出发找到的，它基于每个可能的冲突，而不是任务，所以你慢慢会发现，重要的是明确你的意图，找到方向，而不是和谁结对。\n\n###### 学会分解任务\n\n要明确意图其实很容易，先弄清楚你的需求，也就是用户故事的内容，然后细分它们。但往往我们划分的任务最后看起来并不完全正确，大部分人并不明白分解任务是为了什么，按什么维度划分，要划分成多细的粒度，因为没有驱动力，只能完全凭借经验去分解任务。\n\n现在当你一个人拿到一个用户故事后，你需要找一个结对的对象，所以你先得明确自己的任务意图，分解任务会变得很有动力。你需要考虑的是，分解出来的任务粒度是否和别人相近，否则你和其他人都会难以确定你们是否有冲突。这时你自然会明白需要具体到什么程度，以及包含哪些信息。\n\n举个例子，你拿到的用户故事需要一个可编辑的列表，你首先肯定会考虑把它存到数据库。当你分解的任务粒度比较大时，可能是“保存A列表中的元素”，这样当另外一个人也需要操作另一个类似的B列表的时候，他可能不会想到你。而任务粒度太小，比如“创建数据库表xxx_a”，也是同样的情况。所以现在你分解任务时的问题会变成，如何更广泛的匹配其他人的任务呢？这样该任务也许会变成“通过数据库存储a，并显示到A列表中，它与b业务相关”。这不需要你写出来让别人看到，只要心中明白了这些任务就可以了，最重要的是认知。\n\n###### 迫切需要站会\n\n刚刚你理解了自己的用户故事，但要找到你的结对对象，还需要了解其他团队成员的用户故事，或者当前正在做的任务。这时你会想到站会，是的，在敏捷中站会是最容易实现但最难实践的一环。说最容易是因为我们只要每天早上站一起就可以像模像样了，说最难是因为很难真的被利用到，因为这是一个全员的实践，需要每个人深刻的理解其意义。\n\n我曾见过的最离谱的站会大致分为两种，一种是汇报式的，团队中层级最高的人会不自觉的站在中间，或者其他人会慢慢转向并围拢他，然后每个人向他报告自己昨天完成了什么，他们会忽略掉其他人，因为他们自己也没有向其他人讲述。另一种是结果式的，只说现在和某某正在结对，昨天完成了xx用户故事，或者正在做xx用户故事，明天准备做哪个xx用户故事，但没有任何细节和具体描述，这些信息其实看一眼物理墙就可以知道了。\n\n然而现在不一样了，每个人心中都带着一个疑问，我昨天做的会不会影响其他人，今天准备做的会不会谁能帮到我。站会将不再难以捉摸，你会迫切的想表达自己之前做的，准备做的，遇到的问题，还有更重要的是对其他人的这三个方面异常的感兴趣，他们到底在做什么。\n\n###### 团队思维复杂度\n\n渐渐的大家都会独立思考，不仅是思考自己做的事，还思考别人的事，因为除了你没有其他人会为了你的用户故事而思考。在一次简短的结对编程之后，你的结对对象只能确保你们之间没有冲突了，他所要的功能已经完成了，而你必须自己确保这个用户故事切实的完成了。这样，不会再有人所思考的东西是别人的子集，或者与其他人相似，每个人都有自己所要考虑的东西和目标，而其中又有许多交集。\n\n这种看起来似乎是打乱团队一致性的效果，产生了一种很有趣的现象。不过在说清楚它的优劣之前，我必须先阐述清楚一个概念。团队中所有成员的思维之间有着许多相似和矛盾，这就是*团队思维复杂度*。\n\n往往我们会不断增加团队的一致性，力求全员达成共识，这其实是在降低团队思维复杂度，这样不仅可以降低管理成本，还可以在有问题的时候及时调整，因为每个人得思想都是较为一致的，所以解决问题的能力较强，这叫做团队的*恢复稳定性*。但同时团队的思维和解决办法过于单一，容易陷入各种问题中，也就是所谓的一条腿走路的弊端。而如果团队过于复杂，每个人都有自己的想法，矛盾和制约无处不在，此时的团队很难被改变，却避免了前面所说的思维单一的问题，各种不同的思维会更大范围的覆盖各种解决方案，更多会去避免遇到问题，这是团队的*规避稳定性*。\n\n也就是说当团队过于单一的时候，规避稳定性低，容易遇到问题，但恢复稳定性高，可以更好的解决问题。而复杂度较高的时候，规避稳定性高，可以提早发现并避免问题，但恢复稳定性低，一旦碰到严重问题，风险会非常大。所以在项目管理中，为了降低风险，我们应该找到一个更平衡的点去维持住团队思维复杂度，而不应该一味的增加或降低团队思维复杂度。\n\n碎片化的结对编程恰恰是为了维持这一平衡的实践，在独立思考的团队中，每个人都将保有自己的思路，而结对的时候又会达到沟通思维的目的，使团队思维复杂度维持在一个中间水平。即能降低风险，又可以防止问题的发生。\n\n###### 广泛深入风险\n\n说到风险，在敏捷中我们还提倡先做风险大的事，因为尽早发现问题暴露风险，才有更多的时间去消化风险解决问题。但往往我们很难识别风险，所以总会在低风险的用户故事中潜伏者一两个比较大的问题。\n\n在我们的项目中总是会由相关技术的专家级成员来进行提前的分析，但一个人的精力是有限的，而且我们有时候很难判断一个用户故事所涉及的技术范围具体是什么，所以不如由做的人来提前分析。然而这样又产生了一个问题，在人员较少用户故事较多的团队中（比如我们团队），第一时间我们能接触到的用户故事是有限的，碎片化的结对编程可以很好的解决这个问题。当每个人都领取一个用户故事的时候，我们可以更大范围的接触到这个迭代的用户故事，尽早的找出或碰到有风险的问题，而且在实践中，我发现这些问题往往是和好几个用户故事相关的，如此一来，相当于多人分别识别风险，然后共同解决问题，开发效率和质量也会有一定提升。\n\n###### 驱动\n\n在碎片化结对编程的实践中，我们也遇到过一些问题。比如当有几个用户故事是连续依赖的时候，我们还可以分别领取这些用户故事吗？即使分别领了卡，两个人还是会工作到被依赖的那个用户故事上。但你会发现这样其实并没有回到普通的结对编程状态，一个重要区别是，两个人仍然是抱有不同目标进行开发的。一个人的目标是完成这个用户故事，而另一个人的目标是让这个用户故事为其将要做的那个用户故事服务。所以做被依赖用户故事的人会被结对对象驱动。\n\n有人会发现，这样不就是考虑太多了吗，用户故事不应该考虑以后的实现。其实这是一个平衡的过程，在成本相同的情况下，选择更好的方案肯定是没错的，关键在于不能将精力浪费在没用的东西上。而结对对象所关注的正是他挑的用户故事，他所关注的问题恰恰是除了当前的用户故事最应该被考虑的。在这种驱动和制衡下，你们会选择既能完成当前用户故事，又能让下一个依赖的用户故事更顺利的解决方案，避免一些风险。\n\n### 总结\n\n简而言之，碎片化的结对编程的主要思想是将一对结对对应一个用户故事的死板搭配更加合理的分散成多个结对对象对应多个特性的灵活搭配，以减少浪费。重要的是，每个人一定要形成自己独立的思维习惯，在这种实践下每个人都会自然而然的寻找自己的结对对象。\n\n当然碎片化结对编程也有其局限，在人员对敏捷实践不熟悉的情况下，贸然使用很容易导致各自独立编程不结对的情况出现，它仅是对结对编程的一种适应性改进，适合于用户故事粒度较大，人员数量较少的团队。\n","source":"_posts/2016-05-26-clastic-pair-programing.md","raw":"---\nlayout: post\ntitle: 碎片化结对编程\ntags: [agile, development, thinking, clastic]\ncategory: Work\n---\n\n![clastic](/images/clastic-pair.jpg)\n\n真的很久没写博客了，一直提不起兴趣，总觉得写一些代码如何写，工具如何用，过一阵子就不是很有用了，所以想写一些自己的心得体会，但又很难总结成文章。这几天突然间想通了一些，也许我是时候抛开前端这个枷锁了，今天我们来谈谈敏捷开发的结对编程。\n\n想当年（然而并没有几年）刚来到ThoughtWorks的时候，除了英语，我最不适应的就是pair，即*结对编程*。因为刚上项目的我只能跟着结对对象的思维走，即使我思路正确了也无非是在我的结对对象写的代码上印证了一下，少有的贡献就是不时的提醒他一下typo之类无关紧要的错误。然后当我拿到键盘时，还是因为信息的不对等，我无法在全局层面上做出贡献，因为我必须非常熟悉整个项目才能说服我的pair，修改一些架构上的代码，否则只能改进一些细节上的代码片段。这种毫无创造性的工作方式让我昏昏欲睡，说好的挑战，困难，压力呢？我感到了一种可有可无的迷茫。\n\n<!-- more -->\n\n### 不同的Pair类型\n\n接着我开始了没有什么意义的强势逆袭之路，每天回家之后熟悉代码，有时半夜还在写代码，当然没有结对编程的我只能写完checkout，仅仅是为了熟悉代码库。因为我感受到对代码库的熟悉程度某种程度上决定了结对编程时的话语权。\n\n后来终于在第四个项目上，我始终掌握了代码库最全的信息，至少在团队内是这样的。虽然进度压力仍然不小，但我们还是装模作样的进行了结对编程，这次是从项目开始我就加入了，如此，我在结对时的角色发生了变化，大部分是在给我的结对对象传授知识。慢慢的我发现我总是在写代码，我的结对对象只负责看，这样好像不太对，为什么不对呢？那时我并不知道原因，但我试着改变了风格，让对方来写，我提建议。当然有时候遇到复杂的问题，我也会急不可耐的把键盘抢过来快速搞定它，再讲解一番，接着在code review的时候发现我的结对对象并没有听懂我为什么要这么做，然而这是另外一个问题了，暂且不谈。\n\n其实上面提到的就是几种不同类型的结对方式：\n\n1. **Backseat Driver**\n\n    就是改变风格的我，让对方写，但还是我drive，这样至少一个在写，一个在思考，交流还是比较多的。\n\n1. **Keyboard Grabber**\n\n    就是急不可闹抢过键盘飞快写起来的我，通常是因为双方技术和信息量差距较大，而较高一方没有耐心了。\n\n1. **Silent Sleeper**\n\n    也就是上面提到的昏昏欲睡的我，这一般是另一方太快，而且没有说清楚自己的逻辑导致的，当然也有可能是你思维太慢，比如代码库的信息量太少。\n\n1. **Sprinter**\n\n    在第一个项目我刚刚上手写的时候，大概我的结对对象眼中我就是个sprinter吧，总是想从架构上做一些重构，但又不会TDD，所以刚有个念头就被喊stop了。\n\n### 结对编程究竟为了什么\n\n简单来说，结对编程是为了交流并传播知识，还有避免陷入思维盲区，所以要让两个人一起写代码，沟通相互的不同，在从思维差异到相通的过程中找到更棒的解决方案，最终使团队中每个人都能达到共同智慧所能达到的最高境界——思维的并集。然而从我们决定结对编程开始，一直到最高境界是有很长一段路要走的。在磨合的过程中，这恰好又是四个类型：\n\n1. 高手写，新手看。\n1. 新手写，高手看。\n1. 两个高手相争。\n1. 两个新手入坑。\n\n注意，这里的高手和新手只是指的相对而言，可能是对代码的信息量不同，也可能是技术方向不同导致的。\n\n前面两种其实都是在传授知识，只不过一种是直接传授，一种是通过反馈来传授。这两种情况都是在团队成员所掌握的信息不平衡时所出现的，它们的目标都是最终达到每个人的知识都是一致的。\n\n而后面两种才是项目中的常态，先让我们抛弃高手与新手这样的概念，只是两个水平和信息量相近的程序员进行结对编程。如果两人的思路差异比较大就会产生第三种情况，在某些技术点上产生分歧，然后挣的面红耳赤。最终可能是某人赢得了胜利，这样就失去了结对编程得意义，也浪费了另一个人的思维。也可能是在两边的妥协中产生了一个微妙的结果，这显然没有达到理想的状态，仅仅是思维的交集。如果两人的沟通渐入佳境，找到了和谐的思维交流方式，仍然要小心陷入第四种情况。\n\n我们知道结对编程的好处之一是防止陷入思维盲区，因为一个人的思维是有限的，很容易忽略掉一些东西而不自知，俗话说得好，旁观者清，也是这个道理。但当两人的思维渐渐一致，有了默契之后还算两个思维吗？是不是也会存在思维盲区。如此看来结对编程的目标是让两个人思维一致的理想状态，而这种理想状态又会导致没有结对时思维盲区的问题，这就像是一个悖论，难道我们只能在即将到达理想状态的时候体验一下结对编程的好处？我渐渐的发现，肯定有哪里不对。\n\n### 结对编程状态模型\n\n既然两个人总在结对编程时会产生这样的问题，那我们就轮换着来，实际上很多项目就是这样做的，但通常我们会用一个小程序随意选择结对对象。看起来很科学，我们终于可以比较均匀的和其他人结对了，这样就不会和某个人变成同一个思维了。\n\n然而问题就和bug一样总是层出不穷。如果在任务粒度比较粗，而人数又不多的时候，交换结对又变得很艰难，因为你做完了这个用户故事，另一对人可能才刚发现并开始着手解决问题，此时显然不适合更换，而你和你的结对对象也不可能干等着，依赖于另一对人当前用户故事的用户故事也没法做，于是经常出现某对结对一直在做某个部分的用户故事，然而我们只能祈祷两对结对刚好差不多同时做完。这某种程度上就是所谓的理想状态，两个人变成了一个人。\n\n必须继续改进，所以我们让一个人待在用户故事上，另一个人交换。尝试了一阵子后，又有人觉得更换结对对象太频繁了，刚加入项目的新人还没来得及熟悉一个用户故事，又被换到另一个用户故事上了，最后变成了一个人在主导用户故事，另一个人始终旁观。这又变成了最初的状态，一个人做，另一个看，还是一个人的思维。\n\n虽然问题很多，但我忽然间想到了一个模型，也许能把问题简化一下，如图：\n![pair model](/images/pair-model.jpg)\n\n这条轴代表的是沟通交流的程度，可以称为结对编程的状态轴，而两个端点就是上面提及的问题的状态，没有沟通和彻底沟通都会形成单一思维，失去了结对编程的意义。在结对编程的过程中双方就会变得一致，往右边移动，如果有什么因素使得双方信息不对等或者知识不一致，就会产生分歧，往左边移动。中间的红线则代表了真正最佳的状态，有一定的沟通，但又不是一种思维，可以避免思维盲区。\n\n现在问题就简单了，我们如何驱动一对结对对象向左或者向右，将状态维持在红线附近呢？\n\n### 打碎你的结对\n\n我认为必须改变我们的目标，否则两个人的目标一致总会达成彻底的沟通。而我们的目标就是完成用户故事解决问题，所以我想到了改变两人所分配的用户故事，也就是说你和你的结对对象将不再工作在同一张卡上。这听起来有点天方夜谭，如果两个人不工作在同一张卡上还算是结对编程吗？我认为只要两个人坐在一起有交流就算是结对编程，无所谓你们的目标是什么，至少你们的共同目标还是做好项目。\n\n这样一来我们可以更容易的做一些改变，因为结对被打碎后变得更灵活了，尤其是对任务粒度粗而人数少的团队而言。\n\n###### 基于更细的粒度\n\n现在，我们可以更容易的交换了，你只需要找到跟你目前做的部分有可能有重叠的其他人，或者更容易实践的做法是，找到可能跟你产生代码冲突的人，跟他结对去解决可能冲突的地方。可能是一个模块，也可能是一个方法，甚至是几行公用代码。\n\n你肯定有个疑问，如果自己领的任务和其他人都没有关系怎么办。我想项目中总会有人擅长这个，或者做过类似的东西，找到他打断他目前的工作，和你一起搞定关键的部分，至少要让你明白如何做才能解决问题。如果没有这样的人，那说明也许你就是这个人，相信自己完成这个任务。或者可以找BA（业务分析师）一起结对完成，这样可以保证方向正确性。无论是什么情况，总会有办法找到你的结对对象，因为这是从你的意图出发找到的，它基于每个可能的冲突，而不是任务，所以你慢慢会发现，重要的是明确你的意图，找到方向，而不是和谁结对。\n\n###### 学会分解任务\n\n要明确意图其实很容易，先弄清楚你的需求，也就是用户故事的内容，然后细分它们。但往往我们划分的任务最后看起来并不完全正确，大部分人并不明白分解任务是为了什么，按什么维度划分，要划分成多细的粒度，因为没有驱动力，只能完全凭借经验去分解任务。\n\n现在当你一个人拿到一个用户故事后，你需要找一个结对的对象，所以你先得明确自己的任务意图，分解任务会变得很有动力。你需要考虑的是，分解出来的任务粒度是否和别人相近，否则你和其他人都会难以确定你们是否有冲突。这时你自然会明白需要具体到什么程度，以及包含哪些信息。\n\n举个例子，你拿到的用户故事需要一个可编辑的列表，你首先肯定会考虑把它存到数据库。当你分解的任务粒度比较大时，可能是“保存A列表中的元素”，这样当另外一个人也需要操作另一个类似的B列表的时候，他可能不会想到你。而任务粒度太小，比如“创建数据库表xxx_a”，也是同样的情况。所以现在你分解任务时的问题会变成，如何更广泛的匹配其他人的任务呢？这样该任务也许会变成“通过数据库存储a，并显示到A列表中，它与b业务相关”。这不需要你写出来让别人看到，只要心中明白了这些任务就可以了，最重要的是认知。\n\n###### 迫切需要站会\n\n刚刚你理解了自己的用户故事，但要找到你的结对对象，还需要了解其他团队成员的用户故事，或者当前正在做的任务。这时你会想到站会，是的，在敏捷中站会是最容易实现但最难实践的一环。说最容易是因为我们只要每天早上站一起就可以像模像样了，说最难是因为很难真的被利用到，因为这是一个全员的实践，需要每个人深刻的理解其意义。\n\n我曾见过的最离谱的站会大致分为两种，一种是汇报式的，团队中层级最高的人会不自觉的站在中间，或者其他人会慢慢转向并围拢他，然后每个人向他报告自己昨天完成了什么，他们会忽略掉其他人，因为他们自己也没有向其他人讲述。另一种是结果式的，只说现在和某某正在结对，昨天完成了xx用户故事，或者正在做xx用户故事，明天准备做哪个xx用户故事，但没有任何细节和具体描述，这些信息其实看一眼物理墙就可以知道了。\n\n然而现在不一样了，每个人心中都带着一个疑问，我昨天做的会不会影响其他人，今天准备做的会不会谁能帮到我。站会将不再难以捉摸，你会迫切的想表达自己之前做的，准备做的，遇到的问题，还有更重要的是对其他人的这三个方面异常的感兴趣，他们到底在做什么。\n\n###### 团队思维复杂度\n\n渐渐的大家都会独立思考，不仅是思考自己做的事，还思考别人的事，因为除了你没有其他人会为了你的用户故事而思考。在一次简短的结对编程之后，你的结对对象只能确保你们之间没有冲突了，他所要的功能已经完成了，而你必须自己确保这个用户故事切实的完成了。这样，不会再有人所思考的东西是别人的子集，或者与其他人相似，每个人都有自己所要考虑的东西和目标，而其中又有许多交集。\n\n这种看起来似乎是打乱团队一致性的效果，产生了一种很有趣的现象。不过在说清楚它的优劣之前，我必须先阐述清楚一个概念。团队中所有成员的思维之间有着许多相似和矛盾，这就是*团队思维复杂度*。\n\n往往我们会不断增加团队的一致性，力求全员达成共识，这其实是在降低团队思维复杂度，这样不仅可以降低管理成本，还可以在有问题的时候及时调整，因为每个人得思想都是较为一致的，所以解决问题的能力较强，这叫做团队的*恢复稳定性*。但同时团队的思维和解决办法过于单一，容易陷入各种问题中，也就是所谓的一条腿走路的弊端。而如果团队过于复杂，每个人都有自己的想法，矛盾和制约无处不在，此时的团队很难被改变，却避免了前面所说的思维单一的问题，各种不同的思维会更大范围的覆盖各种解决方案，更多会去避免遇到问题，这是团队的*规避稳定性*。\n\n也就是说当团队过于单一的时候，规避稳定性低，容易遇到问题，但恢复稳定性高，可以更好的解决问题。而复杂度较高的时候，规避稳定性高，可以提早发现并避免问题，但恢复稳定性低，一旦碰到严重问题，风险会非常大。所以在项目管理中，为了降低风险，我们应该找到一个更平衡的点去维持住团队思维复杂度，而不应该一味的增加或降低团队思维复杂度。\n\n碎片化的结对编程恰恰是为了维持这一平衡的实践，在独立思考的团队中，每个人都将保有自己的思路，而结对的时候又会达到沟通思维的目的，使团队思维复杂度维持在一个中间水平。即能降低风险，又可以防止问题的发生。\n\n###### 广泛深入风险\n\n说到风险，在敏捷中我们还提倡先做风险大的事，因为尽早发现问题暴露风险，才有更多的时间去消化风险解决问题。但往往我们很难识别风险，所以总会在低风险的用户故事中潜伏者一两个比较大的问题。\n\n在我们的项目中总是会由相关技术的专家级成员来进行提前的分析，但一个人的精力是有限的，而且我们有时候很难判断一个用户故事所涉及的技术范围具体是什么，所以不如由做的人来提前分析。然而这样又产生了一个问题，在人员较少用户故事较多的团队中（比如我们团队），第一时间我们能接触到的用户故事是有限的，碎片化的结对编程可以很好的解决这个问题。当每个人都领取一个用户故事的时候，我们可以更大范围的接触到这个迭代的用户故事，尽早的找出或碰到有风险的问题，而且在实践中，我发现这些问题往往是和好几个用户故事相关的，如此一来，相当于多人分别识别风险，然后共同解决问题，开发效率和质量也会有一定提升。\n\n###### 驱动\n\n在碎片化结对编程的实践中，我们也遇到过一些问题。比如当有几个用户故事是连续依赖的时候，我们还可以分别领取这些用户故事吗？即使分别领了卡，两个人还是会工作到被依赖的那个用户故事上。但你会发现这样其实并没有回到普通的结对编程状态，一个重要区别是，两个人仍然是抱有不同目标进行开发的。一个人的目标是完成这个用户故事，而另一个人的目标是让这个用户故事为其将要做的那个用户故事服务。所以做被依赖用户故事的人会被结对对象驱动。\n\n有人会发现，这样不就是考虑太多了吗，用户故事不应该考虑以后的实现。其实这是一个平衡的过程，在成本相同的情况下，选择更好的方案肯定是没错的，关键在于不能将精力浪费在没用的东西上。而结对对象所关注的正是他挑的用户故事，他所关注的问题恰恰是除了当前的用户故事最应该被考虑的。在这种驱动和制衡下，你们会选择既能完成当前用户故事，又能让下一个依赖的用户故事更顺利的解决方案，避免一些风险。\n\n### 总结\n\n简而言之，碎片化的结对编程的主要思想是将一对结对对应一个用户故事的死板搭配更加合理的分散成多个结对对象对应多个特性的灵活搭配，以减少浪费。重要的是，每个人一定要形成自己独立的思维习惯，在这种实践下每个人都会自然而然的寻找自己的结对对象。\n\n当然碎片化结对编程也有其局限，在人员对敏捷实践不熟悉的情况下，贸然使用很容易导致各自独立编程不结对的情况出现，它仅是对结对编程的一种适应性改进，适合于用户故事粒度较大，人员数量较少的团队。\n","slug":"clastic-pair-programing","published":1,"date":"2016-05-25T16:00:00.000Z","updated":"2021-11-28T11:59:29.970Z","_id":"ckwj6551b001bvyjh61hdhy9w","comments":1,"photos":[],"link":"","content":"<p><img src=\"/images/clastic-pair.jpg\" alt=\"clastic\"></p>\n<p>真的很久没写博客了，一直提不起兴趣，总觉得写一些代码如何写，工具如何用，过一阵子就不是很有用了，所以想写一些自己的心得体会，但又很难总结成文章。这几天突然间想通了一些，也许我是时候抛开前端这个枷锁了，今天我们来谈谈敏捷开发的结对编程。</p>\n<p>想当年（然而并没有几年）刚来到ThoughtWorks的时候，除了英语，我最不适应的就是pair，即<em>结对编程</em>。因为刚上项目的我只能跟着结对对象的思维走，即使我思路正确了也无非是在我的结对对象写的代码上印证了一下，少有的贡献就是不时的提醒他一下typo之类无关紧要的错误。然后当我拿到键盘时，还是因为信息的不对等，我无法在全局层面上做出贡献，因为我必须非常熟悉整个项目才能说服我的pair，修改一些架构上的代码，否则只能改进一些细节上的代码片段。这种毫无创造性的工作方式让我昏昏欲睡，说好的挑战，困难，压力呢？我感到了一种可有可无的迷茫。</p>\n<span id=\"more\"></span>\n\n<h3 id=\"不同的Pair类型\"><a href=\"#不同的Pair类型\" class=\"headerlink\" title=\"不同的Pair类型\"></a>不同的Pair类型</h3><p>接着我开始了没有什么意义的强势逆袭之路，每天回家之后熟悉代码，有时半夜还在写代码，当然没有结对编程的我只能写完checkout，仅仅是为了熟悉代码库。因为我感受到对代码库的熟悉程度某种程度上决定了结对编程时的话语权。</p>\n<p>后来终于在第四个项目上，我始终掌握了代码库最全的信息，至少在团队内是这样的。虽然进度压力仍然不小，但我们还是装模作样的进行了结对编程，这次是从项目开始我就加入了，如此，我在结对时的角色发生了变化，大部分是在给我的结对对象传授知识。慢慢的我发现我总是在写代码，我的结对对象只负责看，这样好像不太对，为什么不对呢？那时我并不知道原因，但我试着改变了风格，让对方来写，我提建议。当然有时候遇到复杂的问题，我也会急不可耐的把键盘抢过来快速搞定它，再讲解一番，接着在code review的时候发现我的结对对象并没有听懂我为什么要这么做，然而这是另外一个问题了，暂且不谈。</p>\n<p>其实上面提到的就是几种不同类型的结对方式：</p>\n<ol>\n<li><p><strong>Backseat Driver</strong></p>\n<p> 就是改变风格的我，让对方写，但还是我drive，这样至少一个在写，一个在思考，交流还是比较多的。</p>\n</li>\n<li><p><strong>Keyboard Grabber</strong></p>\n<p> 就是急不可闹抢过键盘飞快写起来的我，通常是因为双方技术和信息量差距较大，而较高一方没有耐心了。</p>\n</li>\n<li><p><strong>Silent Sleeper</strong></p>\n<p> 也就是上面提到的昏昏欲睡的我，这一般是另一方太快，而且没有说清楚自己的逻辑导致的，当然也有可能是你思维太慢，比如代码库的信息量太少。</p>\n</li>\n<li><p><strong>Sprinter</strong></p>\n<p> 在第一个项目我刚刚上手写的时候，大概我的结对对象眼中我就是个sprinter吧，总是想从架构上做一些重构，但又不会TDD，所以刚有个念头就被喊stop了。</p>\n</li>\n</ol>\n<h3 id=\"结对编程究竟为了什么\"><a href=\"#结对编程究竟为了什么\" class=\"headerlink\" title=\"结对编程究竟为了什么\"></a>结对编程究竟为了什么</h3><p>简单来说，结对编程是为了交流并传播知识，还有避免陷入思维盲区，所以要让两个人一起写代码，沟通相互的不同，在从思维差异到相通的过程中找到更棒的解决方案，最终使团队中每个人都能达到共同智慧所能达到的最高境界——思维的并集。然而从我们决定结对编程开始，一直到最高境界是有很长一段路要走的。在磨合的过程中，这恰好又是四个类型：</p>\n<ol>\n<li>高手写，新手看。</li>\n<li>新手写，高手看。</li>\n<li>两个高手相争。</li>\n<li>两个新手入坑。</li>\n</ol>\n<p>注意，这里的高手和新手只是指的相对而言，可能是对代码的信息量不同，也可能是技术方向不同导致的。</p>\n<p>前面两种其实都是在传授知识，只不过一种是直接传授，一种是通过反馈来传授。这两种情况都是在团队成员所掌握的信息不平衡时所出现的，它们的目标都是最终达到每个人的知识都是一致的。</p>\n<p>而后面两种才是项目中的常态，先让我们抛弃高手与新手这样的概念，只是两个水平和信息量相近的程序员进行结对编程。如果两人的思路差异比较大就会产生第三种情况，在某些技术点上产生分歧，然后挣的面红耳赤。最终可能是某人赢得了胜利，这样就失去了结对编程得意义，也浪费了另一个人的思维。也可能是在两边的妥协中产生了一个微妙的结果，这显然没有达到理想的状态，仅仅是思维的交集。如果两人的沟通渐入佳境，找到了和谐的思维交流方式，仍然要小心陷入第四种情况。</p>\n<p>我们知道结对编程的好处之一是防止陷入思维盲区，因为一个人的思维是有限的，很容易忽略掉一些东西而不自知，俗话说得好，旁观者清，也是这个道理。但当两人的思维渐渐一致，有了默契之后还算两个思维吗？是不是也会存在思维盲区。如此看来结对编程的目标是让两个人思维一致的理想状态，而这种理想状态又会导致没有结对时思维盲区的问题，这就像是一个悖论，难道我们只能在即将到达理想状态的时候体验一下结对编程的好处？我渐渐的发现，肯定有哪里不对。</p>\n<h3 id=\"结对编程状态模型\"><a href=\"#结对编程状态模型\" class=\"headerlink\" title=\"结对编程状态模型\"></a>结对编程状态模型</h3><p>既然两个人总在结对编程时会产生这样的问题，那我们就轮换着来，实际上很多项目就是这样做的，但通常我们会用一个小程序随意选择结对对象。看起来很科学，我们终于可以比较均匀的和其他人结对了，这样就不会和某个人变成同一个思维了。</p>\n<p>然而问题就和bug一样总是层出不穷。如果在任务粒度比较粗，而人数又不多的时候，交换结对又变得很艰难，因为你做完了这个用户故事，另一对人可能才刚发现并开始着手解决问题，此时显然不适合更换，而你和你的结对对象也不可能干等着，依赖于另一对人当前用户故事的用户故事也没法做，于是经常出现某对结对一直在做某个部分的用户故事，然而我们只能祈祷两对结对刚好差不多同时做完。这某种程度上就是所谓的理想状态，两个人变成了一个人。</p>\n<p>必须继续改进，所以我们让一个人待在用户故事上，另一个人交换。尝试了一阵子后，又有人觉得更换结对对象太频繁了，刚加入项目的新人还没来得及熟悉一个用户故事，又被换到另一个用户故事上了，最后变成了一个人在主导用户故事，另一个人始终旁观。这又变成了最初的状态，一个人做，另一个看，还是一个人的思维。</p>\n<p>虽然问题很多，但我忽然间想到了一个模型，也许能把问题简化一下，如图：<br><img src=\"/images/pair-model.jpg\" alt=\"pair model\"></p>\n<p>这条轴代表的是沟通交流的程度，可以称为结对编程的状态轴，而两个端点就是上面提及的问题的状态，没有沟通和彻底沟通都会形成单一思维，失去了结对编程的意义。在结对编程的过程中双方就会变得一致，往右边移动，如果有什么因素使得双方信息不对等或者知识不一致，就会产生分歧，往左边移动。中间的红线则代表了真正最佳的状态，有一定的沟通，但又不是一种思维，可以避免思维盲区。</p>\n<p>现在问题就简单了，我们如何驱动一对结对对象向左或者向右，将状态维持在红线附近呢？</p>\n<h3 id=\"打碎你的结对\"><a href=\"#打碎你的结对\" class=\"headerlink\" title=\"打碎你的结对\"></a>打碎你的结对</h3><p>我认为必须改变我们的目标，否则两个人的目标一致总会达成彻底的沟通。而我们的目标就是完成用户故事解决问题，所以我想到了改变两人所分配的用户故事，也就是说你和你的结对对象将不再工作在同一张卡上。这听起来有点天方夜谭，如果两个人不工作在同一张卡上还算是结对编程吗？我认为只要两个人坐在一起有交流就算是结对编程，无所谓你们的目标是什么，至少你们的共同目标还是做好项目。</p>\n<p>这样一来我们可以更容易的做一些改变，因为结对被打碎后变得更灵活了，尤其是对任务粒度粗而人数少的团队而言。</p>\n<h6 id=\"基于更细的粒度\"><a href=\"#基于更细的粒度\" class=\"headerlink\" title=\"基于更细的粒度\"></a>基于更细的粒度</h6><p>现在，我们可以更容易的交换了，你只需要找到跟你目前做的部分有可能有重叠的其他人，或者更容易实践的做法是，找到可能跟你产生代码冲突的人，跟他结对去解决可能冲突的地方。可能是一个模块，也可能是一个方法，甚至是几行公用代码。</p>\n<p>你肯定有个疑问，如果自己领的任务和其他人都没有关系怎么办。我想项目中总会有人擅长这个，或者做过类似的东西，找到他打断他目前的工作，和你一起搞定关键的部分，至少要让你明白如何做才能解决问题。如果没有这样的人，那说明也许你就是这个人，相信自己完成这个任务。或者可以找BA（业务分析师）一起结对完成，这样可以保证方向正确性。无论是什么情况，总会有办法找到你的结对对象，因为这是从你的意图出发找到的，它基于每个可能的冲突，而不是任务，所以你慢慢会发现，重要的是明确你的意图，找到方向，而不是和谁结对。</p>\n<h6 id=\"学会分解任务\"><a href=\"#学会分解任务\" class=\"headerlink\" title=\"学会分解任务\"></a>学会分解任务</h6><p>要明确意图其实很容易，先弄清楚你的需求，也就是用户故事的内容，然后细分它们。但往往我们划分的任务最后看起来并不完全正确，大部分人并不明白分解任务是为了什么，按什么维度划分，要划分成多细的粒度，因为没有驱动力，只能完全凭借经验去分解任务。</p>\n<p>现在当你一个人拿到一个用户故事后，你需要找一个结对的对象，所以你先得明确自己的任务意图，分解任务会变得很有动力。你需要考虑的是，分解出来的任务粒度是否和别人相近，否则你和其他人都会难以确定你们是否有冲突。这时你自然会明白需要具体到什么程度，以及包含哪些信息。</p>\n<p>举个例子，你拿到的用户故事需要一个可编辑的列表，你首先肯定会考虑把它存到数据库。当你分解的任务粒度比较大时，可能是“保存A列表中的元素”，这样当另外一个人也需要操作另一个类似的B列表的时候，他可能不会想到你。而任务粒度太小，比如“创建数据库表xxx_a”，也是同样的情况。所以现在你分解任务时的问题会变成，如何更广泛的匹配其他人的任务呢？这样该任务也许会变成“通过数据库存储a，并显示到A列表中，它与b业务相关”。这不需要你写出来让别人看到，只要心中明白了这些任务就可以了，最重要的是认知。</p>\n<h6 id=\"迫切需要站会\"><a href=\"#迫切需要站会\" class=\"headerlink\" title=\"迫切需要站会\"></a>迫切需要站会</h6><p>刚刚你理解了自己的用户故事，但要找到你的结对对象，还需要了解其他团队成员的用户故事，或者当前正在做的任务。这时你会想到站会，是的，在敏捷中站会是最容易实现但最难实践的一环。说最容易是因为我们只要每天早上站一起就可以像模像样了，说最难是因为很难真的被利用到，因为这是一个全员的实践，需要每个人深刻的理解其意义。</p>\n<p>我曾见过的最离谱的站会大致分为两种，一种是汇报式的，团队中层级最高的人会不自觉的站在中间，或者其他人会慢慢转向并围拢他，然后每个人向他报告自己昨天完成了什么，他们会忽略掉其他人，因为他们自己也没有向其他人讲述。另一种是结果式的，只说现在和某某正在结对，昨天完成了xx用户故事，或者正在做xx用户故事，明天准备做哪个xx用户故事，但没有任何细节和具体描述，这些信息其实看一眼物理墙就可以知道了。</p>\n<p>然而现在不一样了，每个人心中都带着一个疑问，我昨天做的会不会影响其他人，今天准备做的会不会谁能帮到我。站会将不再难以捉摸，你会迫切的想表达自己之前做的，准备做的，遇到的问题，还有更重要的是对其他人的这三个方面异常的感兴趣，他们到底在做什么。</p>\n<h6 id=\"团队思维复杂度\"><a href=\"#团队思维复杂度\" class=\"headerlink\" title=\"团队思维复杂度\"></a>团队思维复杂度</h6><p>渐渐的大家都会独立思考，不仅是思考自己做的事，还思考别人的事，因为除了你没有其他人会为了你的用户故事而思考。在一次简短的结对编程之后，你的结对对象只能确保你们之间没有冲突了，他所要的功能已经完成了，而你必须自己确保这个用户故事切实的完成了。这样，不会再有人所思考的东西是别人的子集，或者与其他人相似，每个人都有自己所要考虑的东西和目标，而其中又有许多交集。</p>\n<p>这种看起来似乎是打乱团队一致性的效果，产生了一种很有趣的现象。不过在说清楚它的优劣之前，我必须先阐述清楚一个概念。团队中所有成员的思维之间有着许多相似和矛盾，这就是<em>团队思维复杂度</em>。</p>\n<p>往往我们会不断增加团队的一致性，力求全员达成共识，这其实是在降低团队思维复杂度，这样不仅可以降低管理成本，还可以在有问题的时候及时调整，因为每个人得思想都是较为一致的，所以解决问题的能力较强，这叫做团队的<em>恢复稳定性</em>。但同时团队的思维和解决办法过于单一，容易陷入各种问题中，也就是所谓的一条腿走路的弊端。而如果团队过于复杂，每个人都有自己的想法，矛盾和制约无处不在，此时的团队很难被改变，却避免了前面所说的思维单一的问题，各种不同的思维会更大范围的覆盖各种解决方案，更多会去避免遇到问题，这是团队的<em>规避稳定性</em>。</p>\n<p>也就是说当团队过于单一的时候，规避稳定性低，容易遇到问题，但恢复稳定性高，可以更好的解决问题。而复杂度较高的时候，规避稳定性高，可以提早发现并避免问题，但恢复稳定性低，一旦碰到严重问题，风险会非常大。所以在项目管理中，为了降低风险，我们应该找到一个更平衡的点去维持住团队思维复杂度，而不应该一味的增加或降低团队思维复杂度。</p>\n<p>碎片化的结对编程恰恰是为了维持这一平衡的实践，在独立思考的团队中，每个人都将保有自己的思路，而结对的时候又会达到沟通思维的目的，使团队思维复杂度维持在一个中间水平。即能降低风险，又可以防止问题的发生。</p>\n<h6 id=\"广泛深入风险\"><a href=\"#广泛深入风险\" class=\"headerlink\" title=\"广泛深入风险\"></a>广泛深入风险</h6><p>说到风险，在敏捷中我们还提倡先做风险大的事，因为尽早发现问题暴露风险，才有更多的时间去消化风险解决问题。但往往我们很难识别风险，所以总会在低风险的用户故事中潜伏者一两个比较大的问题。</p>\n<p>在我们的项目中总是会由相关技术的专家级成员来进行提前的分析，但一个人的精力是有限的，而且我们有时候很难判断一个用户故事所涉及的技术范围具体是什么，所以不如由做的人来提前分析。然而这样又产生了一个问题，在人员较少用户故事较多的团队中（比如我们团队），第一时间我们能接触到的用户故事是有限的，碎片化的结对编程可以很好的解决这个问题。当每个人都领取一个用户故事的时候，我们可以更大范围的接触到这个迭代的用户故事，尽早的找出或碰到有风险的问题，而且在实践中，我发现这些问题往往是和好几个用户故事相关的，如此一来，相当于多人分别识别风险，然后共同解决问题，开发效率和质量也会有一定提升。</p>\n<h6 id=\"驱动\"><a href=\"#驱动\" class=\"headerlink\" title=\"驱动\"></a>驱动</h6><p>在碎片化结对编程的实践中，我们也遇到过一些问题。比如当有几个用户故事是连续依赖的时候，我们还可以分别领取这些用户故事吗？即使分别领了卡，两个人还是会工作到被依赖的那个用户故事上。但你会发现这样其实并没有回到普通的结对编程状态，一个重要区别是，两个人仍然是抱有不同目标进行开发的。一个人的目标是完成这个用户故事，而另一个人的目标是让这个用户故事为其将要做的那个用户故事服务。所以做被依赖用户故事的人会被结对对象驱动。</p>\n<p>有人会发现，这样不就是考虑太多了吗，用户故事不应该考虑以后的实现。其实这是一个平衡的过程，在成本相同的情况下，选择更好的方案肯定是没错的，关键在于不能将精力浪费在没用的东西上。而结对对象所关注的正是他挑的用户故事，他所关注的问题恰恰是除了当前的用户故事最应该被考虑的。在这种驱动和制衡下，你们会选择既能完成当前用户故事，又能让下一个依赖的用户故事更顺利的解决方案，避免一些风险。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>简而言之，碎片化的结对编程的主要思想是将一对结对对应一个用户故事的死板搭配更加合理的分散成多个结对对象对应多个特性的灵活搭配，以减少浪费。重要的是，每个人一定要形成自己独立的思维习惯，在这种实践下每个人都会自然而然的寻找自己的结对对象。</p>\n<p>当然碎片化结对编程也有其局限，在人员对敏捷实践不熟悉的情况下，贸然使用很容易导致各自独立编程不结对的情况出现，它仅是对结对编程的一种适应性改进，适合于用户故事粒度较大，人员数量较少的团队。</p>\n","site":{"data":{}},"excerpt":"<p><img src=\"/images/clastic-pair.jpg\" alt=\"clastic\"></p>\n<p>真的很久没写博客了，一直提不起兴趣，总觉得写一些代码如何写，工具如何用，过一阵子就不是很有用了，所以想写一些自己的心得体会，但又很难总结成文章。这几天突然间想通了一些，也许我是时候抛开前端这个枷锁了，今天我们来谈谈敏捷开发的结对编程。</p>\n<p>想当年（然而并没有几年）刚来到ThoughtWorks的时候，除了英语，我最不适应的就是pair，即<em>结对编程</em>。因为刚上项目的我只能跟着结对对象的思维走，即使我思路正确了也无非是在我的结对对象写的代码上印证了一下，少有的贡献就是不时的提醒他一下typo之类无关紧要的错误。然后当我拿到键盘时，还是因为信息的不对等，我无法在全局层面上做出贡献，因为我必须非常熟悉整个项目才能说服我的pair，修改一些架构上的代码，否则只能改进一些细节上的代码片段。这种毫无创造性的工作方式让我昏昏欲睡，说好的挑战，困难，压力呢？我感到了一种可有可无的迷茫。</p>","more":"<h3 id=\"不同的Pair类型\"><a href=\"#不同的Pair类型\" class=\"headerlink\" title=\"不同的Pair类型\"></a>不同的Pair类型</h3><p>接着我开始了没有什么意义的强势逆袭之路，每天回家之后熟悉代码，有时半夜还在写代码，当然没有结对编程的我只能写完checkout，仅仅是为了熟悉代码库。因为我感受到对代码库的熟悉程度某种程度上决定了结对编程时的话语权。</p>\n<p>后来终于在第四个项目上，我始终掌握了代码库最全的信息，至少在团队内是这样的。虽然进度压力仍然不小，但我们还是装模作样的进行了结对编程，这次是从项目开始我就加入了，如此，我在结对时的角色发生了变化，大部分是在给我的结对对象传授知识。慢慢的我发现我总是在写代码，我的结对对象只负责看，这样好像不太对，为什么不对呢？那时我并不知道原因，但我试着改变了风格，让对方来写，我提建议。当然有时候遇到复杂的问题，我也会急不可耐的把键盘抢过来快速搞定它，再讲解一番，接着在code review的时候发现我的结对对象并没有听懂我为什么要这么做，然而这是另外一个问题了，暂且不谈。</p>\n<p>其实上面提到的就是几种不同类型的结对方式：</p>\n<ol>\n<li><p><strong>Backseat Driver</strong></p>\n<p> 就是改变风格的我，让对方写，但还是我drive，这样至少一个在写，一个在思考，交流还是比较多的。</p>\n</li>\n<li><p><strong>Keyboard Grabber</strong></p>\n<p> 就是急不可闹抢过键盘飞快写起来的我，通常是因为双方技术和信息量差距较大，而较高一方没有耐心了。</p>\n</li>\n<li><p><strong>Silent Sleeper</strong></p>\n<p> 也就是上面提到的昏昏欲睡的我，这一般是另一方太快，而且没有说清楚自己的逻辑导致的，当然也有可能是你思维太慢，比如代码库的信息量太少。</p>\n</li>\n<li><p><strong>Sprinter</strong></p>\n<p> 在第一个项目我刚刚上手写的时候，大概我的结对对象眼中我就是个sprinter吧，总是想从架构上做一些重构，但又不会TDD，所以刚有个念头就被喊stop了。</p>\n</li>\n</ol>\n<h3 id=\"结对编程究竟为了什么\"><a href=\"#结对编程究竟为了什么\" class=\"headerlink\" title=\"结对编程究竟为了什么\"></a>结对编程究竟为了什么</h3><p>简单来说，结对编程是为了交流并传播知识，还有避免陷入思维盲区，所以要让两个人一起写代码，沟通相互的不同，在从思维差异到相通的过程中找到更棒的解决方案，最终使团队中每个人都能达到共同智慧所能达到的最高境界——思维的并集。然而从我们决定结对编程开始，一直到最高境界是有很长一段路要走的。在磨合的过程中，这恰好又是四个类型：</p>\n<ol>\n<li>高手写，新手看。</li>\n<li>新手写，高手看。</li>\n<li>两个高手相争。</li>\n<li>两个新手入坑。</li>\n</ol>\n<p>注意，这里的高手和新手只是指的相对而言，可能是对代码的信息量不同，也可能是技术方向不同导致的。</p>\n<p>前面两种其实都是在传授知识，只不过一种是直接传授，一种是通过反馈来传授。这两种情况都是在团队成员所掌握的信息不平衡时所出现的，它们的目标都是最终达到每个人的知识都是一致的。</p>\n<p>而后面两种才是项目中的常态，先让我们抛弃高手与新手这样的概念，只是两个水平和信息量相近的程序员进行结对编程。如果两人的思路差异比较大就会产生第三种情况，在某些技术点上产生分歧，然后挣的面红耳赤。最终可能是某人赢得了胜利，这样就失去了结对编程得意义，也浪费了另一个人的思维。也可能是在两边的妥协中产生了一个微妙的结果，这显然没有达到理想的状态，仅仅是思维的交集。如果两人的沟通渐入佳境，找到了和谐的思维交流方式，仍然要小心陷入第四种情况。</p>\n<p>我们知道结对编程的好处之一是防止陷入思维盲区，因为一个人的思维是有限的，很容易忽略掉一些东西而不自知，俗话说得好，旁观者清，也是这个道理。但当两人的思维渐渐一致，有了默契之后还算两个思维吗？是不是也会存在思维盲区。如此看来结对编程的目标是让两个人思维一致的理想状态，而这种理想状态又会导致没有结对时思维盲区的问题，这就像是一个悖论，难道我们只能在即将到达理想状态的时候体验一下结对编程的好处？我渐渐的发现，肯定有哪里不对。</p>\n<h3 id=\"结对编程状态模型\"><a href=\"#结对编程状态模型\" class=\"headerlink\" title=\"结对编程状态模型\"></a>结对编程状态模型</h3><p>既然两个人总在结对编程时会产生这样的问题，那我们就轮换着来，实际上很多项目就是这样做的，但通常我们会用一个小程序随意选择结对对象。看起来很科学，我们终于可以比较均匀的和其他人结对了，这样就不会和某个人变成同一个思维了。</p>\n<p>然而问题就和bug一样总是层出不穷。如果在任务粒度比较粗，而人数又不多的时候，交换结对又变得很艰难，因为你做完了这个用户故事，另一对人可能才刚发现并开始着手解决问题，此时显然不适合更换，而你和你的结对对象也不可能干等着，依赖于另一对人当前用户故事的用户故事也没法做，于是经常出现某对结对一直在做某个部分的用户故事，然而我们只能祈祷两对结对刚好差不多同时做完。这某种程度上就是所谓的理想状态，两个人变成了一个人。</p>\n<p>必须继续改进，所以我们让一个人待在用户故事上，另一个人交换。尝试了一阵子后，又有人觉得更换结对对象太频繁了，刚加入项目的新人还没来得及熟悉一个用户故事，又被换到另一个用户故事上了，最后变成了一个人在主导用户故事，另一个人始终旁观。这又变成了最初的状态，一个人做，另一个看，还是一个人的思维。</p>\n<p>虽然问题很多，但我忽然间想到了一个模型，也许能把问题简化一下，如图：<br><img src=\"/images/pair-model.jpg\" alt=\"pair model\"></p>\n<p>这条轴代表的是沟通交流的程度，可以称为结对编程的状态轴，而两个端点就是上面提及的问题的状态，没有沟通和彻底沟通都会形成单一思维，失去了结对编程的意义。在结对编程的过程中双方就会变得一致，往右边移动，如果有什么因素使得双方信息不对等或者知识不一致，就会产生分歧，往左边移动。中间的红线则代表了真正最佳的状态，有一定的沟通，但又不是一种思维，可以避免思维盲区。</p>\n<p>现在问题就简单了，我们如何驱动一对结对对象向左或者向右，将状态维持在红线附近呢？</p>\n<h3 id=\"打碎你的结对\"><a href=\"#打碎你的结对\" class=\"headerlink\" title=\"打碎你的结对\"></a>打碎你的结对</h3><p>我认为必须改变我们的目标，否则两个人的目标一致总会达成彻底的沟通。而我们的目标就是完成用户故事解决问题，所以我想到了改变两人所分配的用户故事，也就是说你和你的结对对象将不再工作在同一张卡上。这听起来有点天方夜谭，如果两个人不工作在同一张卡上还算是结对编程吗？我认为只要两个人坐在一起有交流就算是结对编程，无所谓你们的目标是什么，至少你们的共同目标还是做好项目。</p>\n<p>这样一来我们可以更容易的做一些改变，因为结对被打碎后变得更灵活了，尤其是对任务粒度粗而人数少的团队而言。</p>\n<h6 id=\"基于更细的粒度\"><a href=\"#基于更细的粒度\" class=\"headerlink\" title=\"基于更细的粒度\"></a>基于更细的粒度</h6><p>现在，我们可以更容易的交换了，你只需要找到跟你目前做的部分有可能有重叠的其他人，或者更容易实践的做法是，找到可能跟你产生代码冲突的人，跟他结对去解决可能冲突的地方。可能是一个模块，也可能是一个方法，甚至是几行公用代码。</p>\n<p>你肯定有个疑问，如果自己领的任务和其他人都没有关系怎么办。我想项目中总会有人擅长这个，或者做过类似的东西，找到他打断他目前的工作，和你一起搞定关键的部分，至少要让你明白如何做才能解决问题。如果没有这样的人，那说明也许你就是这个人，相信自己完成这个任务。或者可以找BA（业务分析师）一起结对完成，这样可以保证方向正确性。无论是什么情况，总会有办法找到你的结对对象，因为这是从你的意图出发找到的，它基于每个可能的冲突，而不是任务，所以你慢慢会发现，重要的是明确你的意图，找到方向，而不是和谁结对。</p>\n<h6 id=\"学会分解任务\"><a href=\"#学会分解任务\" class=\"headerlink\" title=\"学会分解任务\"></a>学会分解任务</h6><p>要明确意图其实很容易，先弄清楚你的需求，也就是用户故事的内容，然后细分它们。但往往我们划分的任务最后看起来并不完全正确，大部分人并不明白分解任务是为了什么，按什么维度划分，要划分成多细的粒度，因为没有驱动力，只能完全凭借经验去分解任务。</p>\n<p>现在当你一个人拿到一个用户故事后，你需要找一个结对的对象，所以你先得明确自己的任务意图，分解任务会变得很有动力。你需要考虑的是，分解出来的任务粒度是否和别人相近，否则你和其他人都会难以确定你们是否有冲突。这时你自然会明白需要具体到什么程度，以及包含哪些信息。</p>\n<p>举个例子，你拿到的用户故事需要一个可编辑的列表，你首先肯定会考虑把它存到数据库。当你分解的任务粒度比较大时，可能是“保存A列表中的元素”，这样当另外一个人也需要操作另一个类似的B列表的时候，他可能不会想到你。而任务粒度太小，比如“创建数据库表xxx_a”，也是同样的情况。所以现在你分解任务时的问题会变成，如何更广泛的匹配其他人的任务呢？这样该任务也许会变成“通过数据库存储a，并显示到A列表中，它与b业务相关”。这不需要你写出来让别人看到，只要心中明白了这些任务就可以了，最重要的是认知。</p>\n<h6 id=\"迫切需要站会\"><a href=\"#迫切需要站会\" class=\"headerlink\" title=\"迫切需要站会\"></a>迫切需要站会</h6><p>刚刚你理解了自己的用户故事，但要找到你的结对对象，还需要了解其他团队成员的用户故事，或者当前正在做的任务。这时你会想到站会，是的，在敏捷中站会是最容易实现但最难实践的一环。说最容易是因为我们只要每天早上站一起就可以像模像样了，说最难是因为很难真的被利用到，因为这是一个全员的实践，需要每个人深刻的理解其意义。</p>\n<p>我曾见过的最离谱的站会大致分为两种，一种是汇报式的，团队中层级最高的人会不自觉的站在中间，或者其他人会慢慢转向并围拢他，然后每个人向他报告自己昨天完成了什么，他们会忽略掉其他人，因为他们自己也没有向其他人讲述。另一种是结果式的，只说现在和某某正在结对，昨天完成了xx用户故事，或者正在做xx用户故事，明天准备做哪个xx用户故事，但没有任何细节和具体描述，这些信息其实看一眼物理墙就可以知道了。</p>\n<p>然而现在不一样了，每个人心中都带着一个疑问，我昨天做的会不会影响其他人，今天准备做的会不会谁能帮到我。站会将不再难以捉摸，你会迫切的想表达自己之前做的，准备做的，遇到的问题，还有更重要的是对其他人的这三个方面异常的感兴趣，他们到底在做什么。</p>\n<h6 id=\"团队思维复杂度\"><a href=\"#团队思维复杂度\" class=\"headerlink\" title=\"团队思维复杂度\"></a>团队思维复杂度</h6><p>渐渐的大家都会独立思考，不仅是思考自己做的事，还思考别人的事，因为除了你没有其他人会为了你的用户故事而思考。在一次简短的结对编程之后，你的结对对象只能确保你们之间没有冲突了，他所要的功能已经完成了，而你必须自己确保这个用户故事切实的完成了。这样，不会再有人所思考的东西是别人的子集，或者与其他人相似，每个人都有自己所要考虑的东西和目标，而其中又有许多交集。</p>\n<p>这种看起来似乎是打乱团队一致性的效果，产生了一种很有趣的现象。不过在说清楚它的优劣之前，我必须先阐述清楚一个概念。团队中所有成员的思维之间有着许多相似和矛盾，这就是<em>团队思维复杂度</em>。</p>\n<p>往往我们会不断增加团队的一致性，力求全员达成共识，这其实是在降低团队思维复杂度，这样不仅可以降低管理成本，还可以在有问题的时候及时调整，因为每个人得思想都是较为一致的，所以解决问题的能力较强，这叫做团队的<em>恢复稳定性</em>。但同时团队的思维和解决办法过于单一，容易陷入各种问题中，也就是所谓的一条腿走路的弊端。而如果团队过于复杂，每个人都有自己的想法，矛盾和制约无处不在，此时的团队很难被改变，却避免了前面所说的思维单一的问题，各种不同的思维会更大范围的覆盖各种解决方案，更多会去避免遇到问题，这是团队的<em>规避稳定性</em>。</p>\n<p>也就是说当团队过于单一的时候，规避稳定性低，容易遇到问题，但恢复稳定性高，可以更好的解决问题。而复杂度较高的时候，规避稳定性高，可以提早发现并避免问题，但恢复稳定性低，一旦碰到严重问题，风险会非常大。所以在项目管理中，为了降低风险，我们应该找到一个更平衡的点去维持住团队思维复杂度，而不应该一味的增加或降低团队思维复杂度。</p>\n<p>碎片化的结对编程恰恰是为了维持这一平衡的实践，在独立思考的团队中，每个人都将保有自己的思路，而结对的时候又会达到沟通思维的目的，使团队思维复杂度维持在一个中间水平。即能降低风险，又可以防止问题的发生。</p>\n<h6 id=\"广泛深入风险\"><a href=\"#广泛深入风险\" class=\"headerlink\" title=\"广泛深入风险\"></a>广泛深入风险</h6><p>说到风险，在敏捷中我们还提倡先做风险大的事，因为尽早发现问题暴露风险，才有更多的时间去消化风险解决问题。但往往我们很难识别风险，所以总会在低风险的用户故事中潜伏者一两个比较大的问题。</p>\n<p>在我们的项目中总是会由相关技术的专家级成员来进行提前的分析，但一个人的精力是有限的，而且我们有时候很难判断一个用户故事所涉及的技术范围具体是什么，所以不如由做的人来提前分析。然而这样又产生了一个问题，在人员较少用户故事较多的团队中（比如我们团队），第一时间我们能接触到的用户故事是有限的，碎片化的结对编程可以很好的解决这个问题。当每个人都领取一个用户故事的时候，我们可以更大范围的接触到这个迭代的用户故事，尽早的找出或碰到有风险的问题，而且在实践中，我发现这些问题往往是和好几个用户故事相关的，如此一来，相当于多人分别识别风险，然后共同解决问题，开发效率和质量也会有一定提升。</p>\n<h6 id=\"驱动\"><a href=\"#驱动\" class=\"headerlink\" title=\"驱动\"></a>驱动</h6><p>在碎片化结对编程的实践中，我们也遇到过一些问题。比如当有几个用户故事是连续依赖的时候，我们还可以分别领取这些用户故事吗？即使分别领了卡，两个人还是会工作到被依赖的那个用户故事上。但你会发现这样其实并没有回到普通的结对编程状态，一个重要区别是，两个人仍然是抱有不同目标进行开发的。一个人的目标是完成这个用户故事，而另一个人的目标是让这个用户故事为其将要做的那个用户故事服务。所以做被依赖用户故事的人会被结对对象驱动。</p>\n<p>有人会发现，这样不就是考虑太多了吗，用户故事不应该考虑以后的实现。其实这是一个平衡的过程，在成本相同的情况下，选择更好的方案肯定是没错的，关键在于不能将精力浪费在没用的东西上。而结对对象所关注的正是他挑的用户故事，他所关注的问题恰恰是除了当前的用户故事最应该被考虑的。在这种驱动和制衡下，你们会选择既能完成当前用户故事，又能让下一个依赖的用户故事更顺利的解决方案，避免一些风险。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>简而言之，碎片化的结对编程的主要思想是将一对结对对应一个用户故事的死板搭配更加合理的分散成多个结对对象对应多个特性的灵活搭配，以减少浪费。重要的是，每个人一定要形成自己独立的思维习惯，在这种实践下每个人都会自然而然的寻找自己的结对对象。</p>\n<p>当然碎片化结对编程也有其局限，在人员对敏捷实践不熟悉的情况下，贸然使用很容易导致各自独立编程不结对的情况出现，它仅是对结对编程的一种适应性改进，适合于用户故事粒度较大，人员数量较少的团队。</p>"},{"layout":"post","title":"后MVC时代的前端架构","_content":"\n![component](/images/component.jpg)\n\n很多人觉得，前后端的差异主要是分别承载了数据和样式，功能和皮肤。前端就是视觉方面的，后端是实质性的。追溯到很多年前，确实是这样的，所谓的前端只是由于后端MVC中的View过于复杂，为了提升用户体验，提高加载速度，以及降低服务器压力，所衍生出的一些优化技术。\n<!-- more -->\n\n## 前端框架演进\n最初前端没有架构，也不需要。但随着UI交互的复杂度激增，我们发现API提供的数据仍然需要进行处理，再进行渲染，而分离这些需要处理的数据和视觉渲染部分后又需要一层进行控制，自然而然，将后端的MVC照搬了过来。但其实人们并没有发现，并不是我们把MVC搬到了前端，而是把后端的V搬到前端之后又分成了MVC，这个问题暂且搁下，后面会解释。\n\n接着前端又再一次的变得复杂，尤其是不同交互对于同一资源的操作，导致过程化的控制器过于臃肿，而不堪重负，MVVM应运而生。人们都以为，MVVM就是把C变成了ViewModel，但是ViewModel是一个实体，如何控制呢？真正用会MVVM的开发者都会发现，MVVM提倡的是定义而不是控制，定义M和V的关系，什么样的Model应该呈现什么样的View，然后一切自然而然的随着用户的行为去改变。\n\n其实原先的C被更高度的抽象了，变成了框架的一部分，读取M和V的关系，并监听他们，在一方改变的时候根据关系修改另一方，达到双向绑定。而ViewModel其实是为了描述这一关系而抽象出来的Model，因为它是相对于Model更偏向View的，所以叫ViewModel。接着出现的一系列MVWhatever很好的说明了ViewModel并不是C变的，人们以为既然C可以变成VM，那也可以变成别的。殊不知，ViewModel也是一种Model，它是由View分裂出来的，而View只能分裂出Model和View，不会出现别的。\n\n## 样式和数据的区别\nReact横空出世，却没有人能说清楚它到底是MV什么，甚至许多人搞不清M在哪，最后干脆说React就是个View。那么React到底是什么架构呢？先别急，我想先讲一个故事：\n\n> 有一个语言学者提出一个观点 - 法国人的数学很烂，为什么呢？因为法语中的quatre-vingt（80）的意思是 4个20，居然都不会把4乘以20计算出来，是不是数学很差？\n\n第一次听到这个故事，我感到很好笑，难道汉语就不是这样了吗？我们叫做“八十”，其实还是8个10，和4个20有什么区别，还不是都没有计算。后来再一想，不仅不是，而且法国人数学应该很好，因为汉语遵循了现代通用的10进制，而法语是20进制和10进制混合的，所以他们大脑可以自然的映射10进制和20进制，就好比是左撇子为了迎合右撇子的世界而变得思维敏捷一样的道理。\n\n讲到这里，可能你会觉得莫名其妙，这跟前端有什么关系。其实我只是想说明一个道理，我们经常会被一瞬间的思考误导，比如这个故事中，人们会把习惯的“八十”看做是一个独立的东西，而嘲笑法国人他们的“quatre-vingt”，其实我们只是习惯了这种计算，或者说在大脑中建立了映射，就忽略了计算，而将其看做一个整体。由此说明，我们在看到一个信息的时候是会进行无意识计算的，从而你会认为你看到的就是那个东西本身，并不需要计算。我们认为“八十”是一个对象，而不是表达式，但事实是没有符号可以表达80这个数，所以用‘八个十’的表达式来表示，只不过我们太熟练所以自动计算了。\n\n抛弃固有思维，现在假设@为81进制数的最大数，既80，再假设有一种操作符可以把十进制变成81进制数，这一过程是不是数据的计算？但如果有一种字体格式可以把连在一起的8和0两个数字变成@的样子，这算不算样式的改变？也许你会觉得通过操作符是在计算机中当做了@，而字体只是长得像，但计算机真正认识的只有可能是二进制binary，所以整个过程是不是也可以看做都是样式？还有人会说，数据无论变成什么样式它本身都不会变，而样式会变。但如果显示器有色差呢，你看到的蓝色就真的是蓝色吗？样式没变，你看到的仍然会变。\n\n其实数据和样式本质没有区别，区别只在于程度，从计算机到人类的理解程度。差异来自于我们自己，我们把难以理解的叫数据，容易理解的叫样式，计算时间长的叫数据，计算时间短的叫样式。一个矩形你知道是样式，一个长xx，宽xx，边框为xx的东西你会以为是数据，但对于程序来说其实是一样的。处理一下，得到另一种形式的等同的东西，这就是一个不断翻译的过程，从二进制翻译到人类语言，甚至到非语言的一种印象，比如视觉，语音，甚至意识。无论是什么，都是让人类更容易理解。\n\n## Component架构\n耗费了这么大的篇幅说明样式和数据没有区别的目的其实是为了解释React的架构。前面说到的MVC和MVVM其实都是对于View的一种演进，因为所谓View才是最复杂的，为什么说所谓呢，基于前面的结论，View就是Model，但它是人们难以理解的部分，所以没有被抽象为Model，而是直接显示出来让用户自己去读。为了便于理解，想象一种极端的情况，Model只有二进制形式，直接显示给了用户，理论上来说，用户是可以看懂的，只是难度高了一点点。而从View抽象成Model的过程，其实就是程序将二进制翻译出来的过程。而框架的所做的改进就是翻译程度的提升，让用户更容易的读取。\n\n回到React身上，它的架构就十分清晰了，前面的MVC是把后端的View分离出了一部分Model，而MVVM，是把MVC的V又分离了一部分Model出来。React所做的犹如它的版本号一般，直接起飞，每个Component其实都是View分离出来的Model，理论上来说，你能抽象出无限层Component，这个极限上，View已经简单的没有意义了。而实际来说，你可以视项目情况而定，把View抽象到某个程度后扔给用户自己阅读。而由于分成无数层，M到V的过程也变得简单，不再需要控制，因为复杂的计算已经被分解成了极简单的计算分散到每一层中了，甚至有时候仅仅是Component为传入的props加上一些字面量，然后传入另一个Component，或者是分解或组合成Object再向下传递。一旦真的理解了View即是Model的思想，你就会发现，React似乎什么也没做，其实却把什么都做了，而且非常简单。\n\n但Component这种架构也有其问题所在，那就是太过于松散，对架构设计的要求比较高。一旦你并非基于由机器到人类的理解程度来抽象分层你的Component，其复用性和扩展性就会大大降低。\n\n## 前端面向对象\n前面说到了View和Model没有本质上的区别，那么前端架构和后端架构为什么会有区别呢？原因很简单，后端可以把未翻译完的数据丢给前端，但前端不能随随便便丢给用户，所以前端变成了多层MV，而不是后端简单的分为了一层MV。前端面向对象的设计也更加的困难，尤其是拥有多年后端开发经验的开发人员，更容易误导自己，因为在后端翻译完成的东西，在前端就变成了最原始的东西。\n\n举个例子，就拿最常见的电商说事吧，设计一个商品页面的Component架构。在拥有所谓数据的时候，它是某一个商品的页面，比如一件印着国旗的T恤。但显然我们的代码库在运行之前是没有这个从数据库传过来的数据的，所以我们没法把它抽象成一个叫做NationalFlagTShirtPage的Component的。退而求其次，在失去后端数据之后，它应该是一个衣服类的商品页面，比如有一些尺码对照和试衣功能，所以可以有一个叫做ClothesShowcase的Component。说到后端数据的这一层，并不是为了搞笑，它反映出了一个问题。其实后端对于前端，就是上一层的Component。同理，在下一层的Component中，我们也应该忽视这一层传入到下一层的数据，因为它不应该有这个数据。\n\n比如ClothesPage还应该包含一个显示图片的区域，和一个显示尺码信息的区域。这时，很多人会在ClothesShowcase的里面再放一个ClothesImage和ClothesInformation，但是在上一层作为代码一部分的'Clothes'，在这一层应该已经被忽略，我们应该放入ProductImage和SizeInformation。只有当ClothesPage调用SizeInformation并传入'S'，'M'，'L'之类衣服尺码作为参数的时候，它才是衣服尺寸，而它自身应该仅仅是尺寸信息的Component。我们会发现，上一层的代码（字面量'L'等），变成了下一层的数据，如此一直下去，所有的特性都会变成数据，而代码，可能仅仅是一些最基础的元素，比如按钮，方框之类的，甚至是HTML本身。\n\n如果一直使用对于后端来说的数据层面的'clothes'的话，就只能一次把ClothesPage这个Component写好，而没法继续抽象了。而其子Component可能仅仅是由于过于臃肿而强行分割的patial了。这样做除了代码短一些之外，完全不具有复用性和扩展性，因为ClothesPage下的所有Component都只能为Clothes服务了。而其他每个概念都必须把这一切重复一遍。\n\n如果走入另一种极端呢，抽象出一种万用Component，只要传入一个大而全的object，就可以渲染出任意的页面。这个时候虽然复用性有了，但是你会发现你什么也没做，因为这个Component就是HTML的另一层封装，那些传入的参数包含了所有数据，你需要把这些不同的数据同化。\n\n归根结底，Component架构的精髓在于多层，按照人类理解程度分层。否则永远无法分清楚什么是数据，什么是样式，因为它们只会在某一层中有划分。混乱的分层只会导致架构回归到传统的MVC两层结构中去。也因此，前端面向对象必须基于一层，脱离了某一层而论对象或类，都是可笑的，一个类，到了下一层可能就是一个实例。\n","source":"_posts/2017-02-17-frontend-architecture.md","raw":"---\nlayout: post\ntitle: 后MVC时代的前端架构\ntags: [mvc, mvvm, react, architecture, frontend]\ncategory: Tech\n---\n\n![component](/images/component.jpg)\n\n很多人觉得，前后端的差异主要是分别承载了数据和样式，功能和皮肤。前端就是视觉方面的，后端是实质性的。追溯到很多年前，确实是这样的，所谓的前端只是由于后端MVC中的View过于复杂，为了提升用户体验，提高加载速度，以及降低服务器压力，所衍生出的一些优化技术。\n<!-- more -->\n\n## 前端框架演进\n最初前端没有架构，也不需要。但随着UI交互的复杂度激增，我们发现API提供的数据仍然需要进行处理，再进行渲染，而分离这些需要处理的数据和视觉渲染部分后又需要一层进行控制，自然而然，将后端的MVC照搬了过来。但其实人们并没有发现，并不是我们把MVC搬到了前端，而是把后端的V搬到前端之后又分成了MVC，这个问题暂且搁下，后面会解释。\n\n接着前端又再一次的变得复杂，尤其是不同交互对于同一资源的操作，导致过程化的控制器过于臃肿，而不堪重负，MVVM应运而生。人们都以为，MVVM就是把C变成了ViewModel，但是ViewModel是一个实体，如何控制呢？真正用会MVVM的开发者都会发现，MVVM提倡的是定义而不是控制，定义M和V的关系，什么样的Model应该呈现什么样的View，然后一切自然而然的随着用户的行为去改变。\n\n其实原先的C被更高度的抽象了，变成了框架的一部分，读取M和V的关系，并监听他们，在一方改变的时候根据关系修改另一方，达到双向绑定。而ViewModel其实是为了描述这一关系而抽象出来的Model，因为它是相对于Model更偏向View的，所以叫ViewModel。接着出现的一系列MVWhatever很好的说明了ViewModel并不是C变的，人们以为既然C可以变成VM，那也可以变成别的。殊不知，ViewModel也是一种Model，它是由View分裂出来的，而View只能分裂出Model和View，不会出现别的。\n\n## 样式和数据的区别\nReact横空出世，却没有人能说清楚它到底是MV什么，甚至许多人搞不清M在哪，最后干脆说React就是个View。那么React到底是什么架构呢？先别急，我想先讲一个故事：\n\n> 有一个语言学者提出一个观点 - 法国人的数学很烂，为什么呢？因为法语中的quatre-vingt（80）的意思是 4个20，居然都不会把4乘以20计算出来，是不是数学很差？\n\n第一次听到这个故事，我感到很好笑，难道汉语就不是这样了吗？我们叫做“八十”，其实还是8个10，和4个20有什么区别，还不是都没有计算。后来再一想，不仅不是，而且法国人数学应该很好，因为汉语遵循了现代通用的10进制，而法语是20进制和10进制混合的，所以他们大脑可以自然的映射10进制和20进制，就好比是左撇子为了迎合右撇子的世界而变得思维敏捷一样的道理。\n\n讲到这里，可能你会觉得莫名其妙，这跟前端有什么关系。其实我只是想说明一个道理，我们经常会被一瞬间的思考误导，比如这个故事中，人们会把习惯的“八十”看做是一个独立的东西，而嘲笑法国人他们的“quatre-vingt”，其实我们只是习惯了这种计算，或者说在大脑中建立了映射，就忽略了计算，而将其看做一个整体。由此说明，我们在看到一个信息的时候是会进行无意识计算的，从而你会认为你看到的就是那个东西本身，并不需要计算。我们认为“八十”是一个对象，而不是表达式，但事实是没有符号可以表达80这个数，所以用‘八个十’的表达式来表示，只不过我们太熟练所以自动计算了。\n\n抛弃固有思维，现在假设@为81进制数的最大数，既80，再假设有一种操作符可以把十进制变成81进制数，这一过程是不是数据的计算？但如果有一种字体格式可以把连在一起的8和0两个数字变成@的样子，这算不算样式的改变？也许你会觉得通过操作符是在计算机中当做了@，而字体只是长得像，但计算机真正认识的只有可能是二进制binary，所以整个过程是不是也可以看做都是样式？还有人会说，数据无论变成什么样式它本身都不会变，而样式会变。但如果显示器有色差呢，你看到的蓝色就真的是蓝色吗？样式没变，你看到的仍然会变。\n\n其实数据和样式本质没有区别，区别只在于程度，从计算机到人类的理解程度。差异来自于我们自己，我们把难以理解的叫数据，容易理解的叫样式，计算时间长的叫数据，计算时间短的叫样式。一个矩形你知道是样式，一个长xx，宽xx，边框为xx的东西你会以为是数据，但对于程序来说其实是一样的。处理一下，得到另一种形式的等同的东西，这就是一个不断翻译的过程，从二进制翻译到人类语言，甚至到非语言的一种印象，比如视觉，语音，甚至意识。无论是什么，都是让人类更容易理解。\n\n## Component架构\n耗费了这么大的篇幅说明样式和数据没有区别的目的其实是为了解释React的架构。前面说到的MVC和MVVM其实都是对于View的一种演进，因为所谓View才是最复杂的，为什么说所谓呢，基于前面的结论，View就是Model，但它是人们难以理解的部分，所以没有被抽象为Model，而是直接显示出来让用户自己去读。为了便于理解，想象一种极端的情况，Model只有二进制形式，直接显示给了用户，理论上来说，用户是可以看懂的，只是难度高了一点点。而从View抽象成Model的过程，其实就是程序将二进制翻译出来的过程。而框架的所做的改进就是翻译程度的提升，让用户更容易的读取。\n\n回到React身上，它的架构就十分清晰了，前面的MVC是把后端的View分离出了一部分Model，而MVVM，是把MVC的V又分离了一部分Model出来。React所做的犹如它的版本号一般，直接起飞，每个Component其实都是View分离出来的Model，理论上来说，你能抽象出无限层Component，这个极限上，View已经简单的没有意义了。而实际来说，你可以视项目情况而定，把View抽象到某个程度后扔给用户自己阅读。而由于分成无数层，M到V的过程也变得简单，不再需要控制，因为复杂的计算已经被分解成了极简单的计算分散到每一层中了，甚至有时候仅仅是Component为传入的props加上一些字面量，然后传入另一个Component，或者是分解或组合成Object再向下传递。一旦真的理解了View即是Model的思想，你就会发现，React似乎什么也没做，其实却把什么都做了，而且非常简单。\n\n但Component这种架构也有其问题所在，那就是太过于松散，对架构设计的要求比较高。一旦你并非基于由机器到人类的理解程度来抽象分层你的Component，其复用性和扩展性就会大大降低。\n\n## 前端面向对象\n前面说到了View和Model没有本质上的区别，那么前端架构和后端架构为什么会有区别呢？原因很简单，后端可以把未翻译完的数据丢给前端，但前端不能随随便便丢给用户，所以前端变成了多层MV，而不是后端简单的分为了一层MV。前端面向对象的设计也更加的困难，尤其是拥有多年后端开发经验的开发人员，更容易误导自己，因为在后端翻译完成的东西，在前端就变成了最原始的东西。\n\n举个例子，就拿最常见的电商说事吧，设计一个商品页面的Component架构。在拥有所谓数据的时候，它是某一个商品的页面，比如一件印着国旗的T恤。但显然我们的代码库在运行之前是没有这个从数据库传过来的数据的，所以我们没法把它抽象成一个叫做NationalFlagTShirtPage的Component的。退而求其次，在失去后端数据之后，它应该是一个衣服类的商品页面，比如有一些尺码对照和试衣功能，所以可以有一个叫做ClothesShowcase的Component。说到后端数据的这一层，并不是为了搞笑，它反映出了一个问题。其实后端对于前端，就是上一层的Component。同理，在下一层的Component中，我们也应该忽视这一层传入到下一层的数据，因为它不应该有这个数据。\n\n比如ClothesPage还应该包含一个显示图片的区域，和一个显示尺码信息的区域。这时，很多人会在ClothesShowcase的里面再放一个ClothesImage和ClothesInformation，但是在上一层作为代码一部分的'Clothes'，在这一层应该已经被忽略，我们应该放入ProductImage和SizeInformation。只有当ClothesPage调用SizeInformation并传入'S'，'M'，'L'之类衣服尺码作为参数的时候，它才是衣服尺寸，而它自身应该仅仅是尺寸信息的Component。我们会发现，上一层的代码（字面量'L'等），变成了下一层的数据，如此一直下去，所有的特性都会变成数据，而代码，可能仅仅是一些最基础的元素，比如按钮，方框之类的，甚至是HTML本身。\n\n如果一直使用对于后端来说的数据层面的'clothes'的话，就只能一次把ClothesPage这个Component写好，而没法继续抽象了。而其子Component可能仅仅是由于过于臃肿而强行分割的patial了。这样做除了代码短一些之外，完全不具有复用性和扩展性，因为ClothesPage下的所有Component都只能为Clothes服务了。而其他每个概念都必须把这一切重复一遍。\n\n如果走入另一种极端呢，抽象出一种万用Component，只要传入一个大而全的object，就可以渲染出任意的页面。这个时候虽然复用性有了，但是你会发现你什么也没做，因为这个Component就是HTML的另一层封装，那些传入的参数包含了所有数据，你需要把这些不同的数据同化。\n\n归根结底，Component架构的精髓在于多层，按照人类理解程度分层。否则永远无法分清楚什么是数据，什么是样式，因为它们只会在某一层中有划分。混乱的分层只会导致架构回归到传统的MVC两层结构中去。也因此，前端面向对象必须基于一层，脱离了某一层而论对象或类，都是可笑的，一个类，到了下一层可能就是一个实例。\n","slug":"frontend-architecture","published":1,"date":"2017-02-16T16:00:00.000Z","updated":"2021-11-28T11:59:29.970Z","_id":"ckwj6551c001evyjha7rzc6rw","comments":1,"photos":[],"link":"","content":"<p><img src=\"/images/component.jpg\" alt=\"component\"></p>\n<p>很多人觉得，前后端的差异主要是分别承载了数据和样式，功能和皮肤。前端就是视觉方面的，后端是实质性的。追溯到很多年前，确实是这样的，所谓的前端只是由于后端MVC中的View过于复杂，为了提升用户体验，提高加载速度，以及降低服务器压力，所衍生出的一些优化技术。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"前端框架演进\"><a href=\"#前端框架演进\" class=\"headerlink\" title=\"前端框架演进\"></a>前端框架演进</h2><p>最初前端没有架构，也不需要。但随着UI交互的复杂度激增，我们发现API提供的数据仍然需要进行处理，再进行渲染，而分离这些需要处理的数据和视觉渲染部分后又需要一层进行控制，自然而然，将后端的MVC照搬了过来。但其实人们并没有发现，并不是我们把MVC搬到了前端，而是把后端的V搬到前端之后又分成了MVC，这个问题暂且搁下，后面会解释。</p>\n<p>接着前端又再一次的变得复杂，尤其是不同交互对于同一资源的操作，导致过程化的控制器过于臃肿，而不堪重负，MVVM应运而生。人们都以为，MVVM就是把C变成了ViewModel，但是ViewModel是一个实体，如何控制呢？真正用会MVVM的开发者都会发现，MVVM提倡的是定义而不是控制，定义M和V的关系，什么样的Model应该呈现什么样的View，然后一切自然而然的随着用户的行为去改变。</p>\n<p>其实原先的C被更高度的抽象了，变成了框架的一部分，读取M和V的关系，并监听他们，在一方改变的时候根据关系修改另一方，达到双向绑定。而ViewModel其实是为了描述这一关系而抽象出来的Model，因为它是相对于Model更偏向View的，所以叫ViewModel。接着出现的一系列MVWhatever很好的说明了ViewModel并不是C变的，人们以为既然C可以变成VM，那也可以变成别的。殊不知，ViewModel也是一种Model，它是由View分裂出来的，而View只能分裂出Model和View，不会出现别的。</p>\n<h2 id=\"样式和数据的区别\"><a href=\"#样式和数据的区别\" class=\"headerlink\" title=\"样式和数据的区别\"></a>样式和数据的区别</h2><p>React横空出世，却没有人能说清楚它到底是MV什么，甚至许多人搞不清M在哪，最后干脆说React就是个View。那么React到底是什么架构呢？先别急，我想先讲一个故事：</p>\n<blockquote>\n<p>有一个语言学者提出一个观点 - 法国人的数学很烂，为什么呢？因为法语中的quatre-vingt（80）的意思是 4个20，居然都不会把4乘以20计算出来，是不是数学很差？</p>\n</blockquote>\n<p>第一次听到这个故事，我感到很好笑，难道汉语就不是这样了吗？我们叫做“八十”，其实还是8个10，和4个20有什么区别，还不是都没有计算。后来再一想，不仅不是，而且法国人数学应该很好，因为汉语遵循了现代通用的10进制，而法语是20进制和10进制混合的，所以他们大脑可以自然的映射10进制和20进制，就好比是左撇子为了迎合右撇子的世界而变得思维敏捷一样的道理。</p>\n<p>讲到这里，可能你会觉得莫名其妙，这跟前端有什么关系。其实我只是想说明一个道理，我们经常会被一瞬间的思考误导，比如这个故事中，人们会把习惯的“八十”看做是一个独立的东西，而嘲笑法国人他们的“quatre-vingt”，其实我们只是习惯了这种计算，或者说在大脑中建立了映射，就忽略了计算，而将其看做一个整体。由此说明，我们在看到一个信息的时候是会进行无意识计算的，从而你会认为你看到的就是那个东西本身，并不需要计算。我们认为“八十”是一个对象，而不是表达式，但事实是没有符号可以表达80这个数，所以用‘八个十’的表达式来表示，只不过我们太熟练所以自动计算了。</p>\n<p>抛弃固有思维，现在假设@为81进制数的最大数，既80，再假设有一种操作符可以把十进制变成81进制数，这一过程是不是数据的计算？但如果有一种字体格式可以把连在一起的8和0两个数字变成@的样子，这算不算样式的改变？也许你会觉得通过操作符是在计算机中当做了@，而字体只是长得像，但计算机真正认识的只有可能是二进制binary，所以整个过程是不是也可以看做都是样式？还有人会说，数据无论变成什么样式它本身都不会变，而样式会变。但如果显示器有色差呢，你看到的蓝色就真的是蓝色吗？样式没变，你看到的仍然会变。</p>\n<p>其实数据和样式本质没有区别，区别只在于程度，从计算机到人类的理解程度。差异来自于我们自己，我们把难以理解的叫数据，容易理解的叫样式，计算时间长的叫数据，计算时间短的叫样式。一个矩形你知道是样式，一个长xx，宽xx，边框为xx的东西你会以为是数据，但对于程序来说其实是一样的。处理一下，得到另一种形式的等同的东西，这就是一个不断翻译的过程，从二进制翻译到人类语言，甚至到非语言的一种印象，比如视觉，语音，甚至意识。无论是什么，都是让人类更容易理解。</p>\n<h2 id=\"Component架构\"><a href=\"#Component架构\" class=\"headerlink\" title=\"Component架构\"></a>Component架构</h2><p>耗费了这么大的篇幅说明样式和数据没有区别的目的其实是为了解释React的架构。前面说到的MVC和MVVM其实都是对于View的一种演进，因为所谓View才是最复杂的，为什么说所谓呢，基于前面的结论，View就是Model，但它是人们难以理解的部分，所以没有被抽象为Model，而是直接显示出来让用户自己去读。为了便于理解，想象一种极端的情况，Model只有二进制形式，直接显示给了用户，理论上来说，用户是可以看懂的，只是难度高了一点点。而从View抽象成Model的过程，其实就是程序将二进制翻译出来的过程。而框架的所做的改进就是翻译程度的提升，让用户更容易的读取。</p>\n<p>回到React身上，它的架构就十分清晰了，前面的MVC是把后端的View分离出了一部分Model，而MVVM，是把MVC的V又分离了一部分Model出来。React所做的犹如它的版本号一般，直接起飞，每个Component其实都是View分离出来的Model，理论上来说，你能抽象出无限层Component，这个极限上，View已经简单的没有意义了。而实际来说，你可以视项目情况而定，把View抽象到某个程度后扔给用户自己阅读。而由于分成无数层，M到V的过程也变得简单，不再需要控制，因为复杂的计算已经被分解成了极简单的计算分散到每一层中了，甚至有时候仅仅是Component为传入的props加上一些字面量，然后传入另一个Component，或者是分解或组合成Object再向下传递。一旦真的理解了View即是Model的思想，你就会发现，React似乎什么也没做，其实却把什么都做了，而且非常简单。</p>\n<p>但Component这种架构也有其问题所在，那就是太过于松散，对架构设计的要求比较高。一旦你并非基于由机器到人类的理解程度来抽象分层你的Component，其复用性和扩展性就会大大降低。</p>\n<h2 id=\"前端面向对象\"><a href=\"#前端面向对象\" class=\"headerlink\" title=\"前端面向对象\"></a>前端面向对象</h2><p>前面说到了View和Model没有本质上的区别，那么前端架构和后端架构为什么会有区别呢？原因很简单，后端可以把未翻译完的数据丢给前端，但前端不能随随便便丢给用户，所以前端变成了多层MV，而不是后端简单的分为了一层MV。前端面向对象的设计也更加的困难，尤其是拥有多年后端开发经验的开发人员，更容易误导自己，因为在后端翻译完成的东西，在前端就变成了最原始的东西。</p>\n<p>举个例子，就拿最常见的电商说事吧，设计一个商品页面的Component架构。在拥有所谓数据的时候，它是某一个商品的页面，比如一件印着国旗的T恤。但显然我们的代码库在运行之前是没有这个从数据库传过来的数据的，所以我们没法把它抽象成一个叫做NationalFlagTShirtPage的Component的。退而求其次，在失去后端数据之后，它应该是一个衣服类的商品页面，比如有一些尺码对照和试衣功能，所以可以有一个叫做ClothesShowcase的Component。说到后端数据的这一层，并不是为了搞笑，它反映出了一个问题。其实后端对于前端，就是上一层的Component。同理，在下一层的Component中，我们也应该忽视这一层传入到下一层的数据，因为它不应该有这个数据。</p>\n<p>比如ClothesPage还应该包含一个显示图片的区域，和一个显示尺码信息的区域。这时，很多人会在ClothesShowcase的里面再放一个ClothesImage和ClothesInformation，但是在上一层作为代码一部分的’Clothes’，在这一层应该已经被忽略，我们应该放入ProductImage和SizeInformation。只有当ClothesPage调用SizeInformation并传入’S’，’M’，’L’之类衣服尺码作为参数的时候，它才是衣服尺寸，而它自身应该仅仅是尺寸信息的Component。我们会发现，上一层的代码（字面量’L’等），变成了下一层的数据，如此一直下去，所有的特性都会变成数据，而代码，可能仅仅是一些最基础的元素，比如按钮，方框之类的，甚至是HTML本身。</p>\n<p>如果一直使用对于后端来说的数据层面的’clothes’的话，就只能一次把ClothesPage这个Component写好，而没法继续抽象了。而其子Component可能仅仅是由于过于臃肿而强行分割的patial了。这样做除了代码短一些之外，完全不具有复用性和扩展性，因为ClothesPage下的所有Component都只能为Clothes服务了。而其他每个概念都必须把这一切重复一遍。</p>\n<p>如果走入另一种极端呢，抽象出一种万用Component，只要传入一个大而全的object，就可以渲染出任意的页面。这个时候虽然复用性有了，但是你会发现你什么也没做，因为这个Component就是HTML的另一层封装，那些传入的参数包含了所有数据，你需要把这些不同的数据同化。</p>\n<p>归根结底，Component架构的精髓在于多层，按照人类理解程度分层。否则永远无法分清楚什么是数据，什么是样式，因为它们只会在某一层中有划分。混乱的分层只会导致架构回归到传统的MVC两层结构中去。也因此，前端面向对象必须基于一层，脱离了某一层而论对象或类，都是可笑的，一个类，到了下一层可能就是一个实例。</p>\n","site":{"data":{}},"excerpt":"<p><img src=\"/images/component.jpg\" alt=\"component\"></p>\n<p>很多人觉得，前后端的差异主要是分别承载了数据和样式，功能和皮肤。前端就是视觉方面的，后端是实质性的。追溯到很多年前，确实是这样的，所谓的前端只是由于后端MVC中的View过于复杂，为了提升用户体验，提高加载速度，以及降低服务器压力，所衍生出的一些优化技术。</p>","more":"<h2 id=\"前端框架演进\"><a href=\"#前端框架演进\" class=\"headerlink\" title=\"前端框架演进\"></a>前端框架演进</h2><p>最初前端没有架构，也不需要。但随着UI交互的复杂度激增，我们发现API提供的数据仍然需要进行处理，再进行渲染，而分离这些需要处理的数据和视觉渲染部分后又需要一层进行控制，自然而然，将后端的MVC照搬了过来。但其实人们并没有发现，并不是我们把MVC搬到了前端，而是把后端的V搬到前端之后又分成了MVC，这个问题暂且搁下，后面会解释。</p>\n<p>接着前端又再一次的变得复杂，尤其是不同交互对于同一资源的操作，导致过程化的控制器过于臃肿，而不堪重负，MVVM应运而生。人们都以为，MVVM就是把C变成了ViewModel，但是ViewModel是一个实体，如何控制呢？真正用会MVVM的开发者都会发现，MVVM提倡的是定义而不是控制，定义M和V的关系，什么样的Model应该呈现什么样的View，然后一切自然而然的随着用户的行为去改变。</p>\n<p>其实原先的C被更高度的抽象了，变成了框架的一部分，读取M和V的关系，并监听他们，在一方改变的时候根据关系修改另一方，达到双向绑定。而ViewModel其实是为了描述这一关系而抽象出来的Model，因为它是相对于Model更偏向View的，所以叫ViewModel。接着出现的一系列MVWhatever很好的说明了ViewModel并不是C变的，人们以为既然C可以变成VM，那也可以变成别的。殊不知，ViewModel也是一种Model，它是由View分裂出来的，而View只能分裂出Model和View，不会出现别的。</p>\n<h2 id=\"样式和数据的区别\"><a href=\"#样式和数据的区别\" class=\"headerlink\" title=\"样式和数据的区别\"></a>样式和数据的区别</h2><p>React横空出世，却没有人能说清楚它到底是MV什么，甚至许多人搞不清M在哪，最后干脆说React就是个View。那么React到底是什么架构呢？先别急，我想先讲一个故事：</p>\n<blockquote>\n<p>有一个语言学者提出一个观点 - 法国人的数学很烂，为什么呢？因为法语中的quatre-vingt（80）的意思是 4个20，居然都不会把4乘以20计算出来，是不是数学很差？</p>\n</blockquote>\n<p>第一次听到这个故事，我感到很好笑，难道汉语就不是这样了吗？我们叫做“八十”，其实还是8个10，和4个20有什么区别，还不是都没有计算。后来再一想，不仅不是，而且法国人数学应该很好，因为汉语遵循了现代通用的10进制，而法语是20进制和10进制混合的，所以他们大脑可以自然的映射10进制和20进制，就好比是左撇子为了迎合右撇子的世界而变得思维敏捷一样的道理。</p>\n<p>讲到这里，可能你会觉得莫名其妙，这跟前端有什么关系。其实我只是想说明一个道理，我们经常会被一瞬间的思考误导，比如这个故事中，人们会把习惯的“八十”看做是一个独立的东西，而嘲笑法国人他们的“quatre-vingt”，其实我们只是习惯了这种计算，或者说在大脑中建立了映射，就忽略了计算，而将其看做一个整体。由此说明，我们在看到一个信息的时候是会进行无意识计算的，从而你会认为你看到的就是那个东西本身，并不需要计算。我们认为“八十”是一个对象，而不是表达式，但事实是没有符号可以表达80这个数，所以用‘八个十’的表达式来表示，只不过我们太熟练所以自动计算了。</p>\n<p>抛弃固有思维，现在假设@为81进制数的最大数，既80，再假设有一种操作符可以把十进制变成81进制数，这一过程是不是数据的计算？但如果有一种字体格式可以把连在一起的8和0两个数字变成@的样子，这算不算样式的改变？也许你会觉得通过操作符是在计算机中当做了@，而字体只是长得像，但计算机真正认识的只有可能是二进制binary，所以整个过程是不是也可以看做都是样式？还有人会说，数据无论变成什么样式它本身都不会变，而样式会变。但如果显示器有色差呢，你看到的蓝色就真的是蓝色吗？样式没变，你看到的仍然会变。</p>\n<p>其实数据和样式本质没有区别，区别只在于程度，从计算机到人类的理解程度。差异来自于我们自己，我们把难以理解的叫数据，容易理解的叫样式，计算时间长的叫数据，计算时间短的叫样式。一个矩形你知道是样式，一个长xx，宽xx，边框为xx的东西你会以为是数据，但对于程序来说其实是一样的。处理一下，得到另一种形式的等同的东西，这就是一个不断翻译的过程，从二进制翻译到人类语言，甚至到非语言的一种印象，比如视觉，语音，甚至意识。无论是什么，都是让人类更容易理解。</p>\n<h2 id=\"Component架构\"><a href=\"#Component架构\" class=\"headerlink\" title=\"Component架构\"></a>Component架构</h2><p>耗费了这么大的篇幅说明样式和数据没有区别的目的其实是为了解释React的架构。前面说到的MVC和MVVM其实都是对于View的一种演进，因为所谓View才是最复杂的，为什么说所谓呢，基于前面的结论，View就是Model，但它是人们难以理解的部分，所以没有被抽象为Model，而是直接显示出来让用户自己去读。为了便于理解，想象一种极端的情况，Model只有二进制形式，直接显示给了用户，理论上来说，用户是可以看懂的，只是难度高了一点点。而从View抽象成Model的过程，其实就是程序将二进制翻译出来的过程。而框架的所做的改进就是翻译程度的提升，让用户更容易的读取。</p>\n<p>回到React身上，它的架构就十分清晰了，前面的MVC是把后端的View分离出了一部分Model，而MVVM，是把MVC的V又分离了一部分Model出来。React所做的犹如它的版本号一般，直接起飞，每个Component其实都是View分离出来的Model，理论上来说，你能抽象出无限层Component，这个极限上，View已经简单的没有意义了。而实际来说，你可以视项目情况而定，把View抽象到某个程度后扔给用户自己阅读。而由于分成无数层，M到V的过程也变得简单，不再需要控制，因为复杂的计算已经被分解成了极简单的计算分散到每一层中了，甚至有时候仅仅是Component为传入的props加上一些字面量，然后传入另一个Component，或者是分解或组合成Object再向下传递。一旦真的理解了View即是Model的思想，你就会发现，React似乎什么也没做，其实却把什么都做了，而且非常简单。</p>\n<p>但Component这种架构也有其问题所在，那就是太过于松散，对架构设计的要求比较高。一旦你并非基于由机器到人类的理解程度来抽象分层你的Component，其复用性和扩展性就会大大降低。</p>\n<h2 id=\"前端面向对象\"><a href=\"#前端面向对象\" class=\"headerlink\" title=\"前端面向对象\"></a>前端面向对象</h2><p>前面说到了View和Model没有本质上的区别，那么前端架构和后端架构为什么会有区别呢？原因很简单，后端可以把未翻译完的数据丢给前端，但前端不能随随便便丢给用户，所以前端变成了多层MV，而不是后端简单的分为了一层MV。前端面向对象的设计也更加的困难，尤其是拥有多年后端开发经验的开发人员，更容易误导自己，因为在后端翻译完成的东西，在前端就变成了最原始的东西。</p>\n<p>举个例子，就拿最常见的电商说事吧，设计一个商品页面的Component架构。在拥有所谓数据的时候，它是某一个商品的页面，比如一件印着国旗的T恤。但显然我们的代码库在运行之前是没有这个从数据库传过来的数据的，所以我们没法把它抽象成一个叫做NationalFlagTShirtPage的Component的。退而求其次，在失去后端数据之后，它应该是一个衣服类的商品页面，比如有一些尺码对照和试衣功能，所以可以有一个叫做ClothesShowcase的Component。说到后端数据的这一层，并不是为了搞笑，它反映出了一个问题。其实后端对于前端，就是上一层的Component。同理，在下一层的Component中，我们也应该忽视这一层传入到下一层的数据，因为它不应该有这个数据。</p>\n<p>比如ClothesPage还应该包含一个显示图片的区域，和一个显示尺码信息的区域。这时，很多人会在ClothesShowcase的里面再放一个ClothesImage和ClothesInformation，但是在上一层作为代码一部分的’Clothes’，在这一层应该已经被忽略，我们应该放入ProductImage和SizeInformation。只有当ClothesPage调用SizeInformation并传入’S’，’M’，’L’之类衣服尺码作为参数的时候，它才是衣服尺寸，而它自身应该仅仅是尺寸信息的Component。我们会发现，上一层的代码（字面量’L’等），变成了下一层的数据，如此一直下去，所有的特性都会变成数据，而代码，可能仅仅是一些最基础的元素，比如按钮，方框之类的，甚至是HTML本身。</p>\n<p>如果一直使用对于后端来说的数据层面的’clothes’的话，就只能一次把ClothesPage这个Component写好，而没法继续抽象了。而其子Component可能仅仅是由于过于臃肿而强行分割的patial了。这样做除了代码短一些之外，完全不具有复用性和扩展性，因为ClothesPage下的所有Component都只能为Clothes服务了。而其他每个概念都必须把这一切重复一遍。</p>\n<p>如果走入另一种极端呢，抽象出一种万用Component，只要传入一个大而全的object，就可以渲染出任意的页面。这个时候虽然复用性有了，但是你会发现你什么也没做，因为这个Component就是HTML的另一层封装，那些传入的参数包含了所有数据，你需要把这些不同的数据同化。</p>\n<p>归根结底，Component架构的精髓在于多层，按照人类理解程度分层。否则永远无法分清楚什么是数据，什么是样式，因为它们只会在某一层中有划分。混乱的分层只会导致架构回归到传统的MVC两层结构中去。也因此，前端面向对象必须基于一层，脱离了某一层而论对象或类，都是可笑的，一个类，到了下一层可能就是一个实例。</p>"},{"layout":"post","title":"《重构》Refactoring","_content":"\n![Refactoring](/images/refactoring.jpg)以前上学的时候其实大概读过这本书，但是那时没有什么项目经验，对于重构还很难理解其意义，最近因为又读了一遍这本书，发现确实是很棒的一本书，虽然现在写javascript，而这本书是以java为基础的，但仍然有很多值得参考的地方，尤其是一些常见的重构手法，让人看的时就会觉得对对对，确实经常这么干，比如Extract method还有Replace array with object等等都可以应用到其他环境中。\n\n阅读这本书最重要的首先是需要理解的是什么是重构，以前也自诩会定期重构代码，但现在想想，其实真正算作重构的时候并不多，大部分时候我们其实只是在重写，只是因为项目规模较小，所以许多问题并没有暴露出来罢了。\n\n先看看重构的定义：“*对软件内部结构的一种调整，目的是在***不改变软件可观察行为***的前提下，提高其可理解性，降低其修改成本*”\n<!-- more -->\n也许有时候可以用一下午的时间把整个程序重写一边，但在它们臃肿到你可能需要更长时间甚至无法理解时，重写变的越来越遥不可及，最后只会更加臃肿不堪。所以重构与重写最大的区别，我认为应该是不改变软件可观察行为这一要素。另外它的目的或者说动机也就是要解决程序的无限膨胀，让程序变得更有可读性。\n\n重构手法不一定是在重构的时候使用，或者说重构无处不在，有时它也像是一种指导原则，比如什么时候应该使用继承，什么时候应该合并继承。它是动态的，重构手法的运用必须结合实际情况，所以有Pull up method 也有Push down method。情况在变化，代码也必须跟上这种变化。\n\n所以其实Javascript或者说前端开发是很需要重构的，因为前端开发的需求变化是最频繁的，情况也是各种各样。尤其是Javascript过于松散，只能靠代码规范去加强结构和可读性。但是书中很多重构手法仅限于面向对象的开发，还有一些Java的特性，比如Replace conditional with polymorphism，在Javascript中类似多态的机制就是用条件语句判断参数类型实现的。\n\n","source":"_posts/2013-05-04-refactoring.md","raw":"---\nlayout: post\ntitle: 《重构》Refactoring\ntags: [software,SE,软件工程,重构]\ncategory: Read\n---\n\n![Refactoring](/images/refactoring.jpg)以前上学的时候其实大概读过这本书，但是那时没有什么项目经验，对于重构还很难理解其意义，最近因为又读了一遍这本书，发现确实是很棒的一本书，虽然现在写javascript，而这本书是以java为基础的，但仍然有很多值得参考的地方，尤其是一些常见的重构手法，让人看的时就会觉得对对对，确实经常这么干，比如Extract method还有Replace array with object等等都可以应用到其他环境中。\n\n阅读这本书最重要的首先是需要理解的是什么是重构，以前也自诩会定期重构代码，但现在想想，其实真正算作重构的时候并不多，大部分时候我们其实只是在重写，只是因为项目规模较小，所以许多问题并没有暴露出来罢了。\n\n先看看重构的定义：“*对软件内部结构的一种调整，目的是在***不改变软件可观察行为***的前提下，提高其可理解性，降低其修改成本*”\n<!-- more -->\n也许有时候可以用一下午的时间把整个程序重写一边，但在它们臃肿到你可能需要更长时间甚至无法理解时，重写变的越来越遥不可及，最后只会更加臃肿不堪。所以重构与重写最大的区别，我认为应该是不改变软件可观察行为这一要素。另外它的目的或者说动机也就是要解决程序的无限膨胀，让程序变得更有可读性。\n\n重构手法不一定是在重构的时候使用，或者说重构无处不在，有时它也像是一种指导原则，比如什么时候应该使用继承，什么时候应该合并继承。它是动态的，重构手法的运用必须结合实际情况，所以有Pull up method 也有Push down method。情况在变化，代码也必须跟上这种变化。\n\n所以其实Javascript或者说前端开发是很需要重构的，因为前端开发的需求变化是最频繁的，情况也是各种各样。尤其是Javascript过于松散，只能靠代码规范去加强结构和可读性。但是书中很多重构手法仅限于面向对象的开发，还有一些Java的特性，比如Replace conditional with polymorphism，在Javascript中类似多态的机制就是用条件语句判断参数类型实现的。\n\n","slug":"refactoring","published":1,"date":"2013-05-03T16:00:00.000Z","updated":"2021-11-28T11:59:29.970Z","_id":"ckwj6i0430000evjh8ztd7g3r","comments":1,"photos":[],"link":"","content":"<p><img src=\"/images/refactoring.jpg\" alt=\"Refactoring\">以前上学的时候其实大概读过这本书，但是那时没有什么项目经验，对于重构还很难理解其意义，最近因为又读了一遍这本书，发现确实是很棒的一本书，虽然现在写javascript，而这本书是以java为基础的，但仍然有很多值得参考的地方，尤其是一些常见的重构手法，让人看的时就会觉得对对对，确实经常这么干，比如Extract method还有Replace array with object等等都可以应用到其他环境中。</p>\n<p>阅读这本书最重要的首先是需要理解的是什么是重构，以前也自诩会定期重构代码，但现在想想，其实真正算作重构的时候并不多，大部分时候我们其实只是在重写，只是因为项目规模较小，所以许多问题并没有暴露出来罢了。</p>\n<p>先看看重构的定义：“<em>对软件内部结构的一种调整，目的是在</em><strong>不改变软件可观察行为</strong><em>的前提下，提高其可理解性，降低其修改成本</em>”</p>\n<span id=\"more\"></span>\n<p>也许有时候可以用一下午的时间把整个程序重写一边，但在它们臃肿到你可能需要更长时间甚至无法理解时，重写变的越来越遥不可及，最后只会更加臃肿不堪。所以重构与重写最大的区别，我认为应该是不改变软件可观察行为这一要素。另外它的目的或者说动机也就是要解决程序的无限膨胀，让程序变得更有可读性。</p>\n<p>重构手法不一定是在重构的时候使用，或者说重构无处不在，有时它也像是一种指导原则，比如什么时候应该使用继承，什么时候应该合并继承。它是动态的，重构手法的运用必须结合实际情况，所以有Pull up method 也有Push down method。情况在变化，代码也必须跟上这种变化。</p>\n<p>所以其实Javascript或者说前端开发是很需要重构的，因为前端开发的需求变化是最频繁的，情况也是各种各样。尤其是Javascript过于松散，只能靠代码规范去加强结构和可读性。但是书中很多重构手法仅限于面向对象的开发，还有一些Java的特性，比如Replace conditional with polymorphism，在Javascript中类似多态的机制就是用条件语句判断参数类型实现的。</p>\n","site":{"data":{}},"excerpt":"<p><img src=\"/images/refactoring.jpg\" alt=\"Refactoring\">以前上学的时候其实大概读过这本书，但是那时没有什么项目经验，对于重构还很难理解其意义，最近因为又读了一遍这本书，发现确实是很棒的一本书，虽然现在写javascript，而这本书是以java为基础的，但仍然有很多值得参考的地方，尤其是一些常见的重构手法，让人看的时就会觉得对对对，确实经常这么干，比如Extract method还有Replace array with object等等都可以应用到其他环境中。</p>\n<p>阅读这本书最重要的首先是需要理解的是什么是重构，以前也自诩会定期重构代码，但现在想想，其实真正算作重构的时候并不多，大部分时候我们其实只是在重写，只是因为项目规模较小，所以许多问题并没有暴露出来罢了。</p>\n<p>先看看重构的定义：“<em>对软件内部结构的一种调整，目的是在</em><strong>不改变软件可观察行为</strong><em>的前提下，提高其可理解性，降低其修改成本</em>”</p>","more":"<p>也许有时候可以用一下午的时间把整个程序重写一边，但在它们臃肿到你可能需要更长时间甚至无法理解时，重写变的越来越遥不可及，最后只会更加臃肿不堪。所以重构与重写最大的区别，我认为应该是不改变软件可观察行为这一要素。另外它的目的或者说动机也就是要解决程序的无限膨胀，让程序变得更有可读性。</p>\n<p>重构手法不一定是在重构的时候使用，或者说重构无处不在，有时它也像是一种指导原则，比如什么时候应该使用继承，什么时候应该合并继承。它是动态的，重构手法的运用必须结合实际情况，所以有Pull up method 也有Push down method。情况在变化，代码也必须跟上这种变化。</p>\n<p>所以其实Javascript或者说前端开发是很需要重构的，因为前端开发的需求变化是最频繁的，情况也是各种各样。尤其是Javascript过于松散，只能靠代码规范去加强结构和可读性。但是书中很多重构手法仅限于面向对象的开发，还有一些Java的特性，比如Replace conditional with polymorphism，在Javascript中类似多态的机制就是用条件语句判断参数类型实现的。</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"ckwj6550n0000vyjh838xcfma","category_id":"ckwj6550t0002vyjh2knef928","_id":"ckwj65510000cvyjh5e9gd2jg"},{"post_id":"ckwj6550x0006vyjhcxjh7d20","category_id":"ckwj6550t0002vyjh2knef928","_id":"ckwj65511000fvyjh3g4ah6sw"},{"post_id":"ckwj6550s0001vyjhdl7lbeii","category_id":"ckwj6550t0002vyjh2knef928","_id":"ckwj65512000ivyjhcp826m19"},{"post_id":"ckwj6550z000avyjhhdf1citf","category_id":"ckwj6550t0002vyjh2knef928","_id":"ckwj65514000lvyjh41tx1qad"},{"post_id":"ckwj65511000evyjhd18o2abm","category_id":"ckwj6550t0002vyjh2knef928","_id":"ckwj65515000nvyjhdkux4m85"},{"post_id":"ckwj6550v0004vyjha4wa1gaq","category_id":"ckwj6550t0002vyjh2knef928","_id":"ckwj65516000rvyjhdzob690s"},{"post_id":"ckwj65511000gvyjhbktl1ivx","category_id":"ckwj6550t0002vyjh2knef928","_id":"ckwj65517000uvyjhggo7gir4"},{"post_id":"ckwj65513000kvyjhc06b2b53","category_id":"ckwj6550t0002vyjh2knef928","_id":"ckwj65518000xvyjh0fgc50jv"},{"post_id":"ckwj65514000mvyjh6tk37pve","category_id":"ckwj6550t0002vyjh2knef928","_id":"ckwj6551a0014vyjhc3lh2njt"},{"post_id":"ckwj65516000qvyjhbf6h5t3m","category_id":"ckwj6550t0002vyjh2knef928","_id":"ckwj6551a0017vyjh3xg15dgb"},{"post_id":"ckwj6550y0009vyjh7nzha2jd","category_id":"ckwj65512000hvyjh5v541b43","_id":"ckwj6551b0019vyjheq8w0z4p"},{"post_id":"ckwj65517000tvyjhfc9aa20u","category_id":"ckwj65512000hvyjh5v541b43","_id":"ckwj6551c001cvyjh7dk4h0aj"},{"post_id":"ckwj65518000wvyjhdrpietit","category_id":"ckwj6550t0002vyjh2knef928","_id":"ckwj6551c001fvyjhcy1n6v99"},{"post_id":"ckwj655190010vyjh2sbc3c3n","category_id":"ckwj6550t0002vyjh2knef928","_id":"ckwj6551d001hvyjhawtv5w25"},{"post_id":"ckwj655190013vyjh5pll4fuf","category_id":"ckwj6550t0002vyjh2knef928","_id":"ckwj6551d001kvyjh091u4ye7"},{"post_id":"ckwj6551a0016vyjhg56w5tni","category_id":"ckwj6550t0002vyjh2knef928","_id":"ckwj6551e001mvyjhb8ie6lly"},{"post_id":"ckwj6551c001evyjha7rzc6rw","category_id":"ckwj6550t0002vyjh2knef928","_id":"ckwj6551e001pvyjh2phd5lrd"},{"post_id":"ckwj6551b0018vyjhda56gq96","category_id":"ckwj6551c001dvyjh7qod5ezr","_id":"ckwj6551e001rvyjh7hmd4zc2"},{"post_id":"ckwj6551b001bvyjh61hdhy9w","category_id":"ckwj6551c001dvyjh7qod5ezr","_id":"ckwj6551e001tvyjh7gf04gzp"},{"post_id":"ckwj6i0430000evjh8ztd7g3r","category_id":"ckwj65512000hvyjh5v541b43","_id":"ckwj6i0460003evjh0xtcf0gp"}],"PostTag":[{"post_id":"ckwj6550n0000vyjh838xcfma","tag_id":"ckwj6550u0003vyjhcuvm03kd","_id":"ckwj65517000svyjhbtm42ep8"},{"post_id":"ckwj6550n0000vyjh838xcfma","tag_id":"ckwj6550x0008vyjhaztz66s7","_id":"ckwj65518000vvyjhcinw9djk"},{"post_id":"ckwj6550n0000vyjh838xcfma","tag_id":"ckwj65510000dvyjhbvb2dt2h","_id":"ckwj65519000zvyjh2sul5tb3"},{"post_id":"ckwj6550n0000vyjh838xcfma","tag_id":"ckwj65512000jvyjhchzqdf69","_id":"ckwj655190012vyjha9ryemw5"},{"post_id":"ckwj6550s0001vyjhdl7lbeii","tag_id":"ckwj65515000pvyjhf5fx3ort","_id":"ckwj6551d001ivyjhb4ldbx1t"},{"post_id":"ckwj6550s0001vyjhdl7lbeii","tag_id":"ckwj65518000yvyjha2rl809r","_id":"ckwj6551d001lvyjh9jbr27mi"},{"post_id":"ckwj6550s0001vyjhdl7lbeii","tag_id":"ckwj6551a0015vyjhak1vbng4","_id":"ckwj6551e001ovyjh2usx5hrm"},{"post_id":"ckwj6550s0001vyjhdl7lbeii","tag_id":"ckwj6551b001avyjh54mp39z9","_id":"ckwj6551e001qvyjhgy2dg2ur"},{"post_id":"ckwj6550v0004vyjha4wa1gaq","tag_id":"ckwj6551d001gvyjh2uau0fh6","_id":"ckwj6551f001vvyjhc1j215wy"},{"post_id":"ckwj6550v0004vyjha4wa1gaq","tag_id":"ckwj6551e001nvyjhbmh37i6b","_id":"ckwj6551f001wvyjh29b14llb"},{"post_id":"ckwj6550v0004vyjha4wa1gaq","tag_id":"ckwj6551e001svyjh2cldhrow","_id":"ckwj6551f001yvyjh23b28gz0"},{"post_id":"ckwj6550x0006vyjhcxjh7d20","tag_id":"ckwj6551g0021vyjhgdi77e0c","_id":"ckwj6551i002cvyjhbdwre8ah"},{"post_id":"ckwj6550x0006vyjhcxjh7d20","tag_id":"ckwj6551h0024vyjhexpy9r4x","_id":"ckwj6551i002dvyjha2gf2hfg"},{"post_id":"ckwj6550x0006vyjhcxjh7d20","tag_id":"ckwj6551h0027vyjh1b75g059","_id":"ckwj6551i002fvyjh28d25rd2"},{"post_id":"ckwj6550x0006vyjhcxjh7d20","tag_id":"ckwj6551h0028vyjhfcvzeu7l","_id":"ckwj6551j002gvyjh628zb08r"},{"post_id":"ckwj6550x0006vyjhcxjh7d20","tag_id":"ckwj6551i0029vyjh2w2xdfmz","_id":"ckwj6551j002ivyjh7wnma9ge"},{"post_id":"ckwj6550x0006vyjhcxjh7d20","tag_id":"ckwj6551i002avyjh39pgbj08","_id":"ckwj6551j002jvyjhgmm528ct"},{"post_id":"ckwj6550y0009vyjh7nzha2jd","tag_id":"ckwj6551e001uvyjhdbusf4r1","_id":"ckwj6551k002ovyjhakkm524i"},{"post_id":"ckwj6550y0009vyjh7nzha2jd","tag_id":"ckwj6551f001xvyjh4g438kj6","_id":"ckwj6551k002pvyjh0ei901vl"},{"post_id":"ckwj6550y0009vyjh7nzha2jd","tag_id":"ckwj6551j002hvyjh75e4244s","_id":"ckwj6551k002rvyjh7n390jlv"},{"post_id":"ckwj6550y0009vyjh7nzha2jd","tag_id":"ckwj6551j002kvyjh4pz27i56","_id":"ckwj6551k002svyjh02xrcxvr"},{"post_id":"ckwj6550y0009vyjh7nzha2jd","tag_id":"ckwj6551f001zvyjhhcwp3qc7","_id":"ckwj6551k002uvyjhb1tq515z"},{"post_id":"ckwj6550y0009vyjh7nzha2jd","tag_id":"ckwj6551j002mvyjh91yaaln6","_id":"ckwj6551k002vvyjhckeg79qn"},{"post_id":"ckwj6550z000avyjhhdf1citf","tag_id":"ckwj6551g0021vyjhgdi77e0c","_id":"ckwj6551l002zvyjh0ym21i7h"},{"post_id":"ckwj6550z000avyjhhdf1citf","tag_id":"ckwj6551h0024vyjhexpy9r4x","_id":"ckwj6551l0030vyjhfy849weu"},{"post_id":"ckwj6550z000avyjhhdf1citf","tag_id":"ckwj6551k002tvyjh7je55irz","_id":"ckwj6551l0032vyjhavxx710k"},{"post_id":"ckwj6550z000avyjhhdf1citf","tag_id":"ckwj6551k002wvyjhdoia87a9","_id":"ckwj6551l0033vyjhg2jbb251"},{"post_id":"ckwj6550z000avyjhhdf1citf","tag_id":"ckwj6551l002xvyjh123iagvt","_id":"ckwj6551m0035vyjher7udxvy"},{"post_id":"ckwj65511000evyjhd18o2abm","tag_id":"ckwj6551l002yvyjhgjnv33x3","_id":"ckwj6551n003bvyjhbyoi9e2y"},{"post_id":"ckwj65511000evyjhd18o2abm","tag_id":"ckwj6551l0031vyjhaisqeqdf","_id":"ckwj6551n003cvyjh9p108awx"},{"post_id":"ckwj65511000evyjhd18o2abm","tag_id":"ckwj6551m0034vyjh74pg4i9q","_id":"ckwj6551n003evyjhgwtj52r6"},{"post_id":"ckwj65511000evyjhd18o2abm","tag_id":"ckwj6551m0036vyjh0sj8f3zh","_id":"ckwj6551n003fvyjhg73q611b"},{"post_id":"ckwj65511000evyjhd18o2abm","tag_id":"ckwj6551m0037vyjh3pm71lui","_id":"ckwj6551n003hvyjh29c119ma"},{"post_id":"ckwj65511000evyjhd18o2abm","tag_id":"ckwj6551m0038vyjhf9n808ca","_id":"ckwj6551n003ivyjh1f6t3e3k"},{"post_id":"ckwj65511000evyjhd18o2abm","tag_id":"ckwj6551m0039vyjhgfnn3g1k","_id":"ckwj6551n003kvyjhdfvf82pc"},{"post_id":"ckwj65511000gvyjhbktl1ivx","tag_id":"ckwj6551n003avyjhfyrxek7s","_id":"ckwj6551o003qvyjh0ue02nse"},{"post_id":"ckwj65511000gvyjhbktl1ivx","tag_id":"ckwj6551n003dvyjhf05j5nd2","_id":"ckwj6551p003rvyjh7zj98lfg"},{"post_id":"ckwj65511000gvyjhbktl1ivx","tag_id":"ckwj6551n003gvyjh8x0tc8wi","_id":"ckwj6551p003tvyjhdibe1g0l"},{"post_id":"ckwj65511000gvyjhbktl1ivx","tag_id":"ckwj6551n003jvyjh0qnf5xg2","_id":"ckwj6551p003uvyjhc0a9gr0j"},{"post_id":"ckwj65511000gvyjhbktl1ivx","tag_id":"ckwj6551o003lvyjh6wnn37fz","_id":"ckwj6551p003wvyjh48yb8rvm"},{"post_id":"ckwj65511000gvyjhbktl1ivx","tag_id":"ckwj6551o003mvyjh0bj1b9il","_id":"ckwj6551p003xvyjhc2nv96b6"},{"post_id":"ckwj65511000gvyjhbktl1ivx","tag_id":"ckwj6551o003nvyjhdtfq424e","_id":"ckwj6551p003zvyjh8rwzgj3i"},{"post_id":"ckwj65511000gvyjhbktl1ivx","tag_id":"ckwj6551o003ovyjh5yz33mj5","_id":"ckwj6551p0040vyjhedn9gnyk"},{"post_id":"ckwj65513000kvyjhc06b2b53","tag_id":"ckwj65518000yvyjha2rl809r","_id":"ckwj6551q0042vyjh4mvia1l0"},{"post_id":"ckwj65513000kvyjhc06b2b53","tag_id":"ckwj65515000pvyjhf5fx3ort","_id":"ckwj6551q0043vyjhcigacxs4"},{"post_id":"ckwj65513000kvyjhc06b2b53","tag_id":"ckwj6551p003vvyjh2rnq62fv","_id":"ckwj6551q0045vyjhafad5oo1"},{"post_id":"ckwj65513000kvyjhc06b2b53","tag_id":"ckwj6551p003yvyjh6rp2cblx","_id":"ckwj6551q0046vyjhcsle9c26"},{"post_id":"ckwj65514000mvyjh6tk37pve","tag_id":"ckwj6551p0041vyjh1t3u6af7","_id":"ckwj6551s004evyjh63ejau0w"},{"post_id":"ckwj65514000mvyjh6tk37pve","tag_id":"ckwj6551q0044vyjhe4abeil2","_id":"ckwj6551s004fvyjh0lbue2j5"},{"post_id":"ckwj65514000mvyjh6tk37pve","tag_id":"ckwj6551q0047vyjhb3ni8ogz","_id":"ckwj6551s004hvyjhgbiu4ocl"},{"post_id":"ckwj65514000mvyjh6tk37pve","tag_id":"ckwj6551r0048vyjh9kz2a5gi","_id":"ckwj6551s004ivyjha7vt8nou"},{"post_id":"ckwj65514000mvyjh6tk37pve","tag_id":"ckwj6551r0049vyjh7ol8gacb","_id":"ckwj6551s004kvyjh348jd0z9"},{"post_id":"ckwj65514000mvyjh6tk37pve","tag_id":"ckwj6551d001gvyjh2uau0fh6","_id":"ckwj6551s004lvyjhdrnidmwi"},{"post_id":"ckwj65514000mvyjh6tk37pve","tag_id":"ckwj6551r004bvyjh3swfh532","_id":"ckwj6551s004nvyjhgf22ay13"},{"post_id":"ckwj65514000mvyjh6tk37pve","tag_id":"ckwj6551r004cvyjh8mfh2en9","_id":"ckwj6551t004ovyjh2xftbt7a"},{"post_id":"ckwj65516000qvyjhbf6h5t3m","tag_id":"ckwj6551s004dvyjham29hojp","_id":"ckwj6551t004qvyjh4nnag2yk"},{"post_id":"ckwj65516000qvyjhbf6h5t3m","tag_id":"ckwj6551s004gvyjhgli51cj7","_id":"ckwj6551t004rvyjh6wqe103s"},{"post_id":"ckwj65516000qvyjhbf6h5t3m","tag_id":"ckwj6551s004jvyjhcso0f7qy","_id":"ckwj6551t004tvyjh7rmv9xfh"},{"post_id":"ckwj65516000qvyjhbf6h5t3m","tag_id":"ckwj6551s004mvyjhczgyctx5","_id":"ckwj6551t004uvyjh3gy4gpbw"},{"post_id":"ckwj65517000tvyjhfc9aa20u","tag_id":"ckwj6551e001uvyjhdbusf4r1","_id":"ckwj6551u004yvyjhhxcnh0qw"},{"post_id":"ckwj65517000tvyjhfc9aa20u","tag_id":"ckwj6551f001xvyjh4g438kj6","_id":"ckwj6551u004zvyjh7u5q04rk"},{"post_id":"ckwj65517000tvyjhfc9aa20u","tag_id":"ckwj6551f001zvyjhhcwp3qc7","_id":"ckwj6551u0051vyjhd7m3b5np"},{"post_id":"ckwj65517000tvyjhfc9aa20u","tag_id":"ckwj6551t004wvyjh0hui57a1","_id":"ckwj6551u0052vyjhd7jhejzf"},{"post_id":"ckwj65518000wvyjhdrpietit","tag_id":"ckwj6551s004dvyjham29hojp","_id":"ckwj6551v0056vyjhh1k783p1"},{"post_id":"ckwj65518000wvyjhdrpietit","tag_id":"ckwj6551u0050vyjhe0p65twy","_id":"ckwj6551v0057vyjh1elmgwmc"},{"post_id":"ckwj65518000wvyjhdrpietit","tag_id":"ckwj6551u0053vyjhbfla9c52","_id":"ckwj6551v0059vyjh9ql26731"},{"post_id":"ckwj65518000wvyjhdrpietit","tag_id":"ckwj6551u0054vyjh5bb1b9py","_id":"ckwj6551v005avyjh0nusc7lu"},{"post_id":"ckwj655190010vyjh2sbc3c3n","tag_id":"ckwj6551u0055vyjh8rr92w51","_id":"ckwj6551w005evyjh1r9c7lp9"},{"post_id":"ckwj655190010vyjh2sbc3c3n","tag_id":"ckwj6551v0058vyjh8ts43pzh","_id":"ckwj6551w005fvyjhg0w65od2"},{"post_id":"ckwj655190010vyjh2sbc3c3n","tag_id":"ckwj6551v005bvyjh03t3a6m6","_id":"ckwj6551w005hvyjhh7gc338d"},{"post_id":"ckwj655190010vyjh2sbc3c3n","tag_id":"ckwj6551v005cvyjhdl8l5lns","_id":"ckwj6551w005ivyjh2qdlgblq"},{"post_id":"ckwj655190013vyjh5pll4fuf","tag_id":"ckwj6551s004dvyjham29hojp","_id":"ckwj6551x005lvyjh4drw97oo"},{"post_id":"ckwj655190013vyjh5pll4fuf","tag_id":"ckwj6551w005gvyjhcyyr4fe6","_id":"ckwj6551y005mvyjhf5q28f1s"},{"post_id":"ckwj655190013vyjh5pll4fuf","tag_id":"ckwj6551w005jvyjhfnp3hl11","_id":"ckwj6551y005ovyjh6b075b7c"},{"post_id":"ckwj6551a0016vyjhg56w5tni","tag_id":"ckwj6551s004dvyjham29hojp","_id":"ckwj6551y005svyjh4ny69771"},{"post_id":"ckwj6551a0016vyjhg56w5tni","tag_id":"ckwj6551w005gvyjhcyyr4fe6","_id":"ckwj6551z005tvyjhg48xbdtd"},{"post_id":"ckwj6551a0016vyjhg56w5tni","tag_id":"ckwj6551w005jvyjhfnp3hl11","_id":"ckwj6551z005vvyjhakc66g3b"},{"post_id":"ckwj6551a0016vyjhg56w5tni","tag_id":"ckwj6551y005qvyjhgpunefe2","_id":"ckwj6551z005wvyjh0o65373m"},{"post_id":"ckwj6551b0018vyjhda56gq96","tag_id":"ckwj6551y005rvyjh66fr5o0z","_id":"ckwj65520005zvyjh3wwmgc6u"},{"post_id":"ckwj6551b0018vyjhda56gq96","tag_id":"ckwj6551v005bvyjh03t3a6m6","_id":"ckwj655200060vyjhd2sg9gy7"},{"post_id":"ckwj6551b0018vyjhda56gq96","tag_id":"ckwj6551u0055vyjh8rr92w51","_id":"ckwj655210062vyjhbi6ndwe1"},{"post_id":"ckwj6551b001bvyjh61hdhy9w","tag_id":"ckwj6551z005yvyjh62ep7tlv","_id":"ckwj655210066vyjhd2cce5od"},{"post_id":"ckwj6551b001bvyjh61hdhy9w","tag_id":"ckwj655200061vyjhh0dr5ybj","_id":"ckwj655210067vyjh7rwp70z6"},{"post_id":"ckwj6551b001bvyjh61hdhy9w","tag_id":"ckwj655210063vyjh0hdvfzwf","_id":"ckwj655220069vyjh38svchgy"},{"post_id":"ckwj6551b001bvyjh61hdhy9w","tag_id":"ckwj655210064vyjh98ohbrqi","_id":"ckwj65522006avyjhbuka9jby"},{"post_id":"ckwj6551c001evyjha7rzc6rw","tag_id":"ckwj655210065vyjh6nnr6poq","_id":"ckwj65522006evyjhefqjfk56"},{"post_id":"ckwj6551c001evyjha7rzc6rw","tag_id":"ckwj655210068vyjh1okhbxkk","_id":"ckwj65523006fvyjh2r1le8p0"},{"post_id":"ckwj6551c001evyjha7rzc6rw","tag_id":"ckwj65522006bvyjh7wrf7qhl","_id":"ckwj65523006gvyjhfmlt3xpp"},{"post_id":"ckwj6551c001evyjha7rzc6rw","tag_id":"ckwj65522006cvyjha5do86l2","_id":"ckwj65523006hvyjh4e5b9t9a"},{"post_id":"ckwj6551c001evyjha7rzc6rw","tag_id":"ckwj65522006dvyjh3y2ld9b3","_id":"ckwj65523006ivyjh8atgawna"},{"post_id":"ckwj6i0430000evjh8ztd7g3r","tag_id":"ckwj6551e001uvyjhdbusf4r1","_id":"ckwj6i0460001evjh7cpee04k"},{"post_id":"ckwj6i0430000evjh8ztd7g3r","tag_id":"ckwj6551f001xvyjh4g438kj6","_id":"ckwj6i0460002evjh246edqnj"},{"post_id":"ckwj6i0430000evjh8ztd7g3r","tag_id":"ckwj6551f001zvyjhhcwp3qc7","_id":"ckwj6i0460004evjh46x9blmg"},{"post_id":"ckwj6i0430000evjh8ztd7g3r","tag_id":"ckwj6551g0020vyjh6pcshq9r","_id":"ckwj6i0470005evjhcmr17qjb"}],"Tag":[{"name":"http","_id":"ckwj6550u0003vyjhcuvm03kd"},{"name":"https","_id":"ckwj6550x0008vyjhaztz66s7"},{"name":"protocol","_id":"ckwj65510000dvyjhbvb2dt2h"},{"name":"协议","_id":"ckwj65512000jvyjhchzqdf69"},{"name":"html","_id":"ckwj65515000pvyjhf5fx3ort"},{"name":"html5","_id":"ckwj65518000yvyjha2rl809r"},{"name":"mouse look","_id":"ckwj6551a0015vyjhak1vbng4"},{"name":"鼠标视角","_id":"ckwj6551b001avyjh54mp39z9"},{"name":"github","_id":"ckwj6551d001gvyjh2uau0fh6"},{"name":"jekyll","_id":"ckwj6551e001nvyjhbmh37i6b"},{"name":"pages","_id":"ckwj6551e001svyjh2cldhrow"},{"name":"software","_id":"ckwj6551e001uvyjhdbusf4r1"},{"name":"SE","_id":"ckwj6551f001xvyjh4g438kj6"},{"name":"软件工程","_id":"ckwj6551f001zvyjhhcwp3qc7"},{"name":"重构","_id":"ckwj6551g0020vyjh6pcshq9r"},{"name":"tool","_id":"ckwj6551g0021vyjhgdi77e0c"},{"name":"recommend","_id":"ckwj6551h0024vyjhexpy9r4x"},{"name":"color","_id":"ckwj6551h0027vyjh1b75g059"},{"name":"颜色","_id":"ckwj6551h0028vyjhfcvzeu7l"},{"name":"调色","_id":"ckwj6551i0029vyjh2w2xdfmz"},{"name":"配色","_id":"ckwj6551i002avyjh39pgbj08"},{"name":"program","_id":"ckwj6551j002hvyjh75e4244s"},{"name":"code","_id":"ckwj6551j002kvyjh4pz27i56"},{"name":"编程珠玑","_id":"ckwj6551j002mvyjh91yaaln6"},{"name":"image","_id":"ckwj6551k002tvyjh7je55irz"},{"name":"图片","_id":"ckwj6551k002wvyjhdoia87a9"},{"name":"工具","_id":"ckwj6551l002xvyjh123iagvt"},{"name":"Javascript","_id":"ckwj6551l002yvyjhgjnv33x3"},{"name":"event","_id":"ckwj6551l0031vyjhaisqeqdf"},{"name":"which","_id":"ckwj6551m0034vyjh74pg4i9q"},{"name":"keycode","_id":"ckwj6551m0036vyjh0sj8f3zh"},{"name":"charcode","_id":"ckwj6551m0037vyjh3pm71lui"},{"name":"unicode","_id":"ckwj6551m0038vyjhf9n808ca"},{"name":"事件","_id":"ckwj6551m0039vyjhgfnn3g1k"},{"name":"test","_id":"ckwj6551n003avyjhfyrxek7s"},{"name":"unit","_id":"ckwj6551n003dvyjhf05j5nd2"},{"name":"jasmine","_id":"ckwj6551n003gvyjh8x0tc8wi"},{"name":"CI","_id":"ckwj6551n003jvyjh0qnf5xg2"},{"name":"karma","_id":"ckwj6551o003lvyjh6wnn37fz"},{"name":"单元测试","_id":"ckwj6551o003mvyjh0bj1b9il"},{"name":"TDD","_id":"ckwj6551o003nvyjhdtfq424e"},{"name":"BDD","_id":"ckwj6551o003ovyjh5yz33mj5"},{"name":"file","_id":"ckwj6551p003vvyjh2rnq62fv"},{"name":"upload","_id":"ckwj6551p003yvyjh6rp2cblx"},{"name":"workflow","_id":"ckwj6551p0041vyjh1t3u6af7"},{"name":"grunt","_id":"ckwj6551q0044vyjhe4abeil2"},{"name":"bower","_id":"ckwj6551q0047vyjhb3ni8ogz"},{"name":"sublime text","_id":"ckwj6551r0048vyjh9kz2a5gi"},{"name":"chrome","_id":"ckwj6551r0049vyjh7ol8gacb"},{"name":"git","_id":"ckwj6551r004bvyjh3swfh532"},{"name":"node","_id":"ckwj6551r004cvyjh8mfh2en9"},{"name":"css","_id":"ckwj6551s004dvyjham29hojp"},{"name":"stylus","_id":"ckwj6551s004gvyjhgli51cj7"},{"name":"sass","_id":"ckwj6551s004jvyjhcso0f7qy"},{"name":"less","_id":"ckwj6551s004mvyjhczgyctx5"},{"name":"代码整洁","_id":"ckwj6551t004wvyjh0hui57a1"},{"name":"oocss","_id":"ckwj6551u0050vyjhe0p65twy"},{"name":"drycss","_id":"ckwj6551u0053vyjhbfla9c52"},{"name":"smacss","_id":"ckwj6551u0054vyjh5bb1b9py"},{"name":"javascript","_id":"ckwj6551u0055vyjh8rr92w51"},{"name":"angular","_id":"ckwj6551v0058vyjh8ts43pzh"},{"name":"angularjs","_id":"ckwj6551v005bvyjh03t3a6m6"},{"name":"template","_id":"ckwj6551v005cvyjhdl8l5lns"},{"name":"style","_id":"ckwj6551w005gvyjhcyyr4fe6"},{"name":"front-end","_id":"ckwj6551w005jvyjhfnp3hl11"},{"name":"fivewhys","_id":"ckwj6551y005qvyjhgpunefe2"},{"name":"translate","_id":"ckwj6551y005rvyjh66fr5o0z"},{"name":"agile","_id":"ckwj6551z005yvyjh62ep7tlv"},{"name":"development","_id":"ckwj655200061vyjhh0dr5ybj"},{"name":"thinking","_id":"ckwj655210063vyjh0hdvfzwf"},{"name":"clastic","_id":"ckwj655210064vyjh98ohbrqi"},{"name":"mvc","_id":"ckwj655210065vyjh6nnr6poq"},{"name":"mvvm","_id":"ckwj655210068vyjh1okhbxkk"},{"name":"react","_id":"ckwj65522006bvyjh7wrf7qhl"},{"name":"architecture","_id":"ckwj65522006cvyjha5do86l2"},{"name":"frontend","_id":"ckwj65522006dvyjh3y2ld9b3"}]}}